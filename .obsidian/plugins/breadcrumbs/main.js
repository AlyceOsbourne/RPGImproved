/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/graphology/dist/graphology.umd.min.js
var require_graphology_umd_min = __commonJS({
  "node_modules/graphology/dist/graphology.umd.min.js"(exports, module2) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).graphology = e();
    }(exports, function() {
      "use strict";
      function t(e2) {
        return t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t2) {
          return typeof t2;
        } : function(t2) {
          return t2 && "function" == typeof Symbol && t2.constructor === Symbol && t2 !== Symbol.prototype ? "symbol" : typeof t2;
        }, t(e2);
      }
      function e(t2, e2) {
        t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, r(t2, e2);
      }
      function n2(t2) {
        return n2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
          return t3.__proto__ || Object.getPrototypeOf(t3);
        }, n2(t2);
      }
      function r(t2, e2) {
        return r = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
          return t3.__proto__ = e3, t3;
        }, r(t2, e2);
      }
      function i() {
        if ("undefined" == typeof Reflect || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if ("function" == typeof Proxy)
          return true;
        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          })), true;
        } catch (t2) {
          return false;
        }
      }
      function o(t2, e2, n3) {
        return o = i() ? Reflect.construct.bind() : function(t3, e3, n4) {
          var i2 = [null];
          i2.push.apply(i2, e3);
          var o2 = new (Function.bind.apply(t3, i2))();
          return n4 && r(o2, n4.prototype), o2;
        }, o.apply(null, arguments);
      }
      function a(t2) {
        var e2 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
        return a = function(t3) {
          if (null === t3 || (i2 = t3, -1 === Function.toString.call(i2).indexOf("[native code]")))
            return t3;
          var i2;
          if ("function" != typeof t3)
            throw new TypeError("Super expression must either be null or a function");
          if (void 0 !== e2) {
            if (e2.has(t3))
              return e2.get(t3);
            e2.set(t3, a2);
          }
          function a2() {
            return o(t3, arguments, n2(this).constructor);
          }
          return a2.prototype = Object.create(t3.prototype, { constructor: { value: a2, enumerable: false, writable: true, configurable: true } }), r(a2, t3);
        }, a(t2);
      }
      function c(t2) {
        if (void 0 === t2)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t2;
      }
      var u = function() {
        for (var t2 = arguments[0], e2 = 1, n3 = arguments.length; e2 < n3; e2++)
          if (arguments[e2])
            for (var r2 in arguments[e2])
              t2[r2] = arguments[e2][r2];
        return t2;
      };
      function d(t2, e2, n3, r2) {
        var i2 = t2._nodes.get(e2), o2 = null;
        return i2 ? o2 = "mixed" === r2 ? i2.out && i2.out[n3] || i2.undirected && i2.undirected[n3] : "directed" === r2 ? i2.out && i2.out[n3] : i2.undirected && i2.undirected[n3] : o2;
      }
      function s2(e2) {
        return "object" === t(e2) && null !== e2;
      }
      function h(t2) {
        var e2;
        for (e2 in t2)
          return false;
        return true;
      }
      function p(t2, e2, n3) {
        Object.defineProperty(t2, e2, { enumerable: false, configurable: false, writable: true, value: n3 });
      }
      function f(t2, e2, n3) {
        var r2 = { enumerable: true, configurable: true };
        "function" == typeof n3 ? r2.get = n3 : (r2.value = n3, r2.writable = false), Object.defineProperty(t2, e2, r2);
      }
      function l2(t2) {
        return !!s2(t2) && !(t2.attributes && !Array.isArray(t2.attributes));
      }
      "function" == typeof Object.assign && (u = Object.assign);
      var g, y = { exports: {} }, w = "object" == typeof Reflect ? Reflect : null, v = w && "function" == typeof w.apply ? w.apply : function(t2, e2, n3) {
        return Function.prototype.apply.call(t2, e2, n3);
      };
      g = w && "function" == typeof w.ownKeys ? w.ownKeys : Object.getOwnPropertySymbols ? function(t2) {
        return Object.getOwnPropertyNames(t2).concat(Object.getOwnPropertySymbols(t2));
      } : function(t2) {
        return Object.getOwnPropertyNames(t2);
      };
      var b = Number.isNaN || function(t2) {
        return t2 != t2;
      };
      function m() {
        m.init.call(this);
      }
      y.exports = m, y.exports.once = function(t2, e2) {
        return new Promise(function(n3, r2) {
          function i2(n4) {
            t2.removeListener(e2, o2), r2(n4);
          }
          function o2() {
            "function" == typeof t2.removeListener && t2.removeListener("error", i2), n3([].slice.call(arguments));
          }
          U(t2, e2, o2, { once: true }), "error" !== e2 && function(t3, e3, n4) {
            "function" == typeof t3.on && U(t3, "error", e3, n4);
          }(t2, i2, { once: true });
        });
      }, m.EventEmitter = m, m.prototype._events = void 0, m.prototype._eventsCount = 0, m.prototype._maxListeners = void 0;
      var k = 10;
      function _(t2) {
        if ("function" != typeof t2)
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t2);
      }
      function G(t2) {
        return void 0 === t2._maxListeners ? m.defaultMaxListeners : t2._maxListeners;
      }
      function x(t2, e2, n3, r2) {
        var i2, o2, a2, c2;
        if (_(n3), void 0 === (o2 = t2._events) ? (o2 = t2._events = /* @__PURE__ */ Object.create(null), t2._eventsCount = 0) : (void 0 !== o2.newListener && (t2.emit("newListener", e2, n3.listener ? n3.listener : n3), o2 = t2._events), a2 = o2[e2]), void 0 === a2)
          a2 = o2[e2] = n3, ++t2._eventsCount;
        else if ("function" == typeof a2 ? a2 = o2[e2] = r2 ? [n3, a2] : [a2, n3] : r2 ? a2.unshift(n3) : a2.push(n3), (i2 = G(t2)) > 0 && a2.length > i2 && !a2.warned) {
          a2.warned = true;
          var u2 = new Error("Possible EventEmitter memory leak detected. " + a2.length + " " + String(e2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          u2.name = "MaxListenersExceededWarning", u2.emitter = t2, u2.type = e2, u2.count = a2.length, c2 = u2, console && console.warn && console.warn(c2);
        }
        return t2;
      }
      function E() {
        if (!this.fired)
          return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
      }
      function A(t2, e2, n3) {
        var r2 = { fired: false, wrapFn: void 0, target: t2, type: e2, listener: n3 }, i2 = E.bind(r2);
        return i2.listener = n3, r2.wrapFn = i2, i2;
      }
      function L(t2, e2, n3) {
        var r2 = t2._events;
        if (void 0 === r2)
          return [];
        var i2 = r2[e2];
        return void 0 === i2 ? [] : "function" == typeof i2 ? n3 ? [i2.listener || i2] : [i2] : n3 ? function(t3) {
          for (var e3 = new Array(t3.length), n4 = 0; n4 < e3.length; ++n4)
            e3[n4] = t3[n4].listener || t3[n4];
          return e3;
        }(i2) : D(i2, i2.length);
      }
      function S(t2) {
        var e2 = this._events;
        if (void 0 !== e2) {
          var n3 = e2[t2];
          if ("function" == typeof n3)
            return 1;
          if (void 0 !== n3)
            return n3.length;
        }
        return 0;
      }
      function D(t2, e2) {
        for (var n3 = new Array(e2), r2 = 0; r2 < e2; ++r2)
          n3[r2] = t2[r2];
        return n3;
      }
      function U(t2, e2, n3, r2) {
        if ("function" == typeof t2.on)
          r2.once ? t2.once(e2, n3) : t2.on(e2, n3);
        else {
          if ("function" != typeof t2.addEventListener)
            throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t2);
          t2.addEventListener(e2, function i2(o2) {
            r2.once && t2.removeEventListener(e2, i2), n3(o2);
          });
        }
      }
      function N(t2) {
        if ("function" != typeof t2)
          throw new Error("obliterator/iterator: expecting a function!");
        this.next = t2;
      }
      Object.defineProperty(m, "defaultMaxListeners", { enumerable: true, get: function() {
        return k;
      }, set: function(t2) {
        if ("number" != typeof t2 || t2 < 0 || b(t2))
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t2 + ".");
        k = t2;
      } }), m.init = function() {
        void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
      }, m.prototype.setMaxListeners = function(t2) {
        if ("number" != typeof t2 || t2 < 0 || b(t2))
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t2 + ".");
        return this._maxListeners = t2, this;
      }, m.prototype.getMaxListeners = function() {
        return G(this);
      }, m.prototype.emit = function(t2) {
        for (var e2 = [], n3 = 1; n3 < arguments.length; n3++)
          e2.push(arguments[n3]);
        var r2 = "error" === t2, i2 = this._events;
        if (void 0 !== i2)
          r2 = r2 && void 0 === i2.error;
        else if (!r2)
          return false;
        if (r2) {
          var o2;
          if (e2.length > 0 && (o2 = e2[0]), o2 instanceof Error)
            throw o2;
          var a2 = new Error("Unhandled error." + (o2 ? " (" + o2.message + ")" : ""));
          throw a2.context = o2, a2;
        }
        var c2 = i2[t2];
        if (void 0 === c2)
          return false;
        if ("function" == typeof c2)
          v(c2, this, e2);
        else {
          var u2 = c2.length, d2 = D(c2, u2);
          for (n3 = 0; n3 < u2; ++n3)
            v(d2[n3], this, e2);
        }
        return true;
      }, m.prototype.addListener = function(t2, e2) {
        return x(this, t2, e2, false);
      }, m.prototype.on = m.prototype.addListener, m.prototype.prependListener = function(t2, e2) {
        return x(this, t2, e2, true);
      }, m.prototype.once = function(t2, e2) {
        return _(e2), this.on(t2, A(this, t2, e2)), this;
      }, m.prototype.prependOnceListener = function(t2, e2) {
        return _(e2), this.prependListener(t2, A(this, t2, e2)), this;
      }, m.prototype.removeListener = function(t2, e2) {
        var n3, r2, i2, o2, a2;
        if (_(e2), void 0 === (r2 = this._events))
          return this;
        if (void 0 === (n3 = r2[t2]))
          return this;
        if (n3 === e2 || n3.listener === e2)
          0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r2[t2], r2.removeListener && this.emit("removeListener", t2, n3.listener || e2));
        else if ("function" != typeof n3) {
          for (i2 = -1, o2 = n3.length - 1; o2 >= 0; o2--)
            if (n3[o2] === e2 || n3[o2].listener === e2) {
              a2 = n3[o2].listener, i2 = o2;
              break;
            }
          if (i2 < 0)
            return this;
          0 === i2 ? n3.shift() : function(t3, e3) {
            for (; e3 + 1 < t3.length; e3++)
              t3[e3] = t3[e3 + 1];
            t3.pop();
          }(n3, i2), 1 === n3.length && (r2[t2] = n3[0]), void 0 !== r2.removeListener && this.emit("removeListener", t2, a2 || e2);
        }
        return this;
      }, m.prototype.off = m.prototype.removeListener, m.prototype.removeAllListeners = function(t2) {
        var e2, n3, r2;
        if (void 0 === (n3 = this._events))
          return this;
        if (void 0 === n3.removeListener)
          return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n3[t2] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n3[t2]), this;
        if (0 === arguments.length) {
          var i2, o2 = Object.keys(n3);
          for (r2 = 0; r2 < o2.length; ++r2)
            "removeListener" !== (i2 = o2[r2]) && this.removeAllListeners(i2);
          return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
        }
        if ("function" == typeof (e2 = n3[t2]))
          this.removeListener(t2, e2);
        else if (void 0 !== e2)
          for (r2 = e2.length - 1; r2 >= 0; r2--)
            this.removeListener(t2, e2[r2]);
        return this;
      }, m.prototype.listeners = function(t2) {
        return L(this, t2, true);
      }, m.prototype.rawListeners = function(t2) {
        return L(this, t2, false);
      }, m.listenerCount = function(t2, e2) {
        return "function" == typeof t2.listenerCount ? t2.listenerCount(e2) : S.call(t2, e2);
      }, m.prototype.listenerCount = S, m.prototype.eventNames = function() {
        return this._eventsCount > 0 ? g(this._events) : [];
      }, "undefined" != typeof Symbol && (N.prototype[Symbol.iterator] = function() {
        return this;
      }), N.of = function() {
        var t2 = arguments, e2 = t2.length, n3 = 0;
        return new N(function() {
          return n3 >= e2 ? { done: true } : { done: false, value: t2[n3++] };
        });
      }, N.empty = function() {
        return new N(function() {
          return { done: true };
        });
      }, N.fromSequence = function(t2) {
        var e2 = 0, n3 = t2.length;
        return new N(function() {
          return e2 >= n3 ? { done: true } : { done: false, value: t2[e2++] };
        });
      }, N.is = function(t2) {
        return t2 instanceof N || "object" == typeof t2 && null !== t2 && "function" == typeof t2.next;
      };
      var O = N, j = {};
      j.ARRAY_BUFFER_SUPPORT = "undefined" != typeof ArrayBuffer, j.SYMBOL_SUPPORT = "undefined" != typeof Symbol;
      var C = O, M = j, z = M.ARRAY_BUFFER_SUPPORT, W = M.SYMBOL_SUPPORT;
      var P = function(t2) {
        var e2 = function(t3) {
          return "string" == typeof t3 || Array.isArray(t3) || z && ArrayBuffer.isView(t3) ? C.fromSequence(t3) : "object" != typeof t3 || null === t3 ? null : W && "function" == typeof t3[Symbol.iterator] ? t3[Symbol.iterator]() : "function" == typeof t3.next ? t3 : null;
        }(t2);
        if (!e2)
          throw new Error("obliterator: target is not iterable nor a valid iterator.");
        return e2;
      }, R = P, K = function(t2, e2) {
        for (var n3, r2 = arguments.length > 1 ? e2 : 1 / 0, i2 = r2 !== 1 / 0 ? new Array(r2) : [], o2 = 0, a2 = R(t2); ; ) {
          if (o2 === r2)
            return i2;
          if ((n3 = a2.next()).done)
            return o2 !== e2 && (i2.length = o2), i2;
          i2[o2++] = n3.value;
        }
      }, T = function(t2) {
        function n3(e2) {
          var n4;
          return (n4 = t2.call(this) || this).name = "GraphError", n4.message = e2, n4;
        }
        return e(n3, t2), n3;
      }(a(Error)), B = function(t2) {
        function n3(e2) {
          var r2;
          return (r2 = t2.call(this, e2) || this).name = "InvalidArgumentsGraphError", "function" == typeof Error.captureStackTrace && Error.captureStackTrace(c(r2), n3.prototype.constructor), r2;
        }
        return e(n3, t2), n3;
      }(T), F = function(t2) {
        function n3(e2) {
          var r2;
          return (r2 = t2.call(this, e2) || this).name = "NotFoundGraphError", "function" == typeof Error.captureStackTrace && Error.captureStackTrace(c(r2), n3.prototype.constructor), r2;
        }
        return e(n3, t2), n3;
      }(T), I = function(t2) {
        function n3(e2) {
          var r2;
          return (r2 = t2.call(this, e2) || this).name = "UsageGraphError", "function" == typeof Error.captureStackTrace && Error.captureStackTrace(c(r2), n3.prototype.constructor), r2;
        }
        return e(n3, t2), n3;
      }(T);
      function Y(t2, e2) {
        this.key = t2, this.attributes = e2, this.clear();
      }
      function q(t2, e2) {
        this.key = t2, this.attributes = e2, this.clear();
      }
      function J(t2, e2) {
        this.key = t2, this.attributes = e2, this.clear();
      }
      function V(t2, e2, n3, r2, i2) {
        this.key = e2, this.attributes = i2, this.undirected = t2, this.source = n3, this.target = r2;
      }
      Y.prototype.clear = function() {
        this.inDegree = 0, this.outDegree = 0, this.undirectedDegree = 0, this.undirectedLoops = 0, this.directedLoops = 0, this.in = {}, this.out = {}, this.undirected = {};
      }, q.prototype.clear = function() {
        this.inDegree = 0, this.outDegree = 0, this.directedLoops = 0, this.in = {}, this.out = {};
      }, J.prototype.clear = function() {
        this.undirectedDegree = 0, this.undirectedLoops = 0, this.undirected = {};
      }, V.prototype.attach = function() {
        var t2 = "out", e2 = "in";
        this.undirected && (t2 = e2 = "undirected");
        var n3 = this.source.key, r2 = this.target.key;
        this.source[t2][r2] = this, this.undirected && n3 === r2 || (this.target[e2][n3] = this);
      }, V.prototype.attachMulti = function() {
        var t2 = "out", e2 = "in", n3 = this.source.key, r2 = this.target.key;
        this.undirected && (t2 = e2 = "undirected");
        var i2 = this.source[t2], o2 = i2[r2];
        if (void 0 === o2)
          return i2[r2] = this, void (this.undirected && n3 === r2 || (this.target[e2][n3] = this));
        o2.previous = this, this.next = o2, i2[r2] = this, this.target[e2][n3] = this;
      }, V.prototype.detach = function() {
        var t2 = this.source.key, e2 = this.target.key, n3 = "out", r2 = "in";
        this.undirected && (n3 = r2 = "undirected"), delete this.source[n3][e2], delete this.target[r2][t2];
      }, V.prototype.detachMulti = function() {
        var t2 = this.source.key, e2 = this.target.key, n3 = "out", r2 = "in";
        this.undirected && (n3 = r2 = "undirected"), void 0 === this.previous ? void 0 === this.next ? (delete this.source[n3][e2], delete this.target[r2][t2]) : (this.next.previous = void 0, this.source[n3][e2] = this.next, this.target[r2][t2] = this.next) : (this.previous.next = this.next, void 0 !== this.next && (this.next.previous = this.previous));
      };
      function H(t2, e2, n3, r2, i2, o2, a2) {
        var c2, u2, d2, s3;
        if (r2 = "" + r2, 0 === n3) {
          if (!(c2 = t2._nodes.get(r2)))
            throw new F("Graph.".concat(e2, ': could not find the "').concat(r2, '" node in the graph.'));
          d2 = i2, s3 = o2;
        } else if (3 === n3) {
          if (i2 = "" + i2, !(u2 = t2._edges.get(i2)))
            throw new F("Graph.".concat(e2, ': could not find the "').concat(i2, '" edge in the graph.'));
          var h2 = u2.source.key, p2 = u2.target.key;
          if (r2 === h2)
            c2 = u2.target;
          else {
            if (r2 !== p2)
              throw new F("Graph.".concat(e2, ': the "').concat(r2, '" node is not attached to the "').concat(i2, '" edge (').concat(h2, ", ").concat(p2, ")."));
            c2 = u2.source;
          }
          d2 = o2, s3 = a2;
        } else {
          if (!(u2 = t2._edges.get(r2)))
            throw new F("Graph.".concat(e2, ': could not find the "').concat(r2, '" edge in the graph.'));
          c2 = 1 === n3 ? u2.source : u2.target, d2 = i2, s3 = o2;
        }
        return [c2, d2, s3];
      }
      var Q = [{ name: function(t2) {
        return "get".concat(t2, "Attribute");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2, i2) {
          var o2 = H(this, e2, n3, t3, r2, i2), a2 = o2[0], c2 = o2[1];
          return a2.attributes[c2];
        };
      } }, { name: function(t2) {
        return "get".concat(t2, "Attributes");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2) {
          return H(this, e2, n3, t3, r2)[0].attributes;
        };
      } }, { name: function(t2) {
        return "has".concat(t2, "Attribute");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2, i2) {
          var o2 = H(this, e2, n3, t3, r2, i2), a2 = o2[0], c2 = o2[1];
          return a2.attributes.hasOwnProperty(c2);
        };
      } }, { name: function(t2) {
        return "set".concat(t2, "Attribute");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2, i2, o2) {
          var a2 = H(this, e2, n3, t3, r2, i2, o2), c2 = a2[0], u2 = a2[1], d2 = a2[2];
          return c2.attributes[u2] = d2, this.emit("nodeAttributesUpdated", { key: c2.key, type: "set", attributes: c2.attributes, name: u2 }), this;
        };
      } }, { name: function(t2) {
        return "update".concat(t2, "Attribute");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2, i2, o2) {
          var a2 = H(this, e2, n3, t3, r2, i2, o2), c2 = a2[0], u2 = a2[1], d2 = a2[2];
          if ("function" != typeof d2)
            throw new B("Graph.".concat(e2, ": updater should be a function."));
          var s3 = c2.attributes, h2 = d2(s3[u2]);
          return s3[u2] = h2, this.emit("nodeAttributesUpdated", { key: c2.key, type: "set", attributes: c2.attributes, name: u2 }), this;
        };
      } }, { name: function(t2) {
        return "remove".concat(t2, "Attribute");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2, i2) {
          var o2 = H(this, e2, n3, t3, r2, i2), a2 = o2[0], c2 = o2[1];
          return delete a2.attributes[c2], this.emit("nodeAttributesUpdated", { key: a2.key, type: "remove", attributes: a2.attributes, name: c2 }), this;
        };
      } }, { name: function(t2) {
        return "replace".concat(t2, "Attributes");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2, i2) {
          var o2 = H(this, e2, n3, t3, r2, i2), a2 = o2[0], c2 = o2[1];
          if (!s2(c2))
            throw new B("Graph.".concat(e2, ": provided attributes are not a plain object."));
          return a2.attributes = c2, this.emit("nodeAttributesUpdated", { key: a2.key, type: "replace", attributes: a2.attributes }), this;
        };
      } }, { name: function(t2) {
        return "merge".concat(t2, "Attributes");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2, i2) {
          var o2 = H(this, e2, n3, t3, r2, i2), a2 = o2[0], c2 = o2[1];
          if (!s2(c2))
            throw new B("Graph.".concat(e2, ": provided attributes are not a plain object."));
          return u(a2.attributes, c2), this.emit("nodeAttributesUpdated", { key: a2.key, type: "merge", attributes: a2.attributes, data: c2 }), this;
        };
      } }, { name: function(t2) {
        return "update".concat(t2, "Attributes");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2, i2) {
          var o2 = H(this, e2, n3, t3, r2, i2), a2 = o2[0], c2 = o2[1];
          if ("function" != typeof c2)
            throw new B("Graph.".concat(e2, ": provided updater is not a function."));
          return a2.attributes = c2(a2.attributes), this.emit("nodeAttributesUpdated", { key: a2.key, type: "update", attributes: a2.attributes }), this;
        };
      } }];
      var X = [{ name: function(t2) {
        return "get".concat(t2, "Attribute");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2) {
          var i2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new I("Graph.".concat(e2, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 2) {
            if (this.multi)
              throw new I("Graph.".concat(e2, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var o2 = "" + t3, a2 = "" + r2;
            if (r2 = arguments[2], !(i2 = d(this, o2, a2, n3)))
              throw new F("Graph.".concat(e2, ': could not find an edge for the given path ("').concat(o2, '" - "').concat(a2, '").'));
          } else {
            if ("mixed" !== n3)
              throw new I("Graph.".concat(e2, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t3 = "" + t3, !(i2 = this._edges.get(t3)))
              throw new F("Graph.".concat(e2, ': could not find the "').concat(t3, '" edge in the graph.'));
          }
          return i2.attributes[r2];
        };
      } }, { name: function(t2) {
        return "get".concat(t2, "Attributes");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3) {
          var r2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new I("Graph.".concat(e2, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 1) {
            if (this.multi)
              throw new I("Graph.".concat(e2, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var i2 = "" + t3, o2 = "" + arguments[1];
            if (!(r2 = d(this, i2, o2, n3)))
              throw new F("Graph.".concat(e2, ': could not find an edge for the given path ("').concat(i2, '" - "').concat(o2, '").'));
          } else {
            if ("mixed" !== n3)
              throw new I("Graph.".concat(e2, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t3 = "" + t3, !(r2 = this._edges.get(t3)))
              throw new F("Graph.".concat(e2, ': could not find the "').concat(t3, '" edge in the graph.'));
          }
          return r2.attributes;
        };
      } }, { name: function(t2) {
        return "has".concat(t2, "Attribute");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2) {
          var i2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new I("Graph.".concat(e2, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 2) {
            if (this.multi)
              throw new I("Graph.".concat(e2, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var o2 = "" + t3, a2 = "" + r2;
            if (r2 = arguments[2], !(i2 = d(this, o2, a2, n3)))
              throw new F("Graph.".concat(e2, ': could not find an edge for the given path ("').concat(o2, '" - "').concat(a2, '").'));
          } else {
            if ("mixed" !== n3)
              throw new I("Graph.".concat(e2, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t3 = "" + t3, !(i2 = this._edges.get(t3)))
              throw new F("Graph.".concat(e2, ': could not find the "').concat(t3, '" edge in the graph.'));
          }
          return i2.attributes.hasOwnProperty(r2);
        };
      } }, { name: function(t2) {
        return "set".concat(t2, "Attribute");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2, i2) {
          var o2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new I("Graph.".concat(e2, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 3) {
            if (this.multi)
              throw new I("Graph.".concat(e2, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var a2 = "" + t3, c2 = "" + r2;
            if (r2 = arguments[2], i2 = arguments[3], !(o2 = d(this, a2, c2, n3)))
              throw new F("Graph.".concat(e2, ': could not find an edge for the given path ("').concat(a2, '" - "').concat(c2, '").'));
          } else {
            if ("mixed" !== n3)
              throw new I("Graph.".concat(e2, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t3 = "" + t3, !(o2 = this._edges.get(t3)))
              throw new F("Graph.".concat(e2, ': could not find the "').concat(t3, '" edge in the graph.'));
          }
          return o2.attributes[r2] = i2, this.emit("edgeAttributesUpdated", { key: o2.key, type: "set", attributes: o2.attributes, name: r2 }), this;
        };
      } }, { name: function(t2) {
        return "update".concat(t2, "Attribute");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2, i2) {
          var o2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new I("Graph.".concat(e2, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 3) {
            if (this.multi)
              throw new I("Graph.".concat(e2, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var a2 = "" + t3, c2 = "" + r2;
            if (r2 = arguments[2], i2 = arguments[3], !(o2 = d(this, a2, c2, n3)))
              throw new F("Graph.".concat(e2, ': could not find an edge for the given path ("').concat(a2, '" - "').concat(c2, '").'));
          } else {
            if ("mixed" !== n3)
              throw new I("Graph.".concat(e2, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t3 = "" + t3, !(o2 = this._edges.get(t3)))
              throw new F("Graph.".concat(e2, ': could not find the "').concat(t3, '" edge in the graph.'));
          }
          if ("function" != typeof i2)
            throw new B("Graph.".concat(e2, ": updater should be a function."));
          return o2.attributes[r2] = i2(o2.attributes[r2]), this.emit("edgeAttributesUpdated", { key: o2.key, type: "set", attributes: o2.attributes, name: r2 }), this;
        };
      } }, { name: function(t2) {
        return "remove".concat(t2, "Attribute");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2) {
          var i2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new I("Graph.".concat(e2, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 2) {
            if (this.multi)
              throw new I("Graph.".concat(e2, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var o2 = "" + t3, a2 = "" + r2;
            if (r2 = arguments[2], !(i2 = d(this, o2, a2, n3)))
              throw new F("Graph.".concat(e2, ': could not find an edge for the given path ("').concat(o2, '" - "').concat(a2, '").'));
          } else {
            if ("mixed" !== n3)
              throw new I("Graph.".concat(e2, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t3 = "" + t3, !(i2 = this._edges.get(t3)))
              throw new F("Graph.".concat(e2, ': could not find the "').concat(t3, '" edge in the graph.'));
          }
          return delete i2.attributes[r2], this.emit("edgeAttributesUpdated", { key: i2.key, type: "remove", attributes: i2.attributes, name: r2 }), this;
        };
      } }, { name: function(t2) {
        return "replace".concat(t2, "Attributes");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2) {
          var i2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new I("Graph.".concat(e2, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 2) {
            if (this.multi)
              throw new I("Graph.".concat(e2, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var o2 = "" + t3, a2 = "" + r2;
            if (r2 = arguments[2], !(i2 = d(this, o2, a2, n3)))
              throw new F("Graph.".concat(e2, ': could not find an edge for the given path ("').concat(o2, '" - "').concat(a2, '").'));
          } else {
            if ("mixed" !== n3)
              throw new I("Graph.".concat(e2, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t3 = "" + t3, !(i2 = this._edges.get(t3)))
              throw new F("Graph.".concat(e2, ': could not find the "').concat(t3, '" edge in the graph.'));
          }
          if (!s2(r2))
            throw new B("Graph.".concat(e2, ": provided attributes are not a plain object."));
          return i2.attributes = r2, this.emit("edgeAttributesUpdated", { key: i2.key, type: "replace", attributes: i2.attributes }), this;
        };
      } }, { name: function(t2) {
        return "merge".concat(t2, "Attributes");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2) {
          var i2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new I("Graph.".concat(e2, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 2) {
            if (this.multi)
              throw new I("Graph.".concat(e2, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var o2 = "" + t3, a2 = "" + r2;
            if (r2 = arguments[2], !(i2 = d(this, o2, a2, n3)))
              throw new F("Graph.".concat(e2, ': could not find an edge for the given path ("').concat(o2, '" - "').concat(a2, '").'));
          } else {
            if ("mixed" !== n3)
              throw new I("Graph.".concat(e2, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t3 = "" + t3, !(i2 = this._edges.get(t3)))
              throw new F("Graph.".concat(e2, ': could not find the "').concat(t3, '" edge in the graph.'));
          }
          if (!s2(r2))
            throw new B("Graph.".concat(e2, ": provided attributes are not a plain object."));
          return u(i2.attributes, r2), this.emit("edgeAttributesUpdated", { key: i2.key, type: "merge", attributes: i2.attributes, data: r2 }), this;
        };
      } }, { name: function(t2) {
        return "update".concat(t2, "Attributes");
      }, attacher: function(t2, e2, n3) {
        t2.prototype[e2] = function(t3, r2) {
          var i2;
          if ("mixed" !== this.type && "mixed" !== n3 && n3 !== this.type)
            throw new I("Graph.".concat(e2, ": cannot find this type of edges in your ").concat(this.type, " graph."));
          if (arguments.length > 2) {
            if (this.multi)
              throw new I("Graph.".concat(e2, ": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));
            var o2 = "" + t3, a2 = "" + r2;
            if (r2 = arguments[2], !(i2 = d(this, o2, a2, n3)))
              throw new F("Graph.".concat(e2, ': could not find an edge for the given path ("').concat(o2, '" - "').concat(a2, '").'));
          } else {
            if ("mixed" !== n3)
              throw new I("Graph.".concat(e2, ": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));
            if (t3 = "" + t3, !(i2 = this._edges.get(t3)))
              throw new F("Graph.".concat(e2, ': could not find the "').concat(t3, '" edge in the graph.'));
          }
          if ("function" != typeof r2)
            throw new B("Graph.".concat(e2, ": provided updater is not a function."));
          return i2.attributes = r2(i2.attributes), this.emit("edgeAttributesUpdated", { key: i2.key, type: "update", attributes: i2.attributes }), this;
        };
      } }];
      var Z = O, $ = P, tt = function() {
        var t2 = arguments, e2 = null, n3 = -1;
        return new Z(function() {
          for (var r2 = null; ; ) {
            if (null === e2) {
              if (++n3 >= t2.length)
                return { done: true };
              e2 = $(t2[n3]);
            }
            if (true !== (r2 = e2.next()).done)
              break;
            e2 = null;
          }
          return r2;
        });
      }, et = [{ name: "edges", type: "mixed" }, { name: "inEdges", type: "directed", direction: "in" }, { name: "outEdges", type: "directed", direction: "out" }, { name: "inboundEdges", type: "mixed", direction: "in" }, { name: "outboundEdges", type: "mixed", direction: "out" }, { name: "directedEdges", type: "directed" }, { name: "undirectedEdges", type: "undirected" }];
      function nt(t2, e2, n3, r2) {
        var i2 = false;
        for (var o2 in e2)
          if (o2 !== r2) {
            var a2 = e2[o2];
            if (i2 = n3(a2.key, a2.attributes, a2.source.key, a2.target.key, a2.source.attributes, a2.target.attributes, a2.undirected), t2 && i2)
              return a2.key;
          }
      }
      function rt(t2, e2, n3, r2) {
        var i2, o2, a2, c2 = false;
        for (var u2 in e2)
          if (u2 !== r2) {
            i2 = e2[u2];
            do {
              if (o2 = i2.source, a2 = i2.target, c2 = n3(i2.key, i2.attributes, o2.key, a2.key, o2.attributes, a2.attributes, i2.undirected), t2 && c2)
                return i2.key;
              i2 = i2.next;
            } while (void 0 !== i2);
          }
      }
      function it(t2, e2) {
        var n3, r2 = Object.keys(t2), i2 = r2.length, o2 = 0;
        return new O(function() {
          do {
            if (n3)
              n3 = n3.next;
            else {
              if (o2 >= i2)
                return { done: true };
              var a2 = r2[o2++];
              if (a2 === e2) {
                n3 = void 0;
                continue;
              }
              n3 = t2[a2];
            }
          } while (!n3);
          return { done: false, value: { edge: n3.key, attributes: n3.attributes, source: n3.source.key, target: n3.target.key, sourceAttributes: n3.source.attributes, targetAttributes: n3.target.attributes, undirected: n3.undirected } };
        });
      }
      function ot(t2, e2, n3, r2) {
        var i2 = e2[n3];
        if (i2) {
          var o2 = i2.source, a2 = i2.target;
          return r2(i2.key, i2.attributes, o2.key, a2.key, o2.attributes, a2.attributes, i2.undirected) && t2 ? i2.key : void 0;
        }
      }
      function at(t2, e2, n3, r2) {
        var i2 = e2[n3];
        if (i2) {
          var o2 = false;
          do {
            if (o2 = r2(i2.key, i2.attributes, i2.source.key, i2.target.key, i2.source.attributes, i2.target.attributes, i2.undirected), t2 && o2)
              return i2.key;
            i2 = i2.next;
          } while (void 0 !== i2);
        }
      }
      function ct(t2, e2) {
        var n3 = t2[e2];
        return void 0 !== n3.next ? new O(function() {
          if (!n3)
            return { done: true };
          var t3 = { edge: n3.key, attributes: n3.attributes, source: n3.source.key, target: n3.target.key, sourceAttributes: n3.source.attributes, targetAttributes: n3.target.attributes, undirected: n3.undirected };
          return n3 = n3.next, { done: false, value: t3 };
        }) : O.of({ edge: n3.key, attributes: n3.attributes, source: n3.source.key, target: n3.target.key, sourceAttributes: n3.source.attributes, targetAttributes: n3.target.attributes, undirected: n3.undirected });
      }
      function ut(t2, e2) {
        if (0 === t2.size)
          return [];
        if ("mixed" === e2 || e2 === t2.type)
          return "function" == typeof Array.from ? Array.from(t2._edges.keys()) : K(t2._edges.keys(), t2._edges.size);
        for (var n3, r2, i2 = "undirected" === e2 ? t2.undirectedSize : t2.directedSize, o2 = new Array(i2), a2 = "undirected" === e2, c2 = t2._edges.values(), u2 = 0; true !== (n3 = c2.next()).done; )
          (r2 = n3.value).undirected === a2 && (o2[u2++] = r2.key);
        return o2;
      }
      function dt(t2, e2, n3, r2) {
        if (0 !== e2.size) {
          for (var i2, o2, a2 = "mixed" !== n3 && n3 !== e2.type, c2 = "undirected" === n3, u2 = false, d2 = e2._edges.values(); true !== (i2 = d2.next()).done; )
            if (o2 = i2.value, !a2 || o2.undirected === c2) {
              var s3 = o2, h2 = s3.key, p2 = s3.attributes, f2 = s3.source, l3 = s3.target;
              if (u2 = r2(h2, p2, f2.key, l3.key, f2.attributes, l3.attributes, o2.undirected), t2 && u2)
                return h2;
            }
        }
      }
      function st(t2, e2) {
        if (0 === t2.size)
          return O.empty();
        var n3 = "mixed" !== e2 && e2 !== t2.type, r2 = "undirected" === e2, i2 = t2._edges.values();
        return new O(function() {
          for (var t3, e3; ; ) {
            if ((t3 = i2.next()).done)
              return t3;
            if (e3 = t3.value, !n3 || e3.undirected === r2)
              break;
          }
          return { value: { edge: e3.key, attributes: e3.attributes, source: e3.source.key, target: e3.target.key, sourceAttributes: e3.source.attributes, targetAttributes: e3.target.attributes, undirected: e3.undirected }, done: false };
        });
      }
      function ht(t2, e2, n3, r2, i2, o2) {
        var a2, c2 = e2 ? rt : nt;
        if ("undirected" !== n3) {
          if ("out" !== r2 && (a2 = c2(t2, i2.in, o2), t2 && a2))
            return a2;
          if ("in" !== r2 && (a2 = c2(t2, i2.out, o2, r2 ? void 0 : i2.key), t2 && a2))
            return a2;
        }
        if ("directed" !== n3 && (a2 = c2(t2, i2.undirected, o2), t2 && a2))
          return a2;
      }
      function pt(t2, e2, n3, r2) {
        var i2 = [];
        return ht(false, t2, e2, n3, r2, function(t3) {
          i2.push(t3);
        }), i2;
      }
      function ft(t2, e2, n3) {
        var r2 = O.empty();
        return "undirected" !== t2 && ("out" !== e2 && void 0 !== n3.in && (r2 = tt(r2, it(n3.in))), "in" !== e2 && void 0 !== n3.out && (r2 = tt(r2, it(n3.out, e2 ? void 0 : n3.key)))), "directed" !== t2 && void 0 !== n3.undirected && (r2 = tt(r2, it(n3.undirected))), r2;
      }
      function lt(t2, e2, n3, r2, i2, o2, a2) {
        var c2, u2 = n3 ? at : ot;
        if ("undirected" !== e2) {
          if (void 0 !== i2.in && "out" !== r2 && (c2 = u2(t2, i2.in, o2, a2), t2 && c2))
            return c2;
          if (void 0 !== i2.out && "in" !== r2 && (r2 || i2.key !== o2) && (c2 = u2(t2, i2.out, o2, a2), t2 && c2))
            return c2;
        }
        if ("directed" !== e2 && void 0 !== i2.undirected && (c2 = u2(t2, i2.undirected, o2, a2), t2 && c2))
          return c2;
      }
      function gt(t2, e2, n3, r2, i2) {
        var o2 = [];
        return lt(false, t2, e2, n3, r2, i2, function(t3) {
          o2.push(t3);
        }), o2;
      }
      function yt(t2, e2, n3, r2) {
        var i2 = O.empty();
        return "undirected" !== t2 && (void 0 !== n3.in && "out" !== e2 && r2 in n3.in && (i2 = tt(i2, ct(n3.in, r2))), void 0 !== n3.out && "in" !== e2 && r2 in n3.out && (e2 || n3.key !== r2) && (i2 = tt(i2, ct(n3.out, r2)))), "directed" !== t2 && void 0 !== n3.undirected && r2 in n3.undirected && (i2 = tt(i2, ct(n3.undirected, r2))), i2;
      }
      var wt = [{ name: "neighbors", type: "mixed" }, { name: "inNeighbors", type: "directed", direction: "in" }, { name: "outNeighbors", type: "directed", direction: "out" }, { name: "inboundNeighbors", type: "mixed", direction: "in" }, { name: "outboundNeighbors", type: "mixed", direction: "out" }, { name: "directedNeighbors", type: "directed" }, { name: "undirectedNeighbors", type: "undirected" }];
      function vt() {
        this.A = null, this.B = null;
      }
      function bt(t2, e2, n3, r2, i2) {
        for (var o2 in r2) {
          var a2 = r2[o2], c2 = a2.source, u2 = a2.target, d2 = c2 === n3 ? u2 : c2;
          if (!e2 || !e2.has(d2.key)) {
            var s3 = i2(d2.key, d2.attributes);
            if (t2 && s3)
              return d2.key;
          }
        }
      }
      function mt(t2, e2, n3, r2, i2) {
        if ("mixed" !== e2) {
          if ("undirected" === e2)
            return bt(t2, null, r2, r2.undirected, i2);
          if ("string" == typeof n3)
            return bt(t2, null, r2, r2[n3], i2);
        }
        var o2, a2 = new vt();
        if ("undirected" !== e2) {
          if ("out" !== n3) {
            if (o2 = bt(t2, null, r2, r2.in, i2), t2 && o2)
              return o2;
            a2.wrap(r2.in);
          }
          if ("in" !== n3) {
            if (o2 = bt(t2, a2, r2, r2.out, i2), t2 && o2)
              return o2;
            a2.wrap(r2.out);
          }
        }
        if ("directed" !== e2 && (o2 = bt(t2, a2, r2, r2.undirected, i2), t2 && o2))
          return o2;
      }
      function kt(t2, e2, n3) {
        var r2 = Object.keys(n3), i2 = r2.length, o2 = 0;
        return new O(function() {
          var a2 = null;
          do {
            if (o2 >= i2)
              return t2 && t2.wrap(n3), { done: true };
            var c2 = n3[r2[o2++]], u2 = c2.source, d2 = c2.target;
            a2 = u2 === e2 ? d2 : u2, t2 && t2.has(a2.key) && (a2 = null);
          } while (null === a2);
          return { done: false, value: { neighbor: a2.key, attributes: a2.attributes } };
        });
      }
      function _t(t2, e2) {
        var n3 = e2.name, r2 = e2.type, i2 = e2.direction;
        t2.prototype[n3] = function(t3) {
          if ("mixed" !== r2 && "mixed" !== this.type && r2 !== this.type)
            return [];
          t3 = "" + t3;
          var e3 = this._nodes.get(t3);
          if (void 0 === e3)
            throw new F("Graph.".concat(n3, ': could not find the "').concat(t3, '" node in the graph.'));
          return function(t4, e4, n4) {
            if ("mixed" !== t4) {
              if ("undirected" === t4)
                return Object.keys(n4.undirected);
              if ("string" == typeof e4)
                return Object.keys(n4[e4]);
            }
            var r3 = [];
            return mt(false, t4, e4, n4, function(t5) {
              r3.push(t5);
            }), r3;
          }("mixed" === r2 ? this.type : r2, i2, e3);
        };
      }
      function Gt(t2, e2) {
        var n3 = e2.name, r2 = e2.type, i2 = e2.direction, o2 = n3.slice(0, -1) + "Entries";
        t2.prototype[o2] = function(t3) {
          if ("mixed" !== r2 && "mixed" !== this.type && r2 !== this.type)
            return O.empty();
          t3 = "" + t3;
          var e3 = this._nodes.get(t3);
          if (void 0 === e3)
            throw new F("Graph.".concat(o2, ': could not find the "').concat(t3, '" node in the graph.'));
          return function(t4, e4, n4) {
            if ("mixed" !== t4) {
              if ("undirected" === t4)
                return kt(null, n4, n4.undirected);
              if ("string" == typeof e4)
                return kt(null, n4, n4[e4]);
            }
            var r3 = O.empty(), i3 = new vt();
            return "undirected" !== t4 && ("out" !== e4 && (r3 = tt(r3, kt(i3, n4, n4.in))), "in" !== e4 && (r3 = tt(r3, kt(i3, n4, n4.out)))), "directed" !== t4 && (r3 = tt(r3, kt(i3, n4, n4.undirected))), r3;
          }("mixed" === r2 ? this.type : r2, i2, e3);
        };
      }
      function xt(t2, e2, n3, r2, i2) {
        for (var o2, a2, c2, u2, d2, s3, h2, p2 = r2._nodes.values(), f2 = r2.type; true !== (o2 = p2.next()).done; ) {
          var l3 = false;
          if (a2 = o2.value, "undirected" !== f2)
            for (c2 in u2 = a2.out) {
              d2 = u2[c2];
              do {
                if (s3 = d2.target, l3 = true, h2 = i2(a2.key, s3.key, a2.attributes, s3.attributes, d2.key, d2.attributes, d2.undirected), t2 && h2)
                  return d2;
                d2 = d2.next;
              } while (d2);
            }
          if ("directed" !== f2) {
            for (c2 in u2 = a2.undirected)
              if (!(e2 && a2.key > c2)) {
                d2 = u2[c2];
                do {
                  if ((s3 = d2.target).key !== c2 && (s3 = d2.source), l3 = true, h2 = i2(a2.key, s3.key, a2.attributes, s3.attributes, d2.key, d2.attributes, d2.undirected), t2 && h2)
                    return d2;
                  d2 = d2.next;
                } while (d2);
              }
          }
          if (n3 && !l3 && (h2 = i2(a2.key, null, a2.attributes, null, null, null, null), t2 && h2))
            return null;
        }
      }
      function Et(t2) {
        if (!s2(t2))
          throw new B('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');
        if (!("key" in t2))
          throw new B("Graph.import: serialized node is missing its key.");
        if ("attributes" in t2 && (!s2(t2.attributes) || null === t2.attributes))
          throw new B("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");
      }
      function At(t2) {
        if (!s2(t2))
          throw new B('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');
        if (!("source" in t2))
          throw new B("Graph.import: serialized edge is missing its source.");
        if (!("target" in t2))
          throw new B("Graph.import: serialized edge is missing its target.");
        if ("attributes" in t2 && (!s2(t2.attributes) || null === t2.attributes))
          throw new B("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");
        if ("undirected" in t2 && "boolean" != typeof t2.undirected)
          throw new B("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.");
      }
      vt.prototype.wrap = function(t2) {
        null === this.A ? this.A = t2 : null === this.B && (this.B = t2);
      }, vt.prototype.has = function(t2) {
        return null !== this.A && t2 in this.A || null !== this.B && t2 in this.B;
      };
      var Lt, St = (Lt = 255 & Math.floor(256 * Math.random()), function() {
        return Lt++;
      }), Dt = /* @__PURE__ */ new Set(["directed", "undirected", "mixed"]), Ut = /* @__PURE__ */ new Set(["domain", "_events", "_eventsCount", "_maxListeners"]), Nt = { allowSelfLoops: true, multi: false, type: "mixed" };
      function Ot(t2, e2, n3) {
        var r2 = new t2.NodeDataClass(e2, n3);
        return t2._nodes.set(e2, r2), t2.emit("nodeAdded", { key: e2, attributes: n3 }), r2;
      }
      function jt(t2, e2, n3, r2, i2, o2, a2, c2) {
        if (!r2 && "undirected" === t2.type)
          throw new I("Graph.".concat(e2, ": you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead."));
        if (r2 && "directed" === t2.type)
          throw new I("Graph.".concat(e2, ": you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead."));
        if (c2 && !s2(c2))
          throw new B("Graph.".concat(e2, ': invalid attributes. Expecting an object but got "').concat(c2, '"'));
        if (o2 = "" + o2, a2 = "" + a2, c2 = c2 || {}, !t2.allowSelfLoops && o2 === a2)
          throw new I("Graph.".concat(e2, ': source & target are the same ("').concat(o2, `"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`));
        var u2 = t2._nodes.get(o2), d2 = t2._nodes.get(a2);
        if (!u2)
          throw new F("Graph.".concat(e2, ': source node "').concat(o2, '" not found.'));
        if (!d2)
          throw new F("Graph.".concat(e2, ': target node "').concat(a2, '" not found.'));
        var h2 = { key: null, undirected: r2, source: o2, target: a2, attributes: c2 };
        if (n3)
          i2 = t2._edgeKeyGenerator();
        else if (i2 = "" + i2, t2._edges.has(i2))
          throw new I("Graph.".concat(e2, ': the "').concat(i2, '" edge already exists in the graph.'));
        if (!t2.multi && (r2 ? void 0 !== u2.undirected[a2] : void 0 !== u2.out[a2]))
          throw new I("Graph.".concat(e2, ': an edge linking "').concat(o2, '" to "').concat(a2, `" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`));
        var p2 = new V(r2, i2, u2, d2, c2);
        t2._edges.set(i2, p2);
        var f2 = o2 === a2;
        return r2 ? (u2.undirectedDegree++, d2.undirectedDegree++, f2 && (u2.undirectedLoops++, t2._undirectedSelfLoopCount++)) : (u2.outDegree++, d2.inDegree++, f2 && (u2.directedLoops++, t2._directedSelfLoopCount++)), t2.multi ? p2.attachMulti() : p2.attach(), r2 ? t2._undirectedSize++ : t2._directedSize++, h2.key = i2, t2.emit("edgeAdded", h2), i2;
      }
      function Ct(t2, e2, n3, r2, i2, o2, a2, c2, d2) {
        if (!r2 && "undirected" === t2.type)
          throw new I("Graph.".concat(e2, ": you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead."));
        if (r2 && "directed" === t2.type)
          throw new I("Graph.".concat(e2, ": you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead."));
        if (c2) {
          if (d2) {
            if ("function" != typeof c2)
              throw new B("Graph.".concat(e2, ': invalid updater function. Expecting a function but got "').concat(c2, '"'));
          } else if (!s2(c2))
            throw new B("Graph.".concat(e2, ': invalid attributes. Expecting an object but got "').concat(c2, '"'));
        }
        var h2;
        if (o2 = "" + o2, a2 = "" + a2, d2 && (h2 = c2, c2 = void 0), !t2.allowSelfLoops && o2 === a2)
          throw new I("Graph.".concat(e2, ': source & target are the same ("').concat(o2, `"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`));
        var p2, f2, l3 = t2._nodes.get(o2), g2 = t2._nodes.get(a2);
        if (!n3 && (p2 = t2._edges.get(i2))) {
          if (!(p2.source.key === o2 && p2.target.key === a2 || r2 && p2.source.key === a2 && p2.target.key === o2))
            throw new I("Graph.".concat(e2, ': inconsistency detected when attempting to merge the "').concat(i2, '" edge with "').concat(o2, '" source & "').concat(a2, '" target vs. ("').concat(p2.source.key, '", "').concat(p2.target.key, '").'));
          f2 = p2;
        }
        if (f2 || t2.multi || !l3 || (f2 = r2 ? l3.undirected[a2] : l3.out[a2]), f2) {
          var y2 = [f2.key, false, false, false];
          if (d2 ? !h2 : !c2)
            return y2;
          if (d2) {
            var w2 = f2.attributes;
            f2.attributes = h2(w2), t2.emit("edgeAttributesUpdated", { type: "replace", key: f2.key, attributes: f2.attributes });
          } else
            u(f2.attributes, c2), t2.emit("edgeAttributesUpdated", { type: "merge", key: f2.key, attributes: f2.attributes, data: c2 });
          return y2;
        }
        c2 = c2 || {}, d2 && h2 && (c2 = h2(c2));
        var v2 = { key: null, undirected: r2, source: o2, target: a2, attributes: c2 };
        if (n3)
          i2 = t2._edgeKeyGenerator();
        else if (i2 = "" + i2, t2._edges.has(i2))
          throw new I("Graph.".concat(e2, ': the "').concat(i2, '" edge already exists in the graph.'));
        var b2 = false, m2 = false;
        l3 || (l3 = Ot(t2, o2, {}), b2 = true, o2 === a2 && (g2 = l3, m2 = true)), g2 || (g2 = Ot(t2, a2, {}), m2 = true), p2 = new V(r2, i2, l3, g2, c2), t2._edges.set(i2, p2);
        var k2 = o2 === a2;
        return r2 ? (l3.undirectedDegree++, g2.undirectedDegree++, k2 && (l3.undirectedLoops++, t2._undirectedSelfLoopCount++)) : (l3.outDegree++, g2.inDegree++, k2 && (l3.directedLoops++, t2._directedSelfLoopCount++)), t2.multi ? p2.attachMulti() : p2.attach(), r2 ? t2._undirectedSize++ : t2._directedSize++, v2.key = i2, t2.emit("edgeAdded", v2), [i2, true, b2, m2];
      }
      function Mt(t2, e2) {
        t2._edges.delete(e2.key);
        var n3 = e2.source, r2 = e2.target, i2 = e2.attributes, o2 = e2.undirected, a2 = n3 === r2;
        o2 ? (n3.undirectedDegree--, r2.undirectedDegree--, a2 && (n3.undirectedLoops--, t2._undirectedSelfLoopCount--)) : (n3.outDegree--, r2.inDegree--, a2 && (n3.directedLoops--, t2._directedSelfLoopCount--)), t2.multi ? e2.detachMulti() : e2.detach(), o2 ? t2._undirectedSize-- : t2._directedSize--, t2.emit("edgeDropped", { key: e2.key, attributes: i2, source: n3.key, target: r2.key, undirected: o2 });
      }
      var zt = function(n3) {
        function r2(t2) {
          var e2;
          if (e2 = n3.call(this) || this, "boolean" != typeof (t2 = u({}, Nt, t2)).multi)
            throw new B(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "`.concat(t2.multi, '".'));
          if (!Dt.has(t2.type))
            throw new B(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "`.concat(t2.type, '".'));
          if ("boolean" != typeof t2.allowSelfLoops)
            throw new B(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "`.concat(t2.allowSelfLoops, '".'));
          var r3 = "mixed" === t2.type ? Y : "directed" === t2.type ? q : J;
          p(c(e2), "NodeDataClass", r3);
          var i3 = "geid_" + St() + "_", o2 = 0;
          return p(c(e2), "_attributes", {}), p(c(e2), "_nodes", /* @__PURE__ */ new Map()), p(c(e2), "_edges", /* @__PURE__ */ new Map()), p(c(e2), "_directedSize", 0), p(c(e2), "_undirectedSize", 0), p(c(e2), "_directedSelfLoopCount", 0), p(c(e2), "_undirectedSelfLoopCount", 0), p(c(e2), "_edgeKeyGenerator", function() {
            var t3;
            do {
              t3 = i3 + o2++;
            } while (e2._edges.has(t3));
            return t3;
          }), p(c(e2), "_options", t2), Ut.forEach(function(t3) {
            return p(c(e2), t3, e2[t3]);
          }), f(c(e2), "order", function() {
            return e2._nodes.size;
          }), f(c(e2), "size", function() {
            return e2._edges.size;
          }), f(c(e2), "directedSize", function() {
            return e2._directedSize;
          }), f(c(e2), "undirectedSize", function() {
            return e2._undirectedSize;
          }), f(c(e2), "selfLoopCount", function() {
            return e2._directedSelfLoopCount + e2._undirectedSelfLoopCount;
          }), f(c(e2), "directedSelfLoopCount", function() {
            return e2._directedSelfLoopCount;
          }), f(c(e2), "undirectedSelfLoopCount", function() {
            return e2._undirectedSelfLoopCount;
          }), f(c(e2), "multi", e2._options.multi), f(c(e2), "type", e2._options.type), f(c(e2), "allowSelfLoops", e2._options.allowSelfLoops), f(c(e2), "implementation", function() {
            return "graphology";
          }), e2;
        }
        e(r2, n3);
        var i2 = r2.prototype;
        return i2._resetInstanceCounters = function() {
          this._directedSize = 0, this._undirectedSize = 0, this._directedSelfLoopCount = 0, this._undirectedSelfLoopCount = 0;
        }, i2.hasNode = function(t2) {
          return this._nodes.has("" + t2);
        }, i2.hasDirectedEdge = function(t2, e2) {
          if ("undirected" === this.type)
            return false;
          if (1 === arguments.length) {
            var n4 = "" + t2, r3 = this._edges.get(n4);
            return !!r3 && !r3.undirected;
          }
          if (2 === arguments.length) {
            t2 = "" + t2, e2 = "" + e2;
            var i3 = this._nodes.get(t2);
            return !!i3 && i3.out.hasOwnProperty(e2);
          }
          throw new B("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length, ", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."));
        }, i2.hasUndirectedEdge = function(t2, e2) {
          if ("directed" === this.type)
            return false;
          if (1 === arguments.length) {
            var n4 = "" + t2, r3 = this._edges.get(n4);
            return !!r3 && r3.undirected;
          }
          if (2 === arguments.length) {
            t2 = "" + t2, e2 = "" + e2;
            var i3 = this._nodes.get(t2);
            return !!i3 && i3.undirected.hasOwnProperty(e2);
          }
          throw new B("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length, ", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."));
        }, i2.hasEdge = function(t2, e2) {
          if (1 === arguments.length) {
            var n4 = "" + t2;
            return this._edges.has(n4);
          }
          if (2 === arguments.length) {
            t2 = "" + t2, e2 = "" + e2;
            var r3 = this._nodes.get(t2);
            return !!r3 && (void 0 !== r3.out && r3.out.hasOwnProperty(e2) || void 0 !== r3.undirected && r3.undirected.hasOwnProperty(e2));
          }
          throw new B("Graph.hasEdge: invalid arity (".concat(arguments.length, ", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."));
        }, i2.directedEdge = function(t2, e2) {
          if ("undirected" !== this.type) {
            if (t2 = "" + t2, e2 = "" + e2, this.multi)
              throw new I("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");
            var n4 = this._nodes.get(t2);
            if (!n4)
              throw new F('Graph.directedEdge: could not find the "'.concat(t2, '" source node in the graph.'));
            if (!this._nodes.has(e2))
              throw new F('Graph.directedEdge: could not find the "'.concat(e2, '" target node in the graph.'));
            var r3 = n4.out && n4.out[e2] || void 0;
            return r3 ? r3.key : void 0;
          }
        }, i2.undirectedEdge = function(t2, e2) {
          if ("directed" !== this.type) {
            if (t2 = "" + t2, e2 = "" + e2, this.multi)
              throw new I("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");
            var n4 = this._nodes.get(t2);
            if (!n4)
              throw new F('Graph.undirectedEdge: could not find the "'.concat(t2, '" source node in the graph.'));
            if (!this._nodes.has(e2))
              throw new F('Graph.undirectedEdge: could not find the "'.concat(e2, '" target node in the graph.'));
            var r3 = n4.undirected && n4.undirected[e2] || void 0;
            return r3 ? r3.key : void 0;
          }
        }, i2.edge = function(t2, e2) {
          if (this.multi)
            throw new I("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");
          t2 = "" + t2, e2 = "" + e2;
          var n4 = this._nodes.get(t2);
          if (!n4)
            throw new F('Graph.edge: could not find the "'.concat(t2, '" source node in the graph.'));
          if (!this._nodes.has(e2))
            throw new F('Graph.edge: could not find the "'.concat(e2, '" target node in the graph.'));
          var r3 = n4.out && n4.out[e2] || n4.undirected && n4.undirected[e2] || void 0;
          if (r3)
            return r3.key;
        }, i2.areDirectedNeighbors = function(t2, e2) {
          t2 = "" + t2, e2 = "" + e2;
          var n4 = this._nodes.get(t2);
          if (!n4)
            throw new F('Graph.areDirectedNeighbors: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" !== this.type && (e2 in n4.in || e2 in n4.out);
        }, i2.areOutNeighbors = function(t2, e2) {
          t2 = "" + t2, e2 = "" + e2;
          var n4 = this._nodes.get(t2);
          if (!n4)
            throw new F('Graph.areOutNeighbors: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" !== this.type && e2 in n4.out;
        }, i2.areInNeighbors = function(t2, e2) {
          t2 = "" + t2, e2 = "" + e2;
          var n4 = this._nodes.get(t2);
          if (!n4)
            throw new F('Graph.areInNeighbors: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" !== this.type && e2 in n4.in;
        }, i2.areUndirectedNeighbors = function(t2, e2) {
          t2 = "" + t2, e2 = "" + e2;
          var n4 = this._nodes.get(t2);
          if (!n4)
            throw new F('Graph.areUndirectedNeighbors: could not find the "'.concat(t2, '" node in the graph.'));
          return "directed" !== this.type && e2 in n4.undirected;
        }, i2.areNeighbors = function(t2, e2) {
          t2 = "" + t2, e2 = "" + e2;
          var n4 = this._nodes.get(t2);
          if (!n4)
            throw new F('Graph.areNeighbors: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" !== this.type && (e2 in n4.in || e2 in n4.out) || "directed" !== this.type && e2 in n4.undirected;
        }, i2.areInboundNeighbors = function(t2, e2) {
          t2 = "" + t2, e2 = "" + e2;
          var n4 = this._nodes.get(t2);
          if (!n4)
            throw new F('Graph.areInboundNeighbors: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" !== this.type && e2 in n4.in || "directed" !== this.type && e2 in n4.undirected;
        }, i2.areOutboundNeighbors = function(t2, e2) {
          t2 = "" + t2, e2 = "" + e2;
          var n4 = this._nodes.get(t2);
          if (!n4)
            throw new F('Graph.areOutboundNeighbors: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" !== this.type && e2 in n4.out || "directed" !== this.type && e2 in n4.undirected;
        }, i2.inDegree = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.inDegree: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" === this.type ? 0 : e2.inDegree;
        }, i2.outDegree = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.outDegree: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" === this.type ? 0 : e2.outDegree;
        }, i2.directedDegree = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.directedDegree: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" === this.type ? 0 : e2.inDegree + e2.outDegree;
        }, i2.undirectedDegree = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.undirectedDegree: could not find the "'.concat(t2, '" node in the graph.'));
          return "directed" === this.type ? 0 : e2.undirectedDegree;
        }, i2.inboundDegree = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.inboundDegree: could not find the "'.concat(t2, '" node in the graph.'));
          var n4 = 0;
          return "directed" !== this.type && (n4 += e2.undirectedDegree), "undirected" !== this.type && (n4 += e2.inDegree), n4;
        }, i2.outboundDegree = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.outboundDegree: could not find the "'.concat(t2, '" node in the graph.'));
          var n4 = 0;
          return "directed" !== this.type && (n4 += e2.undirectedDegree), "undirected" !== this.type && (n4 += e2.outDegree), n4;
        }, i2.degree = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.degree: could not find the "'.concat(t2, '" node in the graph.'));
          var n4 = 0;
          return "directed" !== this.type && (n4 += e2.undirectedDegree), "undirected" !== this.type && (n4 += e2.inDegree + e2.outDegree), n4;
        }, i2.inDegreeWithoutSelfLoops = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.inDegreeWithoutSelfLoops: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" === this.type ? 0 : e2.inDegree - e2.directedLoops;
        }, i2.outDegreeWithoutSelfLoops = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.outDegreeWithoutSelfLoops: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" === this.type ? 0 : e2.outDegree - e2.directedLoops;
        }, i2.directedDegreeWithoutSelfLoops = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.directedDegreeWithoutSelfLoops: could not find the "'.concat(t2, '" node in the graph.'));
          return "undirected" === this.type ? 0 : e2.inDegree + e2.outDegree - 2 * e2.directedLoops;
        }, i2.undirectedDegreeWithoutSelfLoops = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.undirectedDegreeWithoutSelfLoops: could not find the "'.concat(t2, '" node in the graph.'));
          return "directed" === this.type ? 0 : e2.undirectedDegree - 2 * e2.undirectedLoops;
        }, i2.inboundDegreeWithoutSelfLoops = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.inboundDegreeWithoutSelfLoops: could not find the "'.concat(t2, '" node in the graph.'));
          var n4 = 0, r3 = 0;
          return "directed" !== this.type && (n4 += e2.undirectedDegree, r3 += 2 * e2.undirectedLoops), "undirected" !== this.type && (n4 += e2.inDegree, r3 += e2.directedLoops), n4 - r3;
        }, i2.outboundDegreeWithoutSelfLoops = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.outboundDegreeWithoutSelfLoops: could not find the "'.concat(t2, '" node in the graph.'));
          var n4 = 0, r3 = 0;
          return "directed" !== this.type && (n4 += e2.undirectedDegree, r3 += 2 * e2.undirectedLoops), "undirected" !== this.type && (n4 += e2.outDegree, r3 += e2.directedLoops), n4 - r3;
        }, i2.degreeWithoutSelfLoops = function(t2) {
          t2 = "" + t2;
          var e2 = this._nodes.get(t2);
          if (!e2)
            throw new F('Graph.degreeWithoutSelfLoops: could not find the "'.concat(t2, '" node in the graph.'));
          var n4 = 0, r3 = 0;
          return "directed" !== this.type && (n4 += e2.undirectedDegree, r3 += 2 * e2.undirectedLoops), "undirected" !== this.type && (n4 += e2.inDegree + e2.outDegree, r3 += 2 * e2.directedLoops), n4 - r3;
        }, i2.source = function(t2) {
          t2 = "" + t2;
          var e2 = this._edges.get(t2);
          if (!e2)
            throw new F('Graph.source: could not find the "'.concat(t2, '" edge in the graph.'));
          return e2.source.key;
        }, i2.target = function(t2) {
          t2 = "" + t2;
          var e2 = this._edges.get(t2);
          if (!e2)
            throw new F('Graph.target: could not find the "'.concat(t2, '" edge in the graph.'));
          return e2.target.key;
        }, i2.extremities = function(t2) {
          t2 = "" + t2;
          var e2 = this._edges.get(t2);
          if (!e2)
            throw new F('Graph.extremities: could not find the "'.concat(t2, '" edge in the graph.'));
          return [e2.source.key, e2.target.key];
        }, i2.opposite = function(t2, e2) {
          t2 = "" + t2, e2 = "" + e2;
          var n4 = this._edges.get(e2);
          if (!n4)
            throw new F('Graph.opposite: could not find the "'.concat(e2, '" edge in the graph.'));
          var r3 = n4.source.key, i3 = n4.target.key;
          if (t2 === r3)
            return i3;
          if (t2 === i3)
            return r3;
          throw new F('Graph.opposite: the "'.concat(t2, '" node is not attached to the "').concat(e2, '" edge (').concat(r3, ", ").concat(i3, ")."));
        }, i2.hasExtremity = function(t2, e2) {
          t2 = "" + t2, e2 = "" + e2;
          var n4 = this._edges.get(t2);
          if (!n4)
            throw new F('Graph.hasExtremity: could not find the "'.concat(t2, '" edge in the graph.'));
          return n4.source.key === e2 || n4.target.key === e2;
        }, i2.isUndirected = function(t2) {
          t2 = "" + t2;
          var e2 = this._edges.get(t2);
          if (!e2)
            throw new F('Graph.isUndirected: could not find the "'.concat(t2, '" edge in the graph.'));
          return e2.undirected;
        }, i2.isDirected = function(t2) {
          t2 = "" + t2;
          var e2 = this._edges.get(t2);
          if (!e2)
            throw new F('Graph.isDirected: could not find the "'.concat(t2, '" edge in the graph.'));
          return !e2.undirected;
        }, i2.isSelfLoop = function(t2) {
          t2 = "" + t2;
          var e2 = this._edges.get(t2);
          if (!e2)
            throw new F('Graph.isSelfLoop: could not find the "'.concat(t2, '" edge in the graph.'));
          return e2.source === e2.target;
        }, i2.addNode = function(t2, e2) {
          var n4 = function(t3, e3, n5) {
            if (n5 && !s2(n5))
              throw new B('Graph.addNode: invalid attributes. Expecting an object but got "'.concat(n5, '"'));
            if (e3 = "" + e3, n5 = n5 || {}, t3._nodes.has(e3))
              throw new I('Graph.addNode: the "'.concat(e3, '" node already exist in the graph.'));
            var r3 = new t3.NodeDataClass(e3, n5);
            return t3._nodes.set(e3, r3), t3.emit("nodeAdded", { key: e3, attributes: n5 }), r3;
          }(this, t2, e2);
          return n4.key;
        }, i2.mergeNode = function(t2, e2) {
          if (e2 && !s2(e2))
            throw new B('Graph.mergeNode: invalid attributes. Expecting an object but got "'.concat(e2, '"'));
          t2 = "" + t2, e2 = e2 || {};
          var n4 = this._nodes.get(t2);
          return n4 ? (e2 && (u(n4.attributes, e2), this.emit("nodeAttributesUpdated", { type: "merge", key: t2, attributes: n4.attributes, data: e2 })), [t2, false]) : (n4 = new this.NodeDataClass(t2, e2), this._nodes.set(t2, n4), this.emit("nodeAdded", { key: t2, attributes: e2 }), [t2, true]);
        }, i2.updateNode = function(t2, e2) {
          if (e2 && "function" != typeof e2)
            throw new B('Graph.updateNode: invalid updater function. Expecting a function but got "'.concat(e2, '"'));
          t2 = "" + t2;
          var n4 = this._nodes.get(t2);
          if (n4) {
            if (e2) {
              var r3 = n4.attributes;
              n4.attributes = e2(r3), this.emit("nodeAttributesUpdated", { type: "replace", key: t2, attributes: n4.attributes });
            }
            return [t2, false];
          }
          var i3 = e2 ? e2({}) : {};
          return n4 = new this.NodeDataClass(t2, i3), this._nodes.set(t2, n4), this.emit("nodeAdded", { key: t2, attributes: i3 }), [t2, true];
        }, i2.dropNode = function(t2) {
          t2 = "" + t2;
          var e2, n4 = this._nodes.get(t2);
          if (!n4)
            throw new F('Graph.dropNode: could not find the "'.concat(t2, '" node in the graph.'));
          if ("undirected" !== this.type) {
            for (var r3 in n4.out) {
              e2 = n4.out[r3];
              do {
                Mt(this, e2), e2 = e2.next;
              } while (e2);
            }
            for (var i3 in n4.in) {
              e2 = n4.in[i3];
              do {
                Mt(this, e2), e2 = e2.next;
              } while (e2);
            }
          }
          if ("directed" !== this.type)
            for (var o2 in n4.undirected) {
              e2 = n4.undirected[o2];
              do {
                Mt(this, e2), e2 = e2.next;
              } while (e2);
            }
          this._nodes.delete(t2), this.emit("nodeDropped", { key: t2, attributes: n4.attributes });
        }, i2.dropEdge = function(t2) {
          var e2;
          if (arguments.length > 1) {
            var n4 = "" + arguments[0], r3 = "" + arguments[1];
            if (!(e2 = d(this, n4, r3, this.type)))
              throw new F('Graph.dropEdge: could not find the "'.concat(n4, '" -> "').concat(r3, '" edge in the graph.'));
          } else if (t2 = "" + t2, !(e2 = this._edges.get(t2)))
            throw new F('Graph.dropEdge: could not find the "'.concat(t2, '" edge in the graph.'));
          return Mt(this, e2), this;
        }, i2.dropDirectedEdge = function(t2, e2) {
          if (arguments.length < 2)
            throw new I("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");
          if (this.multi)
            throw new I("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");
          var n4 = d(this, t2 = "" + t2, e2 = "" + e2, "directed");
          if (!n4)
            throw new F('Graph.dropDirectedEdge: could not find a "'.concat(t2, '" -> "').concat(e2, '" edge in the graph.'));
          return Mt(this, n4), this;
        }, i2.dropUndirectedEdge = function(t2, e2) {
          if (arguments.length < 2)
            throw new I("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");
          if (this.multi)
            throw new I("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");
          var n4 = d(this, t2, e2, "undirected");
          if (!n4)
            throw new F('Graph.dropUndirectedEdge: could not find a "'.concat(t2, '" -> "').concat(e2, '" edge in the graph.'));
          return Mt(this, n4), this;
        }, i2.clear = function() {
          this._edges.clear(), this._nodes.clear(), this._resetInstanceCounters(), this.emit("cleared");
        }, i2.clearEdges = function() {
          for (var t2, e2 = this._nodes.values(); true !== (t2 = e2.next()).done; )
            t2.value.clear();
          this._edges.clear(), this._resetInstanceCounters(), this.emit("edgesCleared");
        }, i2.getAttribute = function(t2) {
          return this._attributes[t2];
        }, i2.getAttributes = function() {
          return this._attributes;
        }, i2.hasAttribute = function(t2) {
          return this._attributes.hasOwnProperty(t2);
        }, i2.setAttribute = function(t2, e2) {
          return this._attributes[t2] = e2, this.emit("attributesUpdated", { type: "set", attributes: this._attributes, name: t2 }), this;
        }, i2.updateAttribute = function(t2, e2) {
          if ("function" != typeof e2)
            throw new B("Graph.updateAttribute: updater should be a function.");
          var n4 = this._attributes[t2];
          return this._attributes[t2] = e2(n4), this.emit("attributesUpdated", { type: "set", attributes: this._attributes, name: t2 }), this;
        }, i2.removeAttribute = function(t2) {
          return delete this._attributes[t2], this.emit("attributesUpdated", { type: "remove", attributes: this._attributes, name: t2 }), this;
        }, i2.replaceAttributes = function(t2) {
          if (!s2(t2))
            throw new B("Graph.replaceAttributes: provided attributes are not a plain object.");
          return this._attributes = t2, this.emit("attributesUpdated", { type: "replace", attributes: this._attributes }), this;
        }, i2.mergeAttributes = function(t2) {
          if (!s2(t2))
            throw new B("Graph.mergeAttributes: provided attributes are not a plain object.");
          return u(this._attributes, t2), this.emit("attributesUpdated", { type: "merge", attributes: this._attributes, data: t2 }), this;
        }, i2.updateAttributes = function(t2) {
          if ("function" != typeof t2)
            throw new B("Graph.updateAttributes: provided updater is not a function.");
          return this._attributes = t2(this._attributes), this.emit("attributesUpdated", { type: "update", attributes: this._attributes }), this;
        }, i2.updateEachNodeAttributes = function(t2, e2) {
          if ("function" != typeof t2)
            throw new B("Graph.updateEachNodeAttributes: expecting an updater function.");
          if (e2 && !l2(e2))
            throw new B("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");
          for (var n4, r3, i3 = this._nodes.values(); true !== (n4 = i3.next()).done; )
            (r3 = n4.value).attributes = t2(r3.key, r3.attributes);
          this.emit("eachNodeAttributesUpdated", { hints: e2 || null });
        }, i2.updateEachEdgeAttributes = function(t2, e2) {
          if ("function" != typeof t2)
            throw new B("Graph.updateEachEdgeAttributes: expecting an updater function.");
          if (e2 && !l2(e2))
            throw new B("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");
          for (var n4, r3, i3, o2, a2 = this._edges.values(); true !== (n4 = a2.next()).done; )
            i3 = (r3 = n4.value).source, o2 = r3.target, r3.attributes = t2(r3.key, r3.attributes, i3.key, o2.key, i3.attributes, o2.attributes, r3.undirected);
          this.emit("eachEdgeAttributesUpdated", { hints: e2 || null });
        }, i2.forEachAdjacencyEntry = function(t2) {
          if ("function" != typeof t2)
            throw new B("Graph.forEachAdjacencyEntry: expecting a callback.");
          xt(false, false, false, this, t2);
        }, i2.forEachAdjacencyEntryWithOrphans = function(t2) {
          if ("function" != typeof t2)
            throw new B("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");
          xt(false, false, true, this, t2);
        }, i2.forEachAssymetricAdjacencyEntry = function(t2) {
          if ("function" != typeof t2)
            throw new B("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");
          xt(false, true, false, this, t2);
        }, i2.forEachAssymetricAdjacencyEntryWithOrphans = function(t2) {
          if ("function" != typeof t2)
            throw new B("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");
          xt(false, true, true, this, t2);
        }, i2.nodes = function() {
          return "function" == typeof Array.from ? Array.from(this._nodes.keys()) : K(this._nodes.keys(), this._nodes.size);
        }, i2.forEachNode = function(t2) {
          if ("function" != typeof t2)
            throw new B("Graph.forEachNode: expecting a callback.");
          for (var e2, n4, r3 = this._nodes.values(); true !== (e2 = r3.next()).done; )
            t2((n4 = e2.value).key, n4.attributes);
        }, i2.findNode = function(t2) {
          if ("function" != typeof t2)
            throw new B("Graph.findNode: expecting a callback.");
          for (var e2, n4, r3 = this._nodes.values(); true !== (e2 = r3.next()).done; )
            if (t2((n4 = e2.value).key, n4.attributes))
              return n4.key;
        }, i2.mapNodes = function(t2) {
          if ("function" != typeof t2)
            throw new B("Graph.mapNode: expecting a callback.");
          for (var e2, n4, r3 = this._nodes.values(), i3 = new Array(this.order), o2 = 0; true !== (e2 = r3.next()).done; )
            n4 = e2.value, i3[o2++] = t2(n4.key, n4.attributes);
          return i3;
        }, i2.someNode = function(t2) {
          if ("function" != typeof t2)
            throw new B("Graph.someNode: expecting a callback.");
          for (var e2, n4, r3 = this._nodes.values(); true !== (e2 = r3.next()).done; )
            if (t2((n4 = e2.value).key, n4.attributes))
              return true;
          return false;
        }, i2.everyNode = function(t2) {
          if ("function" != typeof t2)
            throw new B("Graph.everyNode: expecting a callback.");
          for (var e2, n4, r3 = this._nodes.values(); true !== (e2 = r3.next()).done; )
            if (!t2((n4 = e2.value).key, n4.attributes))
              return false;
          return true;
        }, i2.filterNodes = function(t2) {
          if ("function" != typeof t2)
            throw new B("Graph.filterNodes: expecting a callback.");
          for (var e2, n4, r3 = this._nodes.values(), i3 = []; true !== (e2 = r3.next()).done; )
            t2((n4 = e2.value).key, n4.attributes) && i3.push(n4.key);
          return i3;
        }, i2.reduceNodes = function(t2, e2) {
          if ("function" != typeof t2)
            throw new B("Graph.reduceNodes: expecting a callback.");
          if (arguments.length < 2)
            throw new B("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");
          for (var n4, r3, i3 = e2, o2 = this._nodes.values(); true !== (n4 = o2.next()).done; )
            i3 = t2(i3, (r3 = n4.value).key, r3.attributes);
          return i3;
        }, i2.nodeEntries = function() {
          var t2 = this._nodes.values();
          return new O(function() {
            var e2 = t2.next();
            if (e2.done)
              return e2;
            var n4 = e2.value;
            return { value: { node: n4.key, attributes: n4.attributes }, done: false };
          });
        }, i2.export = function() {
          var t2 = this, e2 = new Array(this._nodes.size), n4 = 0;
          this._nodes.forEach(function(t3, r4) {
            e2[n4++] = function(t4, e3) {
              var n5 = { key: t4 };
              return h(e3.attributes) || (n5.attributes = u({}, e3.attributes)), n5;
            }(r4, t3);
          });
          var r3 = new Array(this._edges.size);
          return n4 = 0, this._edges.forEach(function(e3, i3) {
            r3[n4++] = function(t3, e4, n5) {
              var r4 = { key: e4, source: n5.source.key, target: n5.target.key };
              return h(n5.attributes) || (r4.attributes = u({}, n5.attributes)), "mixed" === t3 && n5.undirected && (r4.undirected = true), r4;
            }(t2.type, i3, e3);
          }), { options: { type: this.type, multi: this.multi, allowSelfLoops: this.allowSelfLoops }, attributes: this.getAttributes(), nodes: e2, edges: r3 };
        }, i2.import = function(t2) {
          var e2, n4, i3, o2, a2, c2 = this, u2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          if (t2 instanceof r2)
            return t2.forEachNode(function(t3, e3) {
              u2 ? c2.mergeNode(t3, e3) : c2.addNode(t3, e3);
            }), t2.forEachEdge(function(t3, e3, n5, r3, i4, o3, a3) {
              u2 ? a3 ? c2.mergeUndirectedEdgeWithKey(t3, n5, r3, e3) : c2.mergeDirectedEdgeWithKey(t3, n5, r3, e3) : a3 ? c2.addUndirectedEdgeWithKey(t3, n5, r3, e3) : c2.addDirectedEdgeWithKey(t3, n5, r3, e3);
            }), this;
          if (!s2(t2))
            throw new B("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");
          if (t2.attributes) {
            if (!s2(t2.attributes))
              throw new B("Graph.import: invalid attributes. Expecting a plain object.");
            u2 ? this.mergeAttributes(t2.attributes) : this.replaceAttributes(t2.attributes);
          }
          if (t2.nodes) {
            if (i3 = t2.nodes, !Array.isArray(i3))
              throw new B("Graph.import: invalid nodes. Expecting an array.");
            for (e2 = 0, n4 = i3.length; e2 < n4; e2++) {
              Et(o2 = i3[e2]);
              var d2 = o2, h2 = d2.key, p2 = d2.attributes;
              u2 ? this.mergeNode(h2, p2) : this.addNode(h2, p2);
            }
          }
          if (t2.edges) {
            var f2 = false;
            if ("undirected" === this.type && (f2 = true), i3 = t2.edges, !Array.isArray(i3))
              throw new B("Graph.import: invalid edges. Expecting an array.");
            for (e2 = 0, n4 = i3.length; e2 < n4; e2++) {
              At(a2 = i3[e2]);
              var l3 = a2, g2 = l3.source, y2 = l3.target, w2 = l3.attributes, v2 = l3.undirected, b2 = void 0 === v2 ? f2 : v2;
              "key" in a2 ? (u2 ? b2 ? this.mergeUndirectedEdgeWithKey : this.mergeDirectedEdgeWithKey : b2 ? this.addUndirectedEdgeWithKey : this.addDirectedEdgeWithKey).call(this, a2.key, g2, y2, w2) : (u2 ? b2 ? this.mergeUndirectedEdge : this.mergeDirectedEdge : b2 ? this.addUndirectedEdge : this.addDirectedEdge).call(this, g2, y2, w2);
            }
          }
          return this;
        }, i2.nullCopy = function(t2) {
          var e2 = new r2(u({}, this._options, t2));
          return e2.replaceAttributes(u({}, this.getAttributes())), e2;
        }, i2.emptyCopy = function(t2) {
          var e2 = this.nullCopy(t2);
          return this._nodes.forEach(function(t3, n4) {
            var r3 = u({}, t3.attributes);
            t3 = new e2.NodeDataClass(n4, r3), e2._nodes.set(n4, t3);
          }), e2;
        }, i2.copy = function(t2) {
          if ("string" == typeof (t2 = t2 || {}).type && t2.type !== this.type && "mixed" !== t2.type)
            throw new I('Graph.copy: cannot create an incompatible copy from "'.concat(this.type, '" type to "').concat(t2.type, '" because this would mean losing information about the current graph.'));
          if ("boolean" == typeof t2.multi && t2.multi !== this.multi && true !== t2.multi)
            throw new I("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");
          if ("boolean" == typeof t2.allowSelfLoops && t2.allowSelfLoops !== this.allowSelfLoops && true !== t2.allowSelfLoops)
            throw new I("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");
          for (var e2, n4, r3 = this.emptyCopy(t2), i3 = this._edges.values(); true !== (e2 = i3.next()).done; )
            jt(r3, "copy", false, (n4 = e2.value).undirected, n4.key, n4.source.key, n4.target.key, u({}, n4.attributes));
          return r3;
        }, i2.toJSON = function() {
          return this.export();
        }, i2.toString = function() {
          return "[object Graph]";
        }, i2.inspect = function() {
          var e2 = this, n4 = {};
          this._nodes.forEach(function(t2, e3) {
            n4[e3] = t2.attributes;
          });
          var r3 = {}, i3 = {};
          this._edges.forEach(function(t2, n5) {
            var o3, a3 = t2.undirected ? "--" : "->", c2 = "", u2 = t2.source.key, d2 = t2.target.key;
            t2.undirected && u2 > d2 && (o3 = u2, u2 = d2, d2 = o3);
            var s3 = "(".concat(u2, ")").concat(a3, "(").concat(d2, ")");
            n5.startsWith("geid_") ? e2.multi && (void 0 === i3[s3] ? i3[s3] = 0 : i3[s3]++, c2 += "".concat(i3[s3], ". ")) : c2 += "[".concat(n5, "]: "), r3[c2 += s3] = t2.attributes;
          });
          var o2 = {};
          for (var a2 in this)
            this.hasOwnProperty(a2) && !Ut.has(a2) && "function" != typeof this[a2] && "symbol" !== t(a2) && (o2[a2] = this[a2]);
          return o2.attributes = this._attributes, o2.nodes = n4, o2.edges = r3, p(o2, "constructor", this.constructor), o2;
        }, r2;
      }(y.exports.EventEmitter);
      "undefined" != typeof Symbol && (zt.prototype[Symbol.for("nodejs.util.inspect.custom")] = zt.prototype.inspect), [{ name: function(t2) {
        return "".concat(t2, "Edge");
      }, generateKey: true }, { name: function(t2) {
        return "".concat(t2, "DirectedEdge");
      }, generateKey: true, type: "directed" }, { name: function(t2) {
        return "".concat(t2, "UndirectedEdge");
      }, generateKey: true, type: "undirected" }, { name: function(t2) {
        return "".concat(t2, "EdgeWithKey");
      } }, { name: function(t2) {
        return "".concat(t2, "DirectedEdgeWithKey");
      }, type: "directed" }, { name: function(t2) {
        return "".concat(t2, "UndirectedEdgeWithKey");
      }, type: "undirected" }].forEach(function(t2) {
        ["add", "merge", "update"].forEach(function(e2) {
          var n3 = t2.name(e2), r2 = "add" === e2 ? jt : Ct;
          t2.generateKey ? zt.prototype[n3] = function(i2, o2, a2) {
            return r2(this, n3, true, "undirected" === (t2.type || this.type), null, i2, o2, a2, "update" === e2);
          } : zt.prototype[n3] = function(i2, o2, a2, c2) {
            return r2(this, n3, false, "undirected" === (t2.type || this.type), i2, o2, a2, c2, "update" === e2);
          };
        });
      }), function(t2) {
        Q.forEach(function(e2) {
          var n3 = e2.name, r2 = e2.attacher;
          r2(t2, n3("Node"), 0), r2(t2, n3("Source"), 1), r2(t2, n3("Target"), 2), r2(t2, n3("Opposite"), 3);
        });
      }(zt), function(t2) {
        X.forEach(function(e2) {
          var n3 = e2.name, r2 = e2.attacher;
          r2(t2, n3("Edge"), "mixed"), r2(t2, n3("DirectedEdge"), "directed"), r2(t2, n3("UndirectedEdge"), "undirected");
        });
      }(zt), function(t2) {
        et.forEach(function(e2) {
          !function(t3, e3) {
            var n3 = e3.name, r2 = e3.type, i2 = e3.direction;
            t3.prototype[n3] = function(t4, e4) {
              if ("mixed" !== r2 && "mixed" !== this.type && r2 !== this.type)
                return [];
              if (!arguments.length)
                return ut(this, r2);
              if (1 === arguments.length) {
                t4 = "" + t4;
                var o2 = this._nodes.get(t4);
                if (void 0 === o2)
                  throw new F("Graph.".concat(n3, ': could not find the "').concat(t4, '" node in the graph.'));
                return pt(this.multi, "mixed" === r2 ? this.type : r2, i2, o2);
              }
              if (2 === arguments.length) {
                t4 = "" + t4, e4 = "" + e4;
                var a2 = this._nodes.get(t4);
                if (!a2)
                  throw new F("Graph.".concat(n3, ':  could not find the "').concat(t4, '" source node in the graph.'));
                if (!this._nodes.has(e4))
                  throw new F("Graph.".concat(n3, ':  could not find the "').concat(e4, '" target node in the graph.'));
                return gt(r2, this.multi, i2, a2, e4);
              }
              throw new B("Graph.".concat(n3, ": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length, ")."));
            };
          }(t2, e2), function(t3, e3) {
            var n3 = e3.name, r2 = e3.type, i2 = e3.direction, o2 = "forEach" + n3[0].toUpperCase() + n3.slice(1, -1);
            t3.prototype[o2] = function(t4, e4, n4) {
              if ("mixed" === r2 || "mixed" === this.type || r2 === this.type) {
                if (1 === arguments.length)
                  return dt(false, this, r2, n4 = t4);
                if (2 === arguments.length) {
                  t4 = "" + t4, n4 = e4;
                  var a3 = this._nodes.get(t4);
                  if (void 0 === a3)
                    throw new F("Graph.".concat(o2, ': could not find the "').concat(t4, '" node in the graph.'));
                  return ht(false, this.multi, "mixed" === r2 ? this.type : r2, i2, a3, n4);
                }
                if (3 === arguments.length) {
                  t4 = "" + t4, e4 = "" + e4;
                  var c3 = this._nodes.get(t4);
                  if (!c3)
                    throw new F("Graph.".concat(o2, ':  could not find the "').concat(t4, '" source node in the graph.'));
                  if (!this._nodes.has(e4))
                    throw new F("Graph.".concat(o2, ':  could not find the "').concat(e4, '" target node in the graph.'));
                  return lt(false, r2, this.multi, i2, c3, e4, n4);
                }
                throw new B("Graph.".concat(o2, ": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length, ")."));
              }
            };
            var a2 = "map" + n3[0].toUpperCase() + n3.slice(1);
            t3.prototype[a2] = function() {
              var t4, e4 = Array.prototype.slice.call(arguments), n4 = e4.pop();
              if (0 === e4.length) {
                var i3 = 0;
                "directed" !== r2 && (i3 += this.undirectedSize), "undirected" !== r2 && (i3 += this.directedSize), t4 = new Array(i3);
                var a3 = 0;
                e4.push(function(e5, r3, i4, o3, c3, u3, d2) {
                  t4[a3++] = n4(e5, r3, i4, o3, c3, u3, d2);
                });
              } else
                t4 = [], e4.push(function(e5, r3, i4, o3, a4, c3, u3) {
                  t4.push(n4(e5, r3, i4, o3, a4, c3, u3));
                });
              return this[o2].apply(this, e4), t4;
            };
            var c2 = "filter" + n3[0].toUpperCase() + n3.slice(1);
            t3.prototype[c2] = function() {
              var t4 = Array.prototype.slice.call(arguments), e4 = t4.pop(), n4 = [];
              return t4.push(function(t5, r3, i3, o3, a3, c3, u3) {
                e4(t5, r3, i3, o3, a3, c3, u3) && n4.push(t5);
              }), this[o2].apply(this, t4), n4;
            };
            var u2 = "reduce" + n3[0].toUpperCase() + n3.slice(1);
            t3.prototype[u2] = function() {
              var t4, e4, n4 = Array.prototype.slice.call(arguments);
              if (n4.length < 2 || n4.length > 4)
                throw new B("Graph.".concat(u2, ": invalid number of arguments (expecting 2, 3 or 4 and got ").concat(n4.length, ")."));
              if ("function" == typeof n4[n4.length - 1] && "function" != typeof n4[n4.length - 2])
                throw new B("Graph.".concat(u2, ": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));
              2 === n4.length ? (t4 = n4[0], e4 = n4[1], n4 = []) : 3 === n4.length ? (t4 = n4[1], e4 = n4[2], n4 = [n4[0]]) : 4 === n4.length && (t4 = n4[2], e4 = n4[3], n4 = [n4[0], n4[1]]);
              var r3 = e4;
              return n4.push(function(e5, n5, i3, o3, a3, c3, u3) {
                r3 = t4(r3, e5, n5, i3, o3, a3, c3, u3);
              }), this[o2].apply(this, n4), r3;
            };
          }(t2, e2), function(t3, e3) {
            var n3 = e3.name, r2 = e3.type, i2 = e3.direction, o2 = "find" + n3[0].toUpperCase() + n3.slice(1, -1);
            t3.prototype[o2] = function(t4, e4, n4) {
              if ("mixed" !== r2 && "mixed" !== this.type && r2 !== this.type)
                return false;
              if (1 === arguments.length)
                return dt(true, this, r2, n4 = t4);
              if (2 === arguments.length) {
                t4 = "" + t4, n4 = e4;
                var a3 = this._nodes.get(t4);
                if (void 0 === a3)
                  throw new F("Graph.".concat(o2, ': could not find the "').concat(t4, '" node in the graph.'));
                return ht(true, this.multi, "mixed" === r2 ? this.type : r2, i2, a3, n4);
              }
              if (3 === arguments.length) {
                t4 = "" + t4, e4 = "" + e4;
                var c3 = this._nodes.get(t4);
                if (!c3)
                  throw new F("Graph.".concat(o2, ':  could not find the "').concat(t4, '" source node in the graph.'));
                if (!this._nodes.has(e4))
                  throw new F("Graph.".concat(o2, ':  could not find the "').concat(e4, '" target node in the graph.'));
                return lt(true, r2, this.multi, i2, c3, e4, n4);
              }
              throw new B("Graph.".concat(o2, ": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length, ")."));
            };
            var a2 = "some" + n3[0].toUpperCase() + n3.slice(1, -1);
            t3.prototype[a2] = function() {
              var t4 = Array.prototype.slice.call(arguments), e4 = t4.pop();
              return t4.push(function(t5, n4, r3, i3, o3, a3, c3) {
                return e4(t5, n4, r3, i3, o3, a3, c3);
              }), !!this[o2].apply(this, t4);
            };
            var c2 = "every" + n3[0].toUpperCase() + n3.slice(1, -1);
            t3.prototype[c2] = function() {
              var t4 = Array.prototype.slice.call(arguments), e4 = t4.pop();
              return t4.push(function(t5, n4, r3, i3, o3, a3, c3) {
                return !e4(t5, n4, r3, i3, o3, a3, c3);
              }), !this[o2].apply(this, t4);
            };
          }(t2, e2), function(t3, e3) {
            var n3 = e3.name, r2 = e3.type, i2 = e3.direction, o2 = n3.slice(0, -1) + "Entries";
            t3.prototype[o2] = function(t4, e4) {
              if ("mixed" !== r2 && "mixed" !== this.type && r2 !== this.type)
                return O.empty();
              if (!arguments.length)
                return st(this, r2);
              if (1 === arguments.length) {
                t4 = "" + t4;
                var n4 = this._nodes.get(t4);
                if (!n4)
                  throw new F("Graph.".concat(o2, ': could not find the "').concat(t4, '" node in the graph.'));
                return ft(r2, i2, n4);
              }
              if (2 === arguments.length) {
                t4 = "" + t4, e4 = "" + e4;
                var a2 = this._nodes.get(t4);
                if (!a2)
                  throw new F("Graph.".concat(o2, ':  could not find the "').concat(t4, '" source node in the graph.'));
                if (!this._nodes.has(e4))
                  throw new F("Graph.".concat(o2, ':  could not find the "').concat(e4, '" target node in the graph.'));
                return yt(r2, i2, a2, e4);
              }
              throw new B("Graph.".concat(o2, ": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length, ")."));
            };
          }(t2, e2);
        });
      }(zt), function(t2) {
        wt.forEach(function(e2) {
          _t(t2, e2), function(t3, e3) {
            var n3 = e3.name, r2 = e3.type, i2 = e3.direction, o2 = "forEach" + n3[0].toUpperCase() + n3.slice(1, -1);
            t3.prototype[o2] = function(t4, e4) {
              if ("mixed" === r2 || "mixed" === this.type || r2 === this.type) {
                t4 = "" + t4;
                var n4 = this._nodes.get(t4);
                if (void 0 === n4)
                  throw new F("Graph.".concat(o2, ': could not find the "').concat(t4, '" node in the graph.'));
                mt(false, "mixed" === r2 ? this.type : r2, i2, n4, e4);
              }
            };
            var a2 = "map" + n3[0].toUpperCase() + n3.slice(1);
            t3.prototype[a2] = function(t4, e4) {
              var n4 = [];
              return this[o2](t4, function(t5, r3) {
                n4.push(e4(t5, r3));
              }), n4;
            };
            var c2 = "filter" + n3[0].toUpperCase() + n3.slice(1);
            t3.prototype[c2] = function(t4, e4) {
              var n4 = [];
              return this[o2](t4, function(t5, r3) {
                e4(t5, r3) && n4.push(t5);
              }), n4;
            };
            var u2 = "reduce" + n3[0].toUpperCase() + n3.slice(1);
            t3.prototype[u2] = function(t4, e4, n4) {
              if (arguments.length < 3)
                throw new B("Graph.".concat(u2, ": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));
              var r3 = n4;
              return this[o2](t4, function(t5, n5) {
                r3 = e4(r3, t5, n5);
              }), r3;
            };
          }(t2, e2), function(t3, e3) {
            var n3 = e3.name, r2 = e3.type, i2 = e3.direction, o2 = n3[0].toUpperCase() + n3.slice(1, -1), a2 = "find" + o2;
            t3.prototype[a2] = function(t4, e4) {
              if ("mixed" === r2 || "mixed" === this.type || r2 === this.type) {
                t4 = "" + t4;
                var n4 = this._nodes.get(t4);
                if (void 0 === n4)
                  throw new F("Graph.".concat(a2, ': could not find the "').concat(t4, '" node in the graph.'));
                return mt(true, "mixed" === r2 ? this.type : r2, i2, n4, e4);
              }
            };
            var c2 = "some" + o2;
            t3.prototype[c2] = function(t4, e4) {
              return !!this[a2](t4, e4);
            };
            var u2 = "every" + o2;
            t3.prototype[u2] = function(t4, e4) {
              return !this[a2](t4, function(t5, n4) {
                return !e4(t5, n4);
              });
            };
          }(t2, e2), Gt(t2, e2);
        });
      }(zt);
      var Wt = function(t2) {
        function n3(e2) {
          var n4 = u({ type: "directed" }, e2);
          if ("multi" in n4 && false !== n4.multi)
            throw new B("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");
          if ("directed" !== n4.type)
            throw new B('DirectedGraph.from: inconsistent "' + n4.type + '" type in given options!');
          return t2.call(this, n4) || this;
        }
        return e(n3, t2), n3;
      }(zt), Pt = function(t2) {
        function n3(e2) {
          var n4 = u({ type: "undirected" }, e2);
          if ("multi" in n4 && false !== n4.multi)
            throw new B("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");
          if ("undirected" !== n4.type)
            throw new B('UndirectedGraph.from: inconsistent "' + n4.type + '" type in given options!');
          return t2.call(this, n4) || this;
        }
        return e(n3, t2), n3;
      }(zt), Rt = function(t2) {
        function n3(e2) {
          var n4 = u({ multi: true }, e2);
          if ("multi" in n4 && true !== n4.multi)
            throw new B("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");
          return t2.call(this, n4) || this;
        }
        return e(n3, t2), n3;
      }(zt), Kt = function(t2) {
        function n3(e2) {
          var n4 = u({ type: "directed", multi: true }, e2);
          if ("multi" in n4 && true !== n4.multi)
            throw new B("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");
          if ("directed" !== n4.type)
            throw new B('MultiDirectedGraph.from: inconsistent "' + n4.type + '" type in given options!');
          return t2.call(this, n4) || this;
        }
        return e(n3, t2), n3;
      }(zt), Tt = function(t2) {
        function n3(e2) {
          var n4 = u({ type: "undirected", multi: true }, e2);
          if ("multi" in n4 && true !== n4.multi)
            throw new B("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");
          if ("undirected" !== n4.type)
            throw new B('MultiUndirectedGraph.from: inconsistent "' + n4.type + '" type in given options!');
          return t2.call(this, n4) || this;
        }
        return e(n3, t2), n3;
      }(zt);
      function Bt(t2) {
        t2.from = function(e2, n3) {
          var r2 = u({}, e2.options, n3), i2 = new t2(r2);
          return i2.import(e2), i2;
        };
      }
      return Bt(zt), Bt(Wt), Bt(Pt), Bt(Rt), Bt(Kt), Bt(Tt), zt.Graph = zt, zt.DirectedGraph = Wt, zt.UndirectedGraph = Pt, zt.MultiGraph = Rt, zt.MultiDirectedGraph = Kt, zt.MultiUndirectedGraph = Tt, zt.InvalidArgumentsGraphError = B, zt.NotFoundGraphError = F, zt.UsageGraphError = I, zt;
    });
  }
});

// node_modules/obsidian-dataview/lib/index.js
var require_lib = __commonJS({
  "node_modules/obsidian-dataview/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require("obsidian");
    var LuxonError2 = class extends Error {
    };
    var InvalidDateTimeError2 = class extends LuxonError2 {
      constructor(reason) {
        super(`Invalid DateTime: ${reason.toMessage()}`);
      }
    };
    var InvalidIntervalError2 = class extends LuxonError2 {
      constructor(reason) {
        super(`Invalid Interval: ${reason.toMessage()}`);
      }
    };
    var InvalidDurationError2 = class extends LuxonError2 {
      constructor(reason) {
        super(`Invalid Duration: ${reason.toMessage()}`);
      }
    };
    var ConflictingSpecificationError2 = class extends LuxonError2 {
    };
    var InvalidUnitError2 = class extends LuxonError2 {
      constructor(unit) {
        super(`Invalid unit ${unit}`);
      }
    };
    var InvalidArgumentError2 = class extends LuxonError2 {
    };
    var ZoneIsAbstractError2 = class extends LuxonError2 {
      constructor() {
        super("Zone is an abstract class");
      }
    };
    var n2 = "numeric";
    var s2 = "short";
    var l2 = "long";
    var DATE_SHORT2 = {
      year: n2,
      month: n2,
      day: n2
    };
    var DATE_MED2 = {
      year: n2,
      month: s2,
      day: n2
    };
    var DATE_MED_WITH_WEEKDAY2 = {
      year: n2,
      month: s2,
      day: n2,
      weekday: s2
    };
    var DATE_FULL2 = {
      year: n2,
      month: l2,
      day: n2
    };
    var DATE_HUGE2 = {
      year: n2,
      month: l2,
      day: n2,
      weekday: l2
    };
    var TIME_SIMPLE2 = {
      hour: n2,
      minute: n2
    };
    var TIME_WITH_SECONDS2 = {
      hour: n2,
      minute: n2,
      second: n2
    };
    var TIME_WITH_SHORT_OFFSET2 = {
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: s2
    };
    var TIME_WITH_LONG_OFFSET2 = {
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: l2
    };
    var TIME_24_SIMPLE2 = {
      hour: n2,
      minute: n2,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SECONDS2 = {
      hour: n2,
      minute: n2,
      second: n2,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SHORT_OFFSET2 = {
      hour: n2,
      minute: n2,
      second: n2,
      hourCycle: "h23",
      timeZoneName: s2
    };
    var TIME_24_WITH_LONG_OFFSET2 = {
      hour: n2,
      minute: n2,
      second: n2,
      hourCycle: "h23",
      timeZoneName: l2
    };
    var DATETIME_SHORT2 = {
      year: n2,
      month: n2,
      day: n2,
      hour: n2,
      minute: n2
    };
    var DATETIME_SHORT_WITH_SECONDS2 = {
      year: n2,
      month: n2,
      day: n2,
      hour: n2,
      minute: n2,
      second: n2
    };
    var DATETIME_MED2 = {
      year: n2,
      month: s2,
      day: n2,
      hour: n2,
      minute: n2
    };
    var DATETIME_MED_WITH_SECONDS2 = {
      year: n2,
      month: s2,
      day: n2,
      hour: n2,
      minute: n2,
      second: n2
    };
    var DATETIME_MED_WITH_WEEKDAY2 = {
      year: n2,
      month: s2,
      day: n2,
      weekday: s2,
      hour: n2,
      minute: n2
    };
    var DATETIME_FULL2 = {
      year: n2,
      month: l2,
      day: n2,
      hour: n2,
      minute: n2,
      timeZoneName: s2
    };
    var DATETIME_FULL_WITH_SECONDS2 = {
      year: n2,
      month: l2,
      day: n2,
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: s2
    };
    var DATETIME_HUGE2 = {
      year: n2,
      month: l2,
      day: n2,
      weekday: l2,
      hour: n2,
      minute: n2,
      timeZoneName: l2
    };
    var DATETIME_HUGE_WITH_SECONDS2 = {
      year: n2,
      month: l2,
      day: n2,
      weekday: l2,
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: l2
    };
    var Zone2 = class {
      /**
       * The type of zone
       * @abstract
       * @type {string}
       */
      get type() {
        throw new ZoneIsAbstractError2();
      }
      /**
       * The name of this zone.
       * @abstract
       * @type {string}
       */
      get name() {
        throw new ZoneIsAbstractError2();
      }
      get ianaName() {
        return this.name;
      }
      /**
       * Returns whether the offset is known to be fixed for the whole year.
       * @abstract
       * @type {boolean}
       */
      get isUniversal() {
        throw new ZoneIsAbstractError2();
      }
      /**
       * Returns the offset's common name (such as EST) at the specified timestamp
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to get the name
       * @param {Object} opts - Options to affect the format
       * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
       * @param {string} opts.locale - What locale to return the offset name in.
       * @return {string}
       */
      offsetName(ts, opts) {
        throw new ZoneIsAbstractError2();
      }
      /**
       * Returns the offset's value as a string
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to get the offset
       * @param {string} format - What style of offset to return.
       *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
       * @return {string}
       */
      formatOffset(ts, format) {
        throw new ZoneIsAbstractError2();
      }
      /**
       * Return the offset in minutes for this zone at the specified timestamp.
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to compute the offset
       * @return {number}
       */
      offset(ts) {
        throw new ZoneIsAbstractError2();
      }
      /**
       * Return whether this Zone is equal to another zone
       * @abstract
       * @param {Zone} otherZone - the zone to compare
       * @return {boolean}
       */
      equals(otherZone) {
        throw new ZoneIsAbstractError2();
      }
      /**
       * Return whether this Zone is valid.
       * @abstract
       * @type {boolean}
       */
      get isValid() {
        throw new ZoneIsAbstractError2();
      }
    };
    var singleton$1 = null;
    var SystemZone2 = class _SystemZone extends Zone2 {
      /**
       * Get a singleton instance of the local zone
       * @return {SystemZone}
       */
      static get instance() {
        if (singleton$1 === null) {
          singleton$1 = new _SystemZone();
        }
        return singleton$1;
      }
      /** @override **/
      get type() {
        return "system";
      }
      /** @override **/
      get name() {
        return new Intl.DateTimeFormat().resolvedOptions().timeZone;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName(ts, { format, locale }) {
        return parseZoneInfo2(ts, format, locale);
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset2(this.offset(ts), format);
      }
      /** @override **/
      offset(ts) {
        return -new Date(ts).getTimezoneOffset();
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "system";
      }
      /** @override **/
      get isValid() {
        return true;
      }
    };
    var dtfCache2 = {};
    function makeDTF2(zone) {
      if (!dtfCache2[zone]) {
        dtfCache2[zone] = new Intl.DateTimeFormat("en-US", {
          hour12: false,
          timeZone: zone,
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          era: "short"
        });
      }
      return dtfCache2[zone];
    }
    var typeToPos2 = {
      year: 0,
      month: 1,
      day: 2,
      era: 3,
      hour: 4,
      minute: 5,
      second: 6
    };
    function hackyOffset2(dtf, date) {
      const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
      return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
    }
    function partsOffset2(dtf, date) {
      const formatted = dtf.formatToParts(date);
      const filled = [];
      for (let i = 0; i < formatted.length; i++) {
        const { type, value } = formatted[i];
        const pos = typeToPos2[type];
        if (type === "era") {
          filled[pos] = value;
        } else if (!isUndefined2(pos)) {
          filled[pos] = parseInt(value, 10);
        }
      }
      return filled;
    }
    var ianaZoneCache2 = {};
    var IANAZone2 = class _IANAZone extends Zone2 {
      /**
       * @param {string} name - Zone name
       * @return {IANAZone}
       */
      static create(name) {
        if (!ianaZoneCache2[name]) {
          ianaZoneCache2[name] = new _IANAZone(name);
        }
        return ianaZoneCache2[name];
      }
      /**
       * Reset local caches. Should only be necessary in testing scenarios.
       * @return {void}
       */
      static resetCache() {
        ianaZoneCache2 = {};
        dtfCache2 = {};
      }
      /**
       * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
       * @param {string} s - The string to check validity on
       * @example IANAZone.isValidSpecifier("America/New_York") //=> true
       * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
       * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
       * @return {boolean}
       */
      static isValidSpecifier(s3) {
        return this.isValidZone(s3);
      }
      /**
       * Returns whether the provided string identifies a real zone
       * @param {string} zone - The string to check
       * @example IANAZone.isValidZone("America/New_York") //=> true
       * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
       * @example IANAZone.isValidZone("Sport~~blorp") //=> false
       * @return {boolean}
       */
      static isValidZone(zone) {
        if (!zone) {
          return false;
        }
        try {
          new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
          return true;
        } catch (e) {
          return false;
        }
      }
      constructor(name) {
        super();
        this.zoneName = name;
        this.valid = _IANAZone.isValidZone(name);
      }
      /** @override **/
      get type() {
        return "iana";
      }
      /** @override **/
      get name() {
        return this.zoneName;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName(ts, { format, locale }) {
        return parseZoneInfo2(ts, format, locale, this.name);
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset2(this.offset(ts), format);
      }
      /** @override **/
      offset(ts) {
        const date = new Date(ts);
        if (isNaN(date))
          return NaN;
        const dtf = makeDTF2(this.name);
        let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset2(dtf, date) : hackyOffset2(dtf, date);
        if (adOrBc === "BC") {
          year = -Math.abs(year) + 1;
        }
        const adjustedHour = hour === 24 ? 0 : hour;
        const asUTC = objToLocalTS2({
          year,
          month,
          day,
          hour: adjustedHour,
          minute,
          second,
          millisecond: 0
        });
        let asTS = +date;
        const over = asTS % 1e3;
        asTS -= over >= 0 ? over : 1e3 + over;
        return (asUTC - asTS) / (60 * 1e3);
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "iana" && otherZone.name === this.name;
      }
      /** @override **/
      get isValid() {
        return this.valid;
      }
    };
    var intlLFCache2 = {};
    function getCachedLF2(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let dtf = intlLFCache2[key];
      if (!dtf) {
        dtf = new Intl.ListFormat(locString, opts);
        intlLFCache2[key] = dtf;
      }
      return dtf;
    }
    var intlDTCache2 = {};
    function getCachedDTF2(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let dtf = intlDTCache2[key];
      if (!dtf) {
        dtf = new Intl.DateTimeFormat(locString, opts);
        intlDTCache2[key] = dtf;
      }
      return dtf;
    }
    var intlNumCache2 = {};
    function getCachedINF2(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let inf = intlNumCache2[key];
      if (!inf) {
        inf = new Intl.NumberFormat(locString, opts);
        intlNumCache2[key] = inf;
      }
      return inf;
    }
    var intlRelCache2 = {};
    function getCachedRTF2(locString, opts = {}) {
      const { base, ...cacheKeyOpts } = opts;
      const key = JSON.stringify([locString, cacheKeyOpts]);
      let inf = intlRelCache2[key];
      if (!inf) {
        inf = new Intl.RelativeTimeFormat(locString, opts);
        intlRelCache2[key] = inf;
      }
      return inf;
    }
    var sysLocaleCache2 = null;
    function systemLocale2() {
      if (sysLocaleCache2) {
        return sysLocaleCache2;
      } else {
        sysLocaleCache2 = new Intl.DateTimeFormat().resolvedOptions().locale;
        return sysLocaleCache2;
      }
    }
    function parseLocaleString2(localeStr) {
      const xIndex = localeStr.indexOf("-x-");
      if (xIndex !== -1) {
        localeStr = localeStr.substring(0, xIndex);
      }
      const uIndex = localeStr.indexOf("-u-");
      if (uIndex === -1) {
        return [localeStr];
      } else {
        let options;
        let selectedStr;
        try {
          options = getCachedDTF2(localeStr).resolvedOptions();
          selectedStr = localeStr;
        } catch (e) {
          const smaller = localeStr.substring(0, uIndex);
          options = getCachedDTF2(smaller).resolvedOptions();
          selectedStr = smaller;
        }
        const { numberingSystem, calendar } = options;
        return [selectedStr, numberingSystem, calendar];
      }
    }
    function intlConfigString2(localeStr, numberingSystem, outputCalendar) {
      if (outputCalendar || numberingSystem) {
        if (!localeStr.includes("-u-")) {
          localeStr += "-u";
        }
        if (outputCalendar) {
          localeStr += `-ca-${outputCalendar}`;
        }
        if (numberingSystem) {
          localeStr += `-nu-${numberingSystem}`;
        }
        return localeStr;
      } else {
        return localeStr;
      }
    }
    function mapMonths2(f) {
      const ms = [];
      for (let i = 1; i <= 12; i++) {
        const dt = DateTime2.utc(2009, i, 1);
        ms.push(f(dt));
      }
      return ms;
    }
    function mapWeekdays2(f) {
      const ms = [];
      for (let i = 1; i <= 7; i++) {
        const dt = DateTime2.utc(2016, 11, 13 + i);
        ms.push(f(dt));
      }
      return ms;
    }
    function listStuff2(loc, length, englishFn, intlFn) {
      const mode = loc.listingMode();
      if (mode === "error") {
        return null;
      } else if (mode === "en") {
        return englishFn(length);
      } else {
        return intlFn(length);
      }
    }
    function supportsFastNumbers2(loc) {
      if (loc.numberingSystem && loc.numberingSystem !== "latn") {
        return false;
      } else {
        return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
      }
    }
    var PolyNumberFormatter2 = class {
      constructor(intl, forceSimple, opts) {
        this.padTo = opts.padTo || 0;
        this.floor = opts.floor || false;
        const { padTo, floor, ...otherOpts } = opts;
        if (!forceSimple || Object.keys(otherOpts).length > 0) {
          const intlOpts = { useGrouping: false, ...opts };
          if (opts.padTo > 0)
            intlOpts.minimumIntegerDigits = opts.padTo;
          this.inf = getCachedINF2(intl, intlOpts);
        }
      }
      format(i) {
        if (this.inf) {
          const fixed = this.floor ? Math.floor(i) : i;
          return this.inf.format(fixed);
        } else {
          const fixed = this.floor ? Math.floor(i) : roundTo2(i, 3);
          return padStart2(fixed, this.padTo);
        }
      }
    };
    var PolyDateFormatter2 = class {
      constructor(dt, intl, opts) {
        this.opts = opts;
        this.originalZone = void 0;
        let z = void 0;
        if (this.opts.timeZone) {
          this.dt = dt;
        } else if (dt.zone.type === "fixed") {
          const gmtOffset = -1 * (dt.offset / 60);
          const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
          if (dt.offset !== 0 && IANAZone2.create(offsetZ).valid) {
            z = offsetZ;
            this.dt = dt;
          } else {
            z = "UTC";
            this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
            this.originalZone = dt.zone;
          }
        } else if (dt.zone.type === "system") {
          this.dt = dt;
        } else if (dt.zone.type === "iana") {
          this.dt = dt;
          z = dt.zone.name;
        } else {
          z = "UTC";
          this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
          this.originalZone = dt.zone;
        }
        const intlOpts = { ...this.opts };
        intlOpts.timeZone = intlOpts.timeZone || z;
        this.dtf = getCachedDTF2(intl, intlOpts);
      }
      format() {
        if (this.originalZone) {
          return this.formatToParts().map(({ value }) => value).join("");
        }
        return this.dtf.format(this.dt.toJSDate());
      }
      formatToParts() {
        const parts = this.dtf.formatToParts(this.dt.toJSDate());
        if (this.originalZone) {
          return parts.map((part) => {
            if (part.type === "timeZoneName") {
              const offsetName = this.originalZone.offsetName(this.dt.ts, {
                locale: this.dt.locale,
                format: this.opts.timeZoneName
              });
              return {
                ...part,
                value: offsetName
              };
            } else {
              return part;
            }
          });
        }
        return parts;
      }
      resolvedOptions() {
        return this.dtf.resolvedOptions();
      }
    };
    var PolyRelFormatter2 = class {
      constructor(intl, isEnglish, opts) {
        this.opts = { style: "long", ...opts };
        if (!isEnglish && hasRelative2()) {
          this.rtf = getCachedRTF2(intl, opts);
        }
      }
      format(count, unit) {
        if (this.rtf) {
          return this.rtf.format(count, unit);
        } else {
          return formatRelativeTime2(unit, count, this.opts.numeric, this.opts.style !== "long");
        }
      }
      formatToParts(count, unit) {
        if (this.rtf) {
          return this.rtf.formatToParts(count, unit);
        } else {
          return [];
        }
      }
    };
    var Locale2 = class _Locale {
      static fromOpts(opts) {
        return _Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
      }
      static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
        const specifiedLocale = locale || Settings3.defaultLocale;
        const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale2());
        const numberingSystemR = numberingSystem || Settings3.defaultNumberingSystem;
        const outputCalendarR = outputCalendar || Settings3.defaultOutputCalendar;
        return new _Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
      }
      static resetCache() {
        sysLocaleCache2 = null;
        intlDTCache2 = {};
        intlNumCache2 = {};
        intlRelCache2 = {};
      }
      static fromObject({ locale, numberingSystem, outputCalendar } = {}) {
        return _Locale.create(locale, numberingSystem, outputCalendar);
      }
      constructor(locale, numbering, outputCalendar, specifiedLocale) {
        const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString2(locale);
        this.locale = parsedLocale;
        this.numberingSystem = numbering || parsedNumberingSystem || null;
        this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
        this.intl = intlConfigString2(this.locale, this.numberingSystem, this.outputCalendar);
        this.weekdaysCache = { format: {}, standalone: {} };
        this.monthsCache = { format: {}, standalone: {} };
        this.meridiemCache = null;
        this.eraCache = {};
        this.specifiedLocale = specifiedLocale;
        this.fastNumbersCached = null;
      }
      get fastNumbers() {
        if (this.fastNumbersCached == null) {
          this.fastNumbersCached = supportsFastNumbers2(this);
        }
        return this.fastNumbersCached;
      }
      listingMode() {
        const isActuallyEn = this.isEnglish();
        const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
        return isActuallyEn && hasNoWeirdness ? "en" : "intl";
      }
      clone(alts) {
        if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
          return this;
        } else {
          return _Locale.create(
            alts.locale || this.specifiedLocale,
            alts.numberingSystem || this.numberingSystem,
            alts.outputCalendar || this.outputCalendar,
            alts.defaultToEN || false
          );
        }
      }
      redefaultToEN(alts = {}) {
        return this.clone({ ...alts, defaultToEN: true });
      }
      redefaultToSystem(alts = {}) {
        return this.clone({ ...alts, defaultToEN: false });
      }
      months(length, format = false) {
        return listStuff2(this, length, months2, () => {
          const intl = format ? { month: length, day: "numeric" } : { month: length }, formatStr = format ? "format" : "standalone";
          if (!this.monthsCache[formatStr][length]) {
            this.monthsCache[formatStr][length] = mapMonths2((dt) => this.extract(dt, intl, "month"));
          }
          return this.monthsCache[formatStr][length];
        });
      }
      weekdays(length, format = false) {
        return listStuff2(this, length, weekdays2, () => {
          const intl = format ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format ? "format" : "standalone";
          if (!this.weekdaysCache[formatStr][length]) {
            this.weekdaysCache[formatStr][length] = mapWeekdays2(
              (dt) => this.extract(dt, intl, "weekday")
            );
          }
          return this.weekdaysCache[formatStr][length];
        });
      }
      meridiems() {
        return listStuff2(
          this,
          void 0,
          () => meridiems2,
          () => {
            if (!this.meridiemCache) {
              const intl = { hour: "numeric", hourCycle: "h12" };
              this.meridiemCache = [DateTime2.utc(2016, 11, 13, 9), DateTime2.utc(2016, 11, 13, 19)].map(
                (dt) => this.extract(dt, intl, "dayperiod")
              );
            }
            return this.meridiemCache;
          }
        );
      }
      eras(length) {
        return listStuff2(this, length, eras2, () => {
          const intl = { era: length };
          if (!this.eraCache[length]) {
            this.eraCache[length] = [DateTime2.utc(-40, 1, 1), DateTime2.utc(2017, 1, 1)].map(
              (dt) => this.extract(dt, intl, "era")
            );
          }
          return this.eraCache[length];
        });
      }
      extract(dt, intlOpts, field) {
        const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m) => m.type.toLowerCase() === field);
        return matching ? matching.value : null;
      }
      numberFormatter(opts = {}) {
        return new PolyNumberFormatter2(this.intl, opts.forceSimple || this.fastNumbers, opts);
      }
      dtFormatter(dt, intlOpts = {}) {
        return new PolyDateFormatter2(dt, this.intl, intlOpts);
      }
      relFormatter(opts = {}) {
        return new PolyRelFormatter2(this.intl, this.isEnglish(), opts);
      }
      listFormatter(opts = {}) {
        return getCachedLF2(this.intl, opts);
      }
      isEnglish() {
        return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
      }
      equals(other) {
        return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
      }
    };
    var singleton3 = null;
    var FixedOffsetZone2 = class _FixedOffsetZone extends Zone2 {
      /**
       * Get a singleton instance of UTC
       * @return {FixedOffsetZone}
       */
      static get utcInstance() {
        if (singleton3 === null) {
          singleton3 = new _FixedOffsetZone(0);
        }
        return singleton3;
      }
      /**
       * Get an instance with a specified offset
       * @param {number} offset - The offset in minutes
       * @return {FixedOffsetZone}
       */
      static instance(offset3) {
        return offset3 === 0 ? _FixedOffsetZone.utcInstance : new _FixedOffsetZone(offset3);
      }
      /**
       * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
       * @param {string} s - The offset string to parse
       * @example FixedOffsetZone.parseSpecifier("UTC+6")
       * @example FixedOffsetZone.parseSpecifier("UTC+06")
       * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
       * @return {FixedOffsetZone}
       */
      static parseSpecifier(s3) {
        if (s3) {
          const r = s3.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
          if (r) {
            return new _FixedOffsetZone(signedOffset2(r[1], r[2]));
          }
        }
        return null;
      }
      constructor(offset3) {
        super();
        this.fixed = offset3;
      }
      /** @override **/
      get type() {
        return "fixed";
      }
      /** @override **/
      get name() {
        return this.fixed === 0 ? "UTC" : `UTC${formatOffset2(this.fixed, "narrow")}`;
      }
      get ianaName() {
        if (this.fixed === 0) {
          return "Etc/UTC";
        } else {
          return `Etc/GMT${formatOffset2(-this.fixed, "narrow")}`;
        }
      }
      /** @override **/
      offsetName() {
        return this.name;
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset2(this.fixed, format);
      }
      /** @override **/
      get isUniversal() {
        return true;
      }
      /** @override **/
      offset() {
        return this.fixed;
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
      }
      /** @override **/
      get isValid() {
        return true;
      }
    };
    var InvalidZone2 = class extends Zone2 {
      constructor(zoneName) {
        super();
        this.zoneName = zoneName;
      }
      /** @override **/
      get type() {
        return "invalid";
      }
      /** @override **/
      get name() {
        return this.zoneName;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName() {
        return null;
      }
      /** @override **/
      formatOffset() {
        return "";
      }
      /** @override **/
      offset() {
        return NaN;
      }
      /** @override **/
      equals() {
        return false;
      }
      /** @override **/
      get isValid() {
        return false;
      }
    };
    function normalizeZone2(input, defaultZone3) {
      if (isUndefined2(input) || input === null) {
        return defaultZone3;
      } else if (input instanceof Zone2) {
        return input;
      } else if (isString2(input)) {
        const lowered = input.toLowerCase();
        if (lowered === "default")
          return defaultZone3;
        else if (lowered === "local" || lowered === "system")
          return SystemZone2.instance;
        else if (lowered === "utc" || lowered === "gmt")
          return FixedOffsetZone2.utcInstance;
        else
          return FixedOffsetZone2.parseSpecifier(lowered) || IANAZone2.create(input);
      } else if (isNumber2(input)) {
        return FixedOffsetZone2.instance(input);
      } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
        return input;
      } else {
        return new InvalidZone2(input);
      }
    }
    var now3 = () => Date.now();
    var defaultZone2 = "system";
    var defaultLocale2 = null;
    var defaultNumberingSystem2 = null;
    var defaultOutputCalendar2 = null;
    var twoDigitCutoffYear2 = 60;
    var throwOnInvalid2;
    var Settings3 = class {
      /**
       * Get the callback for returning the current timestamp.
       * @type {function}
       */
      static get now() {
        return now3;
      }
      /**
       * Set the callback for returning the current timestamp.
       * The function should return a number, which will be interpreted as an Epoch millisecond count
       * @type {function}
       * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
       * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
       */
      static set now(n3) {
        now3 = n3;
      }
      /**
       * Set the default time zone to create DateTimes in. Does not affect existing instances.
       * Use the value "system" to reset this value to the system's time zone.
       * @type {string}
       */
      static set defaultZone(zone) {
        defaultZone2 = zone;
      }
      /**
       * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
       * The default value is the system's time zone (the one set on the machine that runs this code).
       * @type {Zone}
       */
      static get defaultZone() {
        return normalizeZone2(defaultZone2, SystemZone2.instance);
      }
      /**
       * Get the default locale to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultLocale() {
        return defaultLocale2;
      }
      /**
       * Set the default locale to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultLocale(locale) {
        defaultLocale2 = locale;
      }
      /**
       * Get the default numbering system to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultNumberingSystem() {
        return defaultNumberingSystem2;
      }
      /**
       * Set the default numbering system to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultNumberingSystem(numberingSystem) {
        defaultNumberingSystem2 = numberingSystem;
      }
      /**
       * Get the default output calendar to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultOutputCalendar() {
        return defaultOutputCalendar2;
      }
      /**
       * Set the default output calendar to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultOutputCalendar(outputCalendar) {
        defaultOutputCalendar2 = outputCalendar;
      }
      /**
       * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
       * @type {number}
       */
      static get twoDigitCutoffYear() {
        return twoDigitCutoffYear2;
      }
      /**
       * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
       * @type {number}
       * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpreted as current century
       * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
       * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
       * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
       */
      static set twoDigitCutoffYear(cutoffYear) {
        twoDigitCutoffYear2 = cutoffYear % 100;
      }
      /**
       * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
       * @type {boolean}
       */
      static get throwOnInvalid() {
        return throwOnInvalid2;
      }
      /**
       * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
       * @type {boolean}
       */
      static set throwOnInvalid(t) {
        throwOnInvalid2 = t;
      }
      /**
       * Reset Luxon's global caches. Should only be necessary in testing scenarios.
       * @return {void}
       */
      static resetCaches() {
        Locale2.resetCache();
        IANAZone2.resetCache();
      }
    };
    function isUndefined2(o) {
      return typeof o === "undefined";
    }
    function isNumber2(o) {
      return typeof o === "number";
    }
    function isInteger2(o) {
      return typeof o === "number" && o % 1 === 0;
    }
    function isString2(o) {
      return typeof o === "string";
    }
    function isDate2(o) {
      return Object.prototype.toString.call(o) === "[object Date]";
    }
    function hasRelative2() {
      try {
        return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
      } catch (e) {
        return false;
      }
    }
    function maybeArray2(thing) {
      return Array.isArray(thing) ? thing : [thing];
    }
    function bestBy2(arr, by, compare) {
      if (arr.length === 0) {
        return void 0;
      }
      return arr.reduce((best, next) => {
        const pair = [by(next), next];
        if (!best) {
          return pair;
        } else if (compare(best[0], pair[0]) === best[0]) {
          return best;
        } else {
          return pair;
        }
      }, null)[1];
    }
    function pick2(obj, keys) {
      return keys.reduce((a, k) => {
        a[k] = obj[k];
        return a;
      }, {});
    }
    function hasOwnProperty2(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    function integerBetween2(thing, bottom, top) {
      return isInteger2(thing) && thing >= bottom && thing <= top;
    }
    function floorMod2(x, n3) {
      return x - n3 * Math.floor(x / n3);
    }
    function padStart2(input, n3 = 2) {
      const isNeg = input < 0;
      let padded;
      if (isNeg) {
        padded = "-" + ("" + -input).padStart(n3, "0");
      } else {
        padded = ("" + input).padStart(n3, "0");
      }
      return padded;
    }
    function parseInteger2(string) {
      if (isUndefined2(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseInt(string, 10);
      }
    }
    function parseFloating2(string) {
      if (isUndefined2(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseFloat(string);
      }
    }
    function parseMillis2(fraction) {
      if (isUndefined2(fraction) || fraction === null || fraction === "") {
        return void 0;
      } else {
        const f = parseFloat("0." + fraction) * 1e3;
        return Math.floor(f);
      }
    }
    function roundTo2(number, digits, towardZero = false) {
      const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
      return rounder(number * factor) / factor;
    }
    function isLeapYear2(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    function daysInYear2(year) {
      return isLeapYear2(year) ? 366 : 365;
    }
    function daysInMonth2(year, month) {
      const modMonth = floorMod2(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
      if (modMonth === 2) {
        return isLeapYear2(modYear) ? 29 : 28;
      } else {
        return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
      }
    }
    function objToLocalTS2(obj) {
      let d = Date.UTC(
        obj.year,
        obj.month - 1,
        obj.day,
        obj.hour,
        obj.minute,
        obj.second,
        obj.millisecond
      );
      if (obj.year < 100 && obj.year >= 0) {
        d = new Date(d);
        d.setUTCFullYear(obj.year, obj.month - 1, obj.day);
      }
      return +d;
    }
    function weeksInWeekYear2(weekYear) {
      const p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
      return p1 === 4 || p2 === 3 ? 53 : 52;
    }
    function untruncateYear2(year) {
      if (year > 99) {
        return year;
      } else
        return year > Settings3.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
    }
    function parseZoneInfo2(ts, offsetFormat, locale, timeZone = null) {
      const date = new Date(ts), intlOpts = {
        hourCycle: "h23",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit"
      };
      if (timeZone) {
        intlOpts.timeZone = timeZone;
      }
      const modified = { timeZoneName: offsetFormat, ...intlOpts };
      const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m) => m.type.toLowerCase() === "timezonename");
      return parsed ? parsed.value : null;
    }
    function signedOffset2(offHourStr, offMinuteStr) {
      let offHour = parseInt(offHourStr, 10);
      if (Number.isNaN(offHour)) {
        offHour = 0;
      }
      const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
      return offHour * 60 + offMinSigned;
    }
    function asNumber2(value) {
      const numericValue = Number(value);
      if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
        throw new InvalidArgumentError2(`Invalid unit value ${value}`);
      return numericValue;
    }
    function normalizeObject2(obj, normalizer) {
      const normalized = {};
      for (const u in obj) {
        if (hasOwnProperty2(obj, u)) {
          const v = obj[u];
          if (v === void 0 || v === null)
            continue;
          normalized[normalizer(u)] = asNumber2(v);
        }
      }
      return normalized;
    }
    function formatOffset2(offset3, format) {
      const hours = Math.trunc(Math.abs(offset3 / 60)), minutes = Math.trunc(Math.abs(offset3 % 60)), sign = offset3 >= 0 ? "+" : "-";
      switch (format) {
        case "short":
          return `${sign}${padStart2(hours, 2)}:${padStart2(minutes, 2)}`;
        case "narrow":
          return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
        case "techie":
          return `${sign}${padStart2(hours, 2)}${padStart2(minutes, 2)}`;
        default:
          throw new RangeError(`Value format ${format} is out of range for property format`);
      }
    }
    function timeObject2(obj) {
      return pick2(obj, ["hour", "minute", "second", "millisecond"]);
    }
    var monthsLong2 = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    var monthsShort2 = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    var monthsNarrow2 = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
    function months2(length) {
      switch (length) {
        case "narrow":
          return [...monthsNarrow2];
        case "short":
          return [...monthsShort2];
        case "long":
          return [...monthsLong2];
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
        case "2-digit":
          return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
        default:
          return null;
      }
    }
    var weekdaysLong2 = [
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
      "Sunday"
    ];
    var weekdaysShort2 = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    var weekdaysNarrow2 = ["M", "T", "W", "T", "F", "S", "S"];
    function weekdays2(length) {
      switch (length) {
        case "narrow":
          return [...weekdaysNarrow2];
        case "short":
          return [...weekdaysShort2];
        case "long":
          return [...weekdaysLong2];
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7"];
        default:
          return null;
      }
    }
    var meridiems2 = ["AM", "PM"];
    var erasLong2 = ["Before Christ", "Anno Domini"];
    var erasShort2 = ["BC", "AD"];
    var erasNarrow2 = ["B", "A"];
    function eras2(length) {
      switch (length) {
        case "narrow":
          return [...erasNarrow2];
        case "short":
          return [...erasShort2];
        case "long":
          return [...erasLong2];
        default:
          return null;
      }
    }
    function meridiemForDateTime2(dt) {
      return meridiems2[dt.hour < 12 ? 0 : 1];
    }
    function weekdayForDateTime2(dt, length) {
      return weekdays2(length)[dt.weekday - 1];
    }
    function monthForDateTime2(dt, length) {
      return months2(length)[dt.month - 1];
    }
    function eraForDateTime2(dt, length) {
      return eras2(length)[dt.year < 0 ? 0 : 1];
    }
    function formatRelativeTime2(unit, count, numeric = "always", narrow = false) {
      const units = {
        years: ["year", "yr."],
        quarters: ["quarter", "qtr."],
        months: ["month", "mo."],
        weeks: ["week", "wk."],
        days: ["day", "day", "days"],
        hours: ["hour", "hr."],
        minutes: ["minute", "min."],
        seconds: ["second", "sec."]
      };
      const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
      if (numeric === "auto" && lastable) {
        const isDay = unit === "days";
        switch (count) {
          case 1:
            return isDay ? "tomorrow" : `next ${units[unit][0]}`;
          case -1:
            return isDay ? "yesterday" : `last ${units[unit][0]}`;
          case 0:
            return isDay ? "today" : `this ${units[unit][0]}`;
        }
      }
      const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
      return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
    }
    function stringifyTokens2(splits, tokenToString) {
      let s3 = "";
      for (const token of splits) {
        if (token.literal) {
          s3 += token.val;
        } else {
          s3 += tokenToString(token.val);
        }
      }
      return s3;
    }
    var macroTokenToFormatOpts2 = {
      D: DATE_SHORT2,
      DD: DATE_MED2,
      DDD: DATE_FULL2,
      DDDD: DATE_HUGE2,
      t: TIME_SIMPLE2,
      tt: TIME_WITH_SECONDS2,
      ttt: TIME_WITH_SHORT_OFFSET2,
      tttt: TIME_WITH_LONG_OFFSET2,
      T: TIME_24_SIMPLE2,
      TT: TIME_24_WITH_SECONDS2,
      TTT: TIME_24_WITH_SHORT_OFFSET2,
      TTTT: TIME_24_WITH_LONG_OFFSET2,
      f: DATETIME_SHORT2,
      ff: DATETIME_MED2,
      fff: DATETIME_FULL2,
      ffff: DATETIME_HUGE2,
      F: DATETIME_SHORT_WITH_SECONDS2,
      FF: DATETIME_MED_WITH_SECONDS2,
      FFF: DATETIME_FULL_WITH_SECONDS2,
      FFFF: DATETIME_HUGE_WITH_SECONDS2
    };
    var Formatter2 = class _Formatter {
      static create(locale, opts = {}) {
        return new _Formatter(locale, opts);
      }
      static parseFormat(fmt) {
        let current = null, currentFull = "", bracketed = false;
        const splits = [];
        for (let i = 0; i < fmt.length; i++) {
          const c = fmt.charAt(i);
          if (c === "'") {
            if (currentFull.length > 0) {
              splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
            }
            current = null;
            currentFull = "";
            bracketed = !bracketed;
          } else if (bracketed) {
            currentFull += c;
          } else if (c === current) {
            currentFull += c;
          } else {
            if (currentFull.length > 0) {
              splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
            }
            currentFull = c;
            current = c;
          }
        }
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
        }
        return splits;
      }
      static macroTokenToFormatOpts(token) {
        return macroTokenToFormatOpts2[token];
      }
      constructor(locale, formatOpts) {
        this.opts = formatOpts;
        this.loc = locale;
        this.systemLoc = null;
      }
      formatWithSystemDefault(dt, opts) {
        if (this.systemLoc === null) {
          this.systemLoc = this.loc.redefaultToSystem();
        }
        const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
        return df.format();
      }
      dtFormatter(dt, opts = {}) {
        return this.loc.dtFormatter(dt, { ...this.opts, ...opts });
      }
      formatDateTime(dt, opts) {
        return this.dtFormatter(dt, opts).format();
      }
      formatDateTimeParts(dt, opts) {
        return this.dtFormatter(dt, opts).formatToParts();
      }
      formatInterval(interval, opts) {
        const df = this.dtFormatter(interval.start, opts);
        return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
      }
      resolvedOptions(dt, opts) {
        return this.dtFormatter(dt, opts).resolvedOptions();
      }
      num(n3, p = 0) {
        if (this.opts.forceSimple) {
          return padStart2(n3, p);
        }
        const opts = { ...this.opts };
        if (p > 0) {
          opts.padTo = p;
        }
        return this.loc.numberFormatter(opts).format(n3);
      }
      formatDateTimeFromString(dt, fmt) {
        const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset3 = (opts) => {
          if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
            return "Z";
          }
          return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
        }, meridiem = () => knownEnglish ? meridiemForDateTime2(dt) : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime2(dt, length) : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime2(dt, length) : string(
          standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
          "weekday"
        ), maybeMacro = (token) => {
          const formatOpts = _Formatter.macroTokenToFormatOpts(token);
          if (formatOpts) {
            return this.formatWithSystemDefault(dt, formatOpts);
          } else {
            return token;
          }
        }, era = (length) => knownEnglish ? eraForDateTime2(dt, length) : string({ era: length }, "era"), tokenToString = (token) => {
          switch (token) {
            case "S":
              return this.num(dt.millisecond);
            case "u":
            case "SSS":
              return this.num(dt.millisecond, 3);
            case "s":
              return this.num(dt.second);
            case "ss":
              return this.num(dt.second, 2);
            case "uu":
              return this.num(Math.floor(dt.millisecond / 10), 2);
            case "uuu":
              return this.num(Math.floor(dt.millisecond / 100));
            case "m":
              return this.num(dt.minute);
            case "mm":
              return this.num(dt.minute, 2);
            case "h":
              return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
            case "hh":
              return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
            case "H":
              return this.num(dt.hour);
            case "HH":
              return this.num(dt.hour, 2);
            case "Z":
              return formatOffset3({ format: "narrow", allowZ: this.opts.allowZ });
            case "ZZ":
              return formatOffset3({ format: "short", allowZ: this.opts.allowZ });
            case "ZZZ":
              return formatOffset3({ format: "techie", allowZ: this.opts.allowZ });
            case "ZZZZ":
              return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
            case "ZZZZZ":
              return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
            case "z":
              return dt.zoneName;
            case "a":
              return meridiem();
            case "d":
              return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
            case "dd":
              return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
            case "c":
              return this.num(dt.weekday);
            case "ccc":
              return weekday("short", true);
            case "cccc":
              return weekday("long", true);
            case "ccccc":
              return weekday("narrow", true);
            case "E":
              return this.num(dt.weekday);
            case "EEE":
              return weekday("short", false);
            case "EEEE":
              return weekday("long", false);
            case "EEEEE":
              return weekday("narrow", false);
            case "L":
              return useDateTimeFormatter ? string({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
            case "LL":
              return useDateTimeFormatter ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
            case "LLL":
              return month("short", true);
            case "LLLL":
              return month("long", true);
            case "LLLLL":
              return month("narrow", true);
            case "M":
              return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month);
            case "MM":
              return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2);
            case "MMM":
              return month("short", false);
            case "MMMM":
              return month("long", false);
            case "MMMMM":
              return month("narrow", false);
            case "y":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
            case "yy":
              return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
            case "yyyy":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4);
            case "yyyyyy":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6);
            case "G":
              return era("short");
            case "GG":
              return era("long");
            case "GGGGG":
              return era("narrow");
            case "kk":
              return this.num(dt.weekYear.toString().slice(-2), 2);
            case "kkkk":
              return this.num(dt.weekYear, 4);
            case "W":
              return this.num(dt.weekNumber);
            case "WW":
              return this.num(dt.weekNumber, 2);
            case "o":
              return this.num(dt.ordinal);
            case "ooo":
              return this.num(dt.ordinal, 3);
            case "q":
              return this.num(dt.quarter);
            case "qq":
              return this.num(dt.quarter, 2);
            case "X":
              return this.num(Math.floor(dt.ts / 1e3));
            case "x":
              return this.num(dt.ts);
            default:
              return maybeMacro(token);
          }
        };
        return stringifyTokens2(_Formatter.parseFormat(fmt), tokenToString);
      }
      formatDurationFromString(dur, fmt) {
        const tokenToField = (token) => {
          switch (token[0]) {
            case "S":
              return "millisecond";
            case "s":
              return "second";
            case "m":
              return "minute";
            case "h":
              return "hour";
            case "d":
              return "day";
            case "w":
              return "week";
            case "M":
              return "month";
            case "y":
              return "year";
            default:
              return null;
          }
        }, tokenToString = (lildur) => (token) => {
          const mapped = tokenToField(token);
          if (mapped) {
            return this.num(lildur.get(mapped), token.length);
          } else {
            return token;
          }
        }, tokens = _Formatter.parseFormat(fmt), realTokens = tokens.reduce(
          (found, { literal, val }) => literal ? found : found.concat(val),
          []
        ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t));
        return stringifyTokens2(tokens, tokenToString(collapsed));
      }
    };
    var Invalid2 = class {
      constructor(reason, explanation) {
        this.reason = reason;
        this.explanation = explanation;
      }
      toMessage() {
        if (this.explanation) {
          return `${this.reason}: ${this.explanation}`;
        } else {
          return this.reason;
        }
      }
    };
    var ianaRegex2 = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
    function combineRegexes2(...regexes) {
      const full = regexes.reduce((f, r) => f + r.source, "");
      return RegExp(`^${full}$`);
    }
    function combineExtractors2(...extractors) {
      return (m) => extractors.reduce(
        ([mergedVals, mergedZone, cursor], ex) => {
          const [val, zone, next] = ex(m, cursor);
          return [{ ...mergedVals, ...val }, zone || mergedZone, next];
        },
        [{}, null, 1]
      ).slice(0, 2);
    }
    function parse2(s3, ...patterns) {
      if (s3 == null) {
        return [null, null];
      }
      for (const [regex, extractor] of patterns) {
        const m = regex.exec(s3);
        if (m) {
          return extractor(m);
        }
      }
      return [null, null];
    }
    function simpleParse2(...keys) {
      return (match3, cursor) => {
        const ret = {};
        let i;
        for (i = 0; i < keys.length; i++) {
          ret[keys[i]] = parseInteger2(match3[cursor + i]);
        }
        return [ret, null, cursor + i];
      };
    }
    var offsetRegex2 = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
    var isoExtendedZone2 = `(?:${offsetRegex2.source}?(?:\\[(${ianaRegex2.source})\\])?)?`;
    var isoTimeBaseRegex2 = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
    var isoTimeRegex2 = RegExp(`${isoTimeBaseRegex2.source}${isoExtendedZone2}`);
    var isoTimeExtensionRegex2 = RegExp(`(?:T${isoTimeRegex2.source})?`);
    var isoYmdRegex2 = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
    var isoWeekRegex2 = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
    var isoOrdinalRegex2 = /(\d{4})-?(\d{3})/;
    var extractISOWeekData2 = simpleParse2("weekYear", "weekNumber", "weekDay");
    var extractISOOrdinalData2 = simpleParse2("year", "ordinal");
    var sqlYmdRegex2 = /(\d{4})-(\d\d)-(\d\d)/;
    var sqlTimeRegex2 = RegExp(
      `${isoTimeBaseRegex2.source} ?(?:${offsetRegex2.source}|(${ianaRegex2.source}))?`
    );
    var sqlTimeExtensionRegex2 = RegExp(`(?: ${sqlTimeRegex2.source})?`);
    function int2(match3, pos, fallback) {
      const m = match3[pos];
      return isUndefined2(m) ? fallback : parseInteger2(m);
    }
    function extractISOYmd2(match3, cursor) {
      const item = {
        year: int2(match3, cursor),
        month: int2(match3, cursor + 1, 1),
        day: int2(match3, cursor + 2, 1)
      };
      return [item, null, cursor + 3];
    }
    function extractISOTime2(match3, cursor) {
      const item = {
        hours: int2(match3, cursor, 0),
        minutes: int2(match3, cursor + 1, 0),
        seconds: int2(match3, cursor + 2, 0),
        milliseconds: parseMillis2(match3[cursor + 3])
      };
      return [item, null, cursor + 4];
    }
    function extractISOOffset2(match3, cursor) {
      const local = !match3[cursor] && !match3[cursor + 1], fullOffset = signedOffset2(match3[cursor + 1], match3[cursor + 2]), zone = local ? null : FixedOffsetZone2.instance(fullOffset);
      return [{}, zone, cursor + 3];
    }
    function extractIANAZone2(match3, cursor) {
      const zone = match3[cursor] ? IANAZone2.create(match3[cursor]) : null;
      return [{}, zone, cursor + 1];
    }
    var isoTimeOnly2 = RegExp(`^T?${isoTimeBaseRegex2.source}$`);
    var isoDuration2 = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
    function extractISODuration2(match3) {
      const [s3, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match3;
      const hasNegativePrefix = s3[0] === "-";
      const negativeSeconds = secondStr && secondStr[0] === "-";
      const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
      return [
        {
          years: maybeNegate(parseFloating2(yearStr)),
          months: maybeNegate(parseFloating2(monthStr)),
          weeks: maybeNegate(parseFloating2(weekStr)),
          days: maybeNegate(parseFloating2(dayStr)),
          hours: maybeNegate(parseFloating2(hourStr)),
          minutes: maybeNegate(parseFloating2(minuteStr)),
          seconds: maybeNegate(parseFloating2(secondStr), secondStr === "-0"),
          milliseconds: maybeNegate(parseMillis2(millisecondsStr), negativeSeconds)
        }
      ];
    }
    var obsOffsets2 = {
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function fromStrings2(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      const result = {
        year: yearStr.length === 2 ? untruncateYear2(parseInteger2(yearStr)) : parseInteger2(yearStr),
        month: monthsShort2.indexOf(monthStr) + 1,
        day: parseInteger2(dayStr),
        hour: parseInteger2(hourStr),
        minute: parseInteger2(minuteStr)
      };
      if (secondStr)
        result.second = parseInteger2(secondStr);
      if (weekdayStr) {
        result.weekday = weekdayStr.length > 3 ? weekdaysLong2.indexOf(weekdayStr) + 1 : weekdaysShort2.indexOf(weekdayStr) + 1;
      }
      return result;
    }
    var rfc28222 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
    function extractRFC28222(match3) {
      const [
        ,
        weekdayStr,
        dayStr,
        monthStr,
        yearStr,
        hourStr,
        minuteStr,
        secondStr,
        obsOffset,
        milOffset,
        offHourStr,
        offMinuteStr
      ] = match3, result = fromStrings2(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      let offset3;
      if (obsOffset) {
        offset3 = obsOffsets2[obsOffset];
      } else if (milOffset) {
        offset3 = 0;
      } else {
        offset3 = signedOffset2(offHourStr, offMinuteStr);
      }
      return [result, new FixedOffsetZone2(offset3)];
    }
    function preprocessRFC28222(s3) {
      return s3.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
    }
    var rfc11232 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
    var rfc8502 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
    var ascii2 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
    function extractRFC1123Or8502(match3) {
      const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match3, result = fromStrings2(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone2.utcInstance];
    }
    function extractASCII2(match3) {
      const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match3, result = fromStrings2(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone2.utcInstance];
    }
    var isoYmdWithTimeExtensionRegex2 = combineRegexes2(isoYmdRegex2, isoTimeExtensionRegex2);
    var isoWeekWithTimeExtensionRegex2 = combineRegexes2(isoWeekRegex2, isoTimeExtensionRegex2);
    var isoOrdinalWithTimeExtensionRegex2 = combineRegexes2(isoOrdinalRegex2, isoTimeExtensionRegex2);
    var isoTimeCombinedRegex2 = combineRegexes2(isoTimeRegex2);
    var extractISOYmdTimeAndOffset2 = combineExtractors2(
      extractISOYmd2,
      extractISOTime2,
      extractISOOffset2,
      extractIANAZone2
    );
    var extractISOWeekTimeAndOffset2 = combineExtractors2(
      extractISOWeekData2,
      extractISOTime2,
      extractISOOffset2,
      extractIANAZone2
    );
    var extractISOOrdinalDateAndTime2 = combineExtractors2(
      extractISOOrdinalData2,
      extractISOTime2,
      extractISOOffset2,
      extractIANAZone2
    );
    var extractISOTimeAndOffset2 = combineExtractors2(
      extractISOTime2,
      extractISOOffset2,
      extractIANAZone2
    );
    function parseISODate2(s3) {
      return parse2(
        s3,
        [isoYmdWithTimeExtensionRegex2, extractISOYmdTimeAndOffset2],
        [isoWeekWithTimeExtensionRegex2, extractISOWeekTimeAndOffset2],
        [isoOrdinalWithTimeExtensionRegex2, extractISOOrdinalDateAndTime2],
        [isoTimeCombinedRegex2, extractISOTimeAndOffset2]
      );
    }
    function parseRFC2822Date2(s3) {
      return parse2(preprocessRFC28222(s3), [rfc28222, extractRFC28222]);
    }
    function parseHTTPDate2(s3) {
      return parse2(
        s3,
        [rfc11232, extractRFC1123Or8502],
        [rfc8502, extractRFC1123Or8502],
        [ascii2, extractASCII2]
      );
    }
    function parseISODuration2(s3) {
      return parse2(s3, [isoDuration2, extractISODuration2]);
    }
    var extractISOTimeOnly2 = combineExtractors2(extractISOTime2);
    function parseISOTimeOnly2(s3) {
      return parse2(s3, [isoTimeOnly2, extractISOTimeOnly2]);
    }
    var sqlYmdWithTimeExtensionRegex2 = combineRegexes2(sqlYmdRegex2, sqlTimeExtensionRegex2);
    var sqlTimeCombinedRegex2 = combineRegexes2(sqlTimeRegex2);
    var extractISOTimeOffsetAndIANAZone2 = combineExtractors2(
      extractISOTime2,
      extractISOOffset2,
      extractIANAZone2
    );
    function parseSQL2(s3) {
      return parse2(
        s3,
        [sqlYmdWithTimeExtensionRegex2, extractISOYmdTimeAndOffset2],
        [sqlTimeCombinedRegex2, extractISOTimeOffsetAndIANAZone2]
      );
    }
    var INVALID$2 = "Invalid Duration";
    var lowOrderMatrix2 = {
      weeks: {
        days: 7,
        hours: 7 * 24,
        minutes: 7 * 24 * 60,
        seconds: 7 * 24 * 60 * 60,
        milliseconds: 7 * 24 * 60 * 60 * 1e3
      },
      days: {
        hours: 24,
        minutes: 24 * 60,
        seconds: 24 * 60 * 60,
        milliseconds: 24 * 60 * 60 * 1e3
      },
      hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
      minutes: { seconds: 60, milliseconds: 60 * 1e3 },
      seconds: { milliseconds: 1e3 }
    };
    var casualMatrix2 = {
      years: {
        quarters: 4,
        months: 12,
        weeks: 52,
        days: 365,
        hours: 365 * 24,
        minutes: 365 * 24 * 60,
        seconds: 365 * 24 * 60 * 60,
        milliseconds: 365 * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: 13,
        days: 91,
        hours: 91 * 24,
        minutes: 91 * 24 * 60,
        seconds: 91 * 24 * 60 * 60,
        milliseconds: 91 * 24 * 60 * 60 * 1e3
      },
      months: {
        weeks: 4,
        days: 30,
        hours: 30 * 24,
        minutes: 30 * 24 * 60,
        seconds: 30 * 24 * 60 * 60,
        milliseconds: 30 * 24 * 60 * 60 * 1e3
      },
      ...lowOrderMatrix2
    };
    var daysInYearAccurate2 = 146097 / 400;
    var daysInMonthAccurate2 = 146097 / 4800;
    var accurateMatrix2 = {
      years: {
        quarters: 4,
        months: 12,
        weeks: daysInYearAccurate2 / 7,
        days: daysInYearAccurate2,
        hours: daysInYearAccurate2 * 24,
        minutes: daysInYearAccurate2 * 24 * 60,
        seconds: daysInYearAccurate2 * 24 * 60 * 60,
        milliseconds: daysInYearAccurate2 * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: daysInYearAccurate2 / 28,
        days: daysInYearAccurate2 / 4,
        hours: daysInYearAccurate2 * 24 / 4,
        minutes: daysInYearAccurate2 * 24 * 60 / 4,
        seconds: daysInYearAccurate2 * 24 * 60 * 60 / 4,
        milliseconds: daysInYearAccurate2 * 24 * 60 * 60 * 1e3 / 4
      },
      months: {
        weeks: daysInMonthAccurate2 / 7,
        days: daysInMonthAccurate2,
        hours: daysInMonthAccurate2 * 24,
        minutes: daysInMonthAccurate2 * 24 * 60,
        seconds: daysInMonthAccurate2 * 24 * 60 * 60,
        milliseconds: daysInMonthAccurate2 * 24 * 60 * 60 * 1e3
      },
      ...lowOrderMatrix2
    };
    var orderedUnits$1 = [
      "years",
      "quarters",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    ];
    var reverseUnits2 = orderedUnits$1.slice(0).reverse();
    function clone$1(dur, alts, clear = false) {
      const conf = {
        values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
        loc: dur.loc.clone(alts.loc),
        conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
        matrix: alts.matrix || dur.matrix
      };
      return new Duration2(conf);
    }
    function durationToMillis2(matrix, vals) {
      var _a;
      let sum = (_a = vals.milliseconds) != null ? _a : 0;
      for (const unit of reverseUnits2.slice(1)) {
        if (vals[unit]) {
          sum += vals[unit] * matrix[unit]["milliseconds"];
        }
      }
      return sum;
    }
    function normalizeValues2(matrix, vals) {
      const factor = durationToMillis2(matrix, vals) < 0 ? -1 : 1;
      orderedUnits$1.reduceRight((previous, current) => {
        if (!isUndefined2(vals[current])) {
          if (previous) {
            const previousVal = vals[previous] * factor;
            const conv = matrix[current][previous];
            const rollUp = Math.floor(previousVal / conv);
            vals[current] += rollUp * factor;
            vals[previous] -= rollUp * conv * factor;
          }
          return current;
        } else {
          return previous;
        }
      }, null);
      orderedUnits$1.reduce((previous, current) => {
        if (!isUndefined2(vals[current])) {
          if (previous) {
            const fraction = vals[previous] % 1;
            vals[previous] -= fraction;
            vals[current] += fraction * matrix[previous][current];
          }
          return current;
        } else {
          return previous;
        }
      }, null);
    }
    function removeZeroes2(vals) {
      const newVals = {};
      for (const [key, value] of Object.entries(vals)) {
        if (value !== 0) {
          newVals[key] = value;
        }
      }
      return newVals;
    }
    var Duration2 = class _Duration {
      /**
       * @private
       */
      constructor(config) {
        const accurate = config.conversionAccuracy === "longterm" || false;
        let matrix = accurate ? accurateMatrix2 : casualMatrix2;
        if (config.matrix) {
          matrix = config.matrix;
        }
        this.values = config.values;
        this.loc = config.loc || Locale2.create();
        this.conversionAccuracy = accurate ? "longterm" : "casual";
        this.invalid = config.invalid || null;
        this.matrix = matrix;
        this.isLuxonDuration = true;
      }
      /**
       * Create Duration from a number of milliseconds.
       * @param {number} count of milliseconds
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @return {Duration}
       */
      static fromMillis(count, opts) {
        return _Duration.fromObject({ milliseconds: count }, opts);
      }
      /**
       * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
       * If this object is empty then a zero milliseconds duration is returned.
       * @param {Object} obj - the object to create the DateTime from
       * @param {number} obj.years
       * @param {number} obj.quarters
       * @param {number} obj.months
       * @param {number} obj.weeks
       * @param {number} obj.days
       * @param {number} obj.hours
       * @param {number} obj.minutes
       * @param {number} obj.seconds
       * @param {number} obj.milliseconds
       * @param {Object} [opts=[]] - options for creating this Duration
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the custom conversion system to use
       * @return {Duration}
       */
      static fromObject(obj, opts = {}) {
        if (obj == null || typeof obj !== "object") {
          throw new InvalidArgumentError2(
            `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
          );
        }
        return new _Duration({
          values: normalizeObject2(obj, _Duration.normalizeUnit),
          loc: Locale2.fromObject(opts),
          conversionAccuracy: opts.conversionAccuracy,
          matrix: opts.matrix
        });
      }
      /**
       * Create a Duration from DurationLike.
       *
       * @param {Object | number | Duration} durationLike
       * One of:
       * - object with keys like 'years' and 'hours'.
       * - number representing milliseconds
       * - Duration instance
       * @return {Duration}
       */
      static fromDurationLike(durationLike) {
        if (isNumber2(durationLike)) {
          return _Duration.fromMillis(durationLike);
        } else if (_Duration.isDuration(durationLike)) {
          return durationLike;
        } else if (typeof durationLike === "object") {
          return _Duration.fromObject(durationLike);
        } else {
          throw new InvalidArgumentError2(
            `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
          );
        }
      }
      /**
       * Create a Duration from an ISO 8601 duration string.
       * @param {string} text - text to parse
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the preset conversion system to use
       * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
       * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
       * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
       * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
       * @return {Duration}
       */
      static fromISO(text2, opts) {
        const [parsed] = parseISODuration2(text2);
        if (parsed) {
          return _Duration.fromObject(parsed, opts);
        } else {
          return _Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
        }
      }
      /**
       * Create a Duration from an ISO 8601 time string.
       * @param {string} text - text to parse
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the conversion system to use
       * @see https://en.wikipedia.org/wiki/ISO_8601#Times
       * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
       * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @return {Duration}
       */
      static fromISOTime(text2, opts) {
        const [parsed] = parseISOTimeOnly2(text2);
        if (parsed) {
          return _Duration.fromObject(parsed, opts);
        } else {
          return _Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
        }
      }
      /**
       * Create an invalid Duration.
       * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {Duration}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError2("need to specify a reason the Duration is invalid");
        }
        const invalid = reason instanceof Invalid2 ? reason : new Invalid2(reason, explanation);
        if (Settings3.throwOnInvalid) {
          throw new InvalidDurationError2(invalid);
        } else {
          return new _Duration({ invalid });
        }
      }
      /**
       * @private
       */
      static normalizeUnit(unit) {
        const normalized = {
          year: "years",
          years: "years",
          quarter: "quarters",
          quarters: "quarters",
          month: "months",
          months: "months",
          week: "weeks",
          weeks: "weeks",
          day: "days",
          days: "days",
          hour: "hours",
          hours: "hours",
          minute: "minutes",
          minutes: "minutes",
          second: "seconds",
          seconds: "seconds",
          millisecond: "milliseconds",
          milliseconds: "milliseconds"
        }[unit ? unit.toLowerCase() : unit];
        if (!normalized)
          throw new InvalidUnitError2(unit);
        return normalized;
      }
      /**
       * Check if an object is a Duration. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isDuration(o) {
        return o && o.isLuxonDuration || false;
      }
      /**
       * Get  the locale of a Duration, such 'en-GB'
       * @type {string}
       */
      get locale() {
        return this.isValid ? this.loc.locale : null;
      }
      /**
       * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
       *
       * @type {string}
       */
      get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null;
      }
      /**
       * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
       * * `S` for milliseconds
       * * `s` for seconds
       * * `m` for minutes
       * * `h` for hours
       * * `d` for days
       * * `w` for weeks
       * * `M` for months
       * * `y` for years
       * Notes:
       * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
       * * Tokens can be escaped by wrapping with single quotes.
       * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
       * @param {string} fmt - the format string
       * @param {Object} opts - options
       * @param {boolean} [opts.floor=true] - floor numerical values
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
       * @return {string}
       */
      toFormat(fmt, opts = {}) {
        const fmtOpts = {
          ...opts,
          floor: opts.round !== false && opts.floor !== false
        };
        return this.isValid ? Formatter2.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
      }
      /**
       * Returns a string representation of a Duration with all units included.
       * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
       * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
       * @example
       * ```js
       * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
       * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
       * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
       * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
       * ```
       */
      toHuman(opts = {}) {
        if (!this.isValid)
          return INVALID$2;
        const l3 = orderedUnits$1.map((unit) => {
          const val = this.values[unit];
          if (isUndefined2(val)) {
            return null;
          }
          return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
        }).filter((n3) => n3);
        return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l3);
      }
      /**
       * Returns a JavaScript object with this Duration's values.
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
       * @return {Object}
       */
      toObject() {
        if (!this.isValid)
          return {};
        return { ...this.values };
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Duration.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
       * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
       * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
       * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
       * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
       * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
       * @return {string}
       */
      toISO() {
        if (!this.isValid)
          return null;
        let s3 = "P";
        if (this.years !== 0)
          s3 += this.years + "Y";
        if (this.months !== 0 || this.quarters !== 0)
          s3 += this.months + this.quarters * 3 + "M";
        if (this.weeks !== 0)
          s3 += this.weeks + "W";
        if (this.days !== 0)
          s3 += this.days + "D";
        if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
          s3 += "T";
        if (this.hours !== 0)
          s3 += this.hours + "H";
        if (this.minutes !== 0)
          s3 += this.minutes + "M";
        if (this.seconds !== 0 || this.milliseconds !== 0)
          s3 += roundTo2(this.seconds + this.milliseconds / 1e3, 3) + "S";
        if (s3 === "P")
          s3 += "T0S";
        return s3;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
       * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Times
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
       * @return {string}
       */
      toISOTime(opts = {}) {
        if (!this.isValid)
          return null;
        const millis = this.toMillis();
        if (millis < 0 || millis >= 864e5)
          return null;
        opts = {
          suppressMilliseconds: false,
          suppressSeconds: false,
          includePrefix: false,
          format: "extended",
          ...opts,
          includeOffset: false
        };
        const dateTime = DateTime2.fromMillis(millis, { zone: "UTC" });
        return dateTime.toISOTime(opts);
      }
      /**
       * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
       * @return {string}
       */
      toJSON() {
        return this.toISO();
      }
      /**
       * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
       * @return {string}
       */
      toString() {
        return this.toISO();
      }
      /**
       * Returns an milliseconds value of this Duration.
       * @return {number}
       */
      toMillis() {
        if (!this.isValid)
          return NaN;
        return durationToMillis2(this.matrix, this.values);
      }
      /**
       * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
       * @return {number}
       */
      valueOf() {
        return this.toMillis();
      }
      /**
       * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
       * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @return {Duration}
       */
      plus(duration) {
        if (!this.isValid)
          return this;
        const dur = _Duration.fromDurationLike(duration), result = {};
        for (const k of orderedUnits$1) {
          if (hasOwnProperty2(dur.values, k) || hasOwnProperty2(this.values, k)) {
            result[k] = dur.get(k) + this.get(k);
          }
        }
        return clone$1(this, { values: result }, true);
      }
      /**
       * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
       * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @return {Duration}
       */
      minus(duration) {
        if (!this.isValid)
          return this;
        const dur = _Duration.fromDurationLike(duration);
        return this.plus(dur.negate());
      }
      /**
       * Scale this Duration by the specified amount. Return a newly-constructed Duration.
       * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
       * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
       * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
       * @return {Duration}
       */
      mapUnits(fn) {
        if (!this.isValid)
          return this;
        const result = {};
        for (const k of Object.keys(this.values)) {
          result[k] = asNumber2(fn(this.values[k], k));
        }
        return clone$1(this, { values: result }, true);
      }
      /**
       * Get the value of unit.
       * @param {string} unit - a unit such as 'minute' or 'day'
       * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
       * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
       * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
       * @return {number}
       */
      get(unit) {
        return this[_Duration.normalizeUnit(unit)];
      }
      /**
       * "Set" the values of specified units. Return a newly-constructed Duration.
       * @param {Object} values - a mapping of units to numbers
       * @example dur.set({ years: 2017 })
       * @example dur.set({ hours: 8, minutes: 30 })
       * @return {Duration}
       */
      set(values) {
        if (!this.isValid)
          return this;
        const mixed = { ...this.values, ...normalizeObject2(values, _Duration.normalizeUnit) };
        return clone$1(this, { values: mixed });
      }
      /**
       * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
       * @example dur.reconfigure({ locale: 'en-GB' })
       * @return {Duration}
       */
      reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
        const loc = this.loc.clone({ locale, numberingSystem });
        const opts = { loc, matrix, conversionAccuracy };
        return clone$1(this, opts);
      }
      /**
       * Return the length of the duration in the specified unit.
       * @param {string} unit - a unit such as 'minutes' or 'days'
       * @example Duration.fromObject({years: 1}).as('days') //=> 365
       * @example Duration.fromObject({years: 1}).as('months') //=> 12
       * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
       * @return {number}
       */
      as(unit) {
        return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
      }
      /**
       * Reduce this Duration to its canonical representation in its current units.
       * Assuming the overall value of the Duration is positive, this means:
       * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
       * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
       *   the overall value would be negative, see second example)
       * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
       *
       * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
       * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
       * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
       * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
       * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
       * @return {Duration}
       */
      normalize() {
        if (!this.isValid)
          return this;
        const vals = this.toObject();
        normalizeValues2(this.matrix, vals);
        return clone$1(this, { values: vals }, true);
      }
      /**
       * Rescale units to its largest representation
       * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
       * @return {Duration}
       */
      rescale() {
        if (!this.isValid)
          return this;
        const vals = removeZeroes2(this.normalize().shiftToAll().toObject());
        return clone$1(this, { values: vals }, true);
      }
      /**
       * Convert this Duration into its representation in a different set of units.
       * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
       * @return {Duration}
       */
      shiftTo(...units) {
        if (!this.isValid)
          return this;
        if (units.length === 0) {
          return this;
        }
        units = units.map((u) => _Duration.normalizeUnit(u));
        const built = {}, accumulated = {}, vals = this.toObject();
        let lastUnit;
        for (const k of orderedUnits$1) {
          if (units.indexOf(k) >= 0) {
            lastUnit = k;
            let own = 0;
            for (const ak in accumulated) {
              own += this.matrix[ak][k] * accumulated[ak];
              accumulated[ak] = 0;
            }
            if (isNumber2(vals[k])) {
              own += vals[k];
            }
            const i = Math.trunc(own);
            built[k] = i;
            accumulated[k] = (own * 1e3 - i * 1e3) / 1e3;
          } else if (isNumber2(vals[k])) {
            accumulated[k] = vals[k];
          }
        }
        for (const key in accumulated) {
          if (accumulated[key] !== 0) {
            built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
          }
        }
        normalizeValues2(this.matrix, built);
        return clone$1(this, { values: built }, true);
      }
      /**
       * Shift this Duration to all available units.
       * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
       * @return {Duration}
       */
      shiftToAll() {
        if (!this.isValid)
          return this;
        return this.shiftTo(
          "years",
          "months",
          "weeks",
          "days",
          "hours",
          "minutes",
          "seconds",
          "milliseconds"
        );
      }
      /**
       * Return the negative of this Duration.
       * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
       * @return {Duration}
       */
      negate() {
        if (!this.isValid)
          return this;
        const negated = {};
        for (const k of Object.keys(this.values)) {
          negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
        }
        return clone$1(this, { values: negated }, true);
      }
      /**
       * Get the years.
       * @type {number}
       */
      get years() {
        return this.isValid ? this.values.years || 0 : NaN;
      }
      /**
       * Get the quarters.
       * @type {number}
       */
      get quarters() {
        return this.isValid ? this.values.quarters || 0 : NaN;
      }
      /**
       * Get the months.
       * @type {number}
       */
      get months() {
        return this.isValid ? this.values.months || 0 : NaN;
      }
      /**
       * Get the weeks
       * @type {number}
       */
      get weeks() {
        return this.isValid ? this.values.weeks || 0 : NaN;
      }
      /**
       * Get the days.
       * @type {number}
       */
      get days() {
        return this.isValid ? this.values.days || 0 : NaN;
      }
      /**
       * Get the hours.
       * @type {number}
       */
      get hours() {
        return this.isValid ? this.values.hours || 0 : NaN;
      }
      /**
       * Get the minutes.
       * @type {number}
       */
      get minutes() {
        return this.isValid ? this.values.minutes || 0 : NaN;
      }
      /**
       * Get the seconds.
       * @return {number}
       */
      get seconds() {
        return this.isValid ? this.values.seconds || 0 : NaN;
      }
      /**
       * Get the milliseconds.
       * @return {number}
       */
      get milliseconds() {
        return this.isValid ? this.values.milliseconds || 0 : NaN;
      }
      /**
       * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
       * on invalid DateTimes or Intervals.
       * @return {boolean}
       */
      get isValid() {
        return this.invalid === null;
      }
      /**
       * Returns an error code if this Duration became invalid, or null if the Duration is valid
       * @return {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Equality check
       * Two Durations are equal iff they have the same units and the same values for each unit.
       * @param {Duration} other
       * @return {boolean}
       */
      equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        if (!this.loc.equals(other.loc)) {
          return false;
        }
        function eq(v1, v2) {
          if (v1 === void 0 || v1 === 0)
            return v2 === void 0 || v2 === 0;
          return v1 === v2;
        }
        for (const u of orderedUnits$1) {
          if (!eq(this.values[u], other.values[u])) {
            return false;
          }
        }
        return true;
      }
    };
    var INVALID$1 = "Invalid Interval";
    function validateStartEnd2(start, end) {
      if (!start || !start.isValid) {
        return Interval2.invalid("missing or invalid start");
      } else if (!end || !end.isValid) {
        return Interval2.invalid("missing or invalid end");
      } else if (end < start) {
        return Interval2.invalid(
          "end before start",
          `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
        );
      } else {
        return null;
      }
    }
    var Interval2 = class _Interval {
      /**
       * @private
       */
      constructor(config) {
        this.s = config.start;
        this.e = config.end;
        this.invalid = config.invalid || null;
        this.isLuxonInterval = true;
      }
      /**
       * Create an invalid Interval.
       * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {Interval}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError2("need to specify a reason the Interval is invalid");
        }
        const invalid = reason instanceof Invalid2 ? reason : new Invalid2(reason, explanation);
        if (Settings3.throwOnInvalid) {
          throw new InvalidIntervalError2(invalid);
        } else {
          return new _Interval({ invalid });
        }
      }
      /**
       * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
       * @param {DateTime|Date|Object} start
       * @param {DateTime|Date|Object} end
       * @return {Interval}
       */
      static fromDateTimes(start, end) {
        const builtStart = friendlyDateTime2(start), builtEnd = friendlyDateTime2(end);
        const validateError = validateStartEnd2(builtStart, builtEnd);
        if (validateError == null) {
          return new _Interval({
            start: builtStart,
            end: builtEnd
          });
        } else {
          return validateError;
        }
      }
      /**
       * Create an Interval from a start DateTime and a Duration to extend to.
       * @param {DateTime|Date|Object} start
       * @param {Duration|Object|number} duration - the length of the Interval.
       * @return {Interval}
       */
      static after(start, duration) {
        const dur = Duration2.fromDurationLike(duration), dt = friendlyDateTime2(start);
        return _Interval.fromDateTimes(dt, dt.plus(dur));
      }
      /**
       * Create an Interval from an end DateTime and a Duration to extend backwards to.
       * @param {DateTime|Date|Object} end
       * @param {Duration|Object|number} duration - the length of the Interval.
       * @return {Interval}
       */
      static before(end, duration) {
        const dur = Duration2.fromDurationLike(duration), dt = friendlyDateTime2(end);
        return _Interval.fromDateTimes(dt.minus(dur), dt);
      }
      /**
       * Create an Interval from an ISO 8601 string.
       * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
       * @param {string} text - the ISO string to parse
       * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @return {Interval}
       */
      static fromISO(text2, opts) {
        const [s3, e] = (text2 || "").split("/", 2);
        if (s3 && e) {
          let start, startIsValid;
          try {
            start = DateTime2.fromISO(s3, opts);
            startIsValid = start.isValid;
          } catch (e2) {
            startIsValid = false;
          }
          let end, endIsValid;
          try {
            end = DateTime2.fromISO(e, opts);
            endIsValid = end.isValid;
          } catch (e2) {
            endIsValid = false;
          }
          if (startIsValid && endIsValid) {
            return _Interval.fromDateTimes(start, end);
          }
          if (startIsValid) {
            const dur = Duration2.fromISO(e, opts);
            if (dur.isValid) {
              return _Interval.after(start, dur);
            }
          } else if (endIsValid) {
            const dur = Duration2.fromISO(s3, opts);
            if (dur.isValid) {
              return _Interval.before(end, dur);
            }
          }
        }
        return _Interval.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
      }
      /**
       * Check if an object is an Interval. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isInterval(o) {
        return o && o.isLuxonInterval || false;
      }
      /**
       * Returns the start of the Interval
       * @type {DateTime}
       */
      get start() {
        return this.isValid ? this.s : null;
      }
      /**
       * Returns the end of the Interval
       * @type {DateTime}
       */
      get end() {
        return this.isValid ? this.e : null;
      }
      /**
       * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
       * @type {boolean}
       */
      get isValid() {
        return this.invalidReason === null;
      }
      /**
       * Returns an error code if this Interval is invalid, or null if the Interval is valid
       * @type {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Returns the length of the Interval in the specified unit.
       * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
       * @return {number}
       */
      length(unit = "milliseconds") {
        return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
      }
      /**
       * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
       * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
       * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
       * @param {string} [unit='milliseconds'] - the unit of time to count.
       * @return {number}
       */
      count(unit = "milliseconds") {
        if (!this.isValid)
          return NaN;
        const start = this.start.startOf(unit), end = this.end.startOf(unit);
        return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
      }
      /**
       * Returns whether this Interval's start and end are both in the same unit of time
       * @param {string} unit - the unit of time to check sameness on
       * @return {boolean}
       */
      hasSame(unit) {
        return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
      }
      /**
       * Return whether this Interval has the same start and end DateTimes.
       * @return {boolean}
       */
      isEmpty() {
        return this.s.valueOf() === this.e.valueOf();
      }
      /**
       * Return whether this Interval's start is after the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      isAfter(dateTime) {
        if (!this.isValid)
          return false;
        return this.s > dateTime;
      }
      /**
       * Return whether this Interval's end is before the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      isBefore(dateTime) {
        if (!this.isValid)
          return false;
        return this.e <= dateTime;
      }
      /**
       * Return whether this Interval contains the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      contains(dateTime) {
        if (!this.isValid)
          return false;
        return this.s <= dateTime && this.e > dateTime;
      }
      /**
       * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
       * @param {Object} values - the values to set
       * @param {DateTime} values.start - the starting DateTime
       * @param {DateTime} values.end - the ending DateTime
       * @return {Interval}
       */
      set({ start, end } = {}) {
        if (!this.isValid)
          return this;
        return _Interval.fromDateTimes(start || this.s, end || this.e);
      }
      /**
       * Split this Interval at each of the specified DateTimes
       * @param {...DateTime} dateTimes - the unit of time to count.
       * @return {Array}
       */
      splitAt(...dateTimes) {
        if (!this.isValid)
          return [];
        const sorted = dateTimes.map(friendlyDateTime2).filter((d) => this.contains(d)).sort(), results = [];
        let { s: s3 } = this, i = 0;
        while (s3 < this.e) {
          const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
          results.push(_Interval.fromDateTimes(s3, next));
          s3 = next;
          i += 1;
        }
        return results;
      }
      /**
       * Split this Interval into smaller Intervals, each of the specified length.
       * Left over time is grouped into a smaller interval
       * @param {Duration|Object|number} duration - The length of each resulting interval.
       * @return {Array}
       */
      splitBy(duration) {
        const dur = Duration2.fromDurationLike(duration);
        if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
          return [];
        }
        let { s: s3 } = this, idx = 1, next;
        const results = [];
        while (s3 < this.e) {
          const added = this.start.plus(dur.mapUnits((x) => x * idx));
          next = +added > +this.e ? this.e : added;
          results.push(_Interval.fromDateTimes(s3, next));
          s3 = next;
          idx += 1;
        }
        return results;
      }
      /**
       * Split this Interval into the specified number of smaller intervals.
       * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
       * @return {Array}
       */
      divideEqually(numberOfParts) {
        if (!this.isValid)
          return [];
        return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
      }
      /**
       * Return whether this Interval overlaps with the specified Interval
       * @param {Interval} other
       * @return {boolean}
       */
      overlaps(other) {
        return this.e > other.s && this.s < other.e;
      }
      /**
       * Return whether this Interval's end is adjacent to the specified Interval's start.
       * @param {Interval} other
       * @return {boolean}
       */
      abutsStart(other) {
        if (!this.isValid)
          return false;
        return +this.e === +other.s;
      }
      /**
       * Return whether this Interval's start is adjacent to the specified Interval's end.
       * @param {Interval} other
       * @return {boolean}
       */
      abutsEnd(other) {
        if (!this.isValid)
          return false;
        return +other.e === +this.s;
      }
      /**
       * Return whether this Interval engulfs the start and end of the specified Interval.
       * @param {Interval} other
       * @return {boolean}
       */
      engulfs(other) {
        if (!this.isValid)
          return false;
        return this.s <= other.s && this.e >= other.e;
      }
      /**
       * Return whether this Interval has the same start and end as the specified Interval.
       * @param {Interval} other
       * @return {boolean}
       */
      equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        return this.s.equals(other.s) && this.e.equals(other.e);
      }
      /**
       * Return an Interval representing the intersection of this Interval and the specified Interval.
       * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
       * Returns null if the intersection is empty, meaning, the intervals don't intersect.
       * @param {Interval} other
       * @return {Interval}
       */
      intersection(other) {
        if (!this.isValid)
          return this;
        const s3 = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;
        if (s3 >= e) {
          return null;
        } else {
          return _Interval.fromDateTimes(s3, e);
        }
      }
      /**
       * Return an Interval representing the union of this Interval and the specified Interval.
       * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
       * @param {Interval} other
       * @return {Interval}
       */
      union(other) {
        if (!this.isValid)
          return this;
        const s3 = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;
        return _Interval.fromDateTimes(s3, e);
      }
      /**
       * Merge an array of Intervals into a equivalent minimal set of Intervals.
       * Combines overlapping and adjacent Intervals.
       * @param {Array} intervals
       * @return {Array}
       */
      static merge(intervals) {
        const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(
          ([sofar, current], item) => {
            if (!current) {
              return [sofar, item];
            } else if (current.overlaps(item) || current.abutsStart(item)) {
              return [sofar, current.union(item)];
            } else {
              return [sofar.concat([current]), item];
            }
          },
          [[], null]
        );
        if (final) {
          found.push(final);
        }
        return found;
      }
      /**
       * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
       * @param {Array} intervals
       * @return {Array}
       */
      static xor(intervals) {
        let start = null, currentCount = 0;
        const results = [], ends = intervals.map((i) => [
          { time: i.s, type: "s" },
          { time: i.e, type: "e" }
        ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a, b) => a.time - b.time);
        for (const i of arr) {
          currentCount += i.type === "s" ? 1 : -1;
          if (currentCount === 1) {
            start = i.time;
          } else {
            if (start && +start !== +i.time) {
              results.push(_Interval.fromDateTimes(start, i.time));
            }
            start = null;
          }
        }
        return _Interval.merge(results);
      }
      /**
       * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
       * @param {...Interval} intervals
       * @return {Array}
       */
      difference(...intervals) {
        return _Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
      }
      /**
       * Returns a string representation of this Interval appropriate for debugging.
       * @return {string}
       */
      toString() {
        if (!this.isValid)
          return INVALID$1;
        return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
      }
      /**
       * Returns a localized string representing this Interval. Accepts the same options as the
       * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
       * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
       * is browser-specific, but in general it will return an appropriate representation of the
       * Interval in the assigned locale. Defaults to the system's locale if no locale has been
       * specified.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
       * Intl.DateTimeFormat constructor options.
       * @param {Object} opts - Options to override the configuration of the start DateTime.
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022  11/8/2022
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7  8, 2022
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 78 novembre 2022
       * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00  8:00 PM
       * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00  8:00 p
       * @return {string}
       */
      toLocaleString(formatOpts = DATE_SHORT2, opts = {}) {
        return this.isValid ? Formatter2.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID$1;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Interval.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @param {Object} opts - The same options as {@link DateTime#toISO}
       * @return {string}
       */
      toISO(opts) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
      }
      /**
       * Returns an ISO 8601-compliant string representation of date of this Interval.
       * The time components are ignored.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @return {string}
       */
      toISODate() {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISODate()}/${this.e.toISODate()}`;
      }
      /**
       * Returns an ISO 8601-compliant string representation of time of this Interval.
       * The date components are ignored.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @param {Object} opts - The same options as {@link DateTime#toISO}
       * @return {string}
       */
      toISOTime(opts) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
      }
      /**
       * Returns a string representation of this Interval formatted according to the specified format
       * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
       * formatting tool.
       * @param {string} dateFormat - The format string. This string formats the start and end time.
       * See {@link DateTime#toFormat} for details.
       * @param {Object} opts - Options.
       * @param {string} [opts.separator =  '  '] - A separator to place between the start and end
       * representations.
       * @return {string}
       */
      toFormat(dateFormat, { separator = " \u2013 " } = {}) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
      }
      /**
       * Return a Duration representing the time spanned by this interval.
       * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
       * @return {Duration}
       */
      toDuration(unit, opts) {
        if (!this.isValid) {
          return Duration2.invalid(this.invalidReason);
        }
        return this.e.diff(this.s, unit, opts);
      }
      /**
       * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
       * @param {function} mapFn
       * @return {Interval}
       * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
       * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
       */
      mapEndpoints(mapFn) {
        return _Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
      }
    };
    var Info2 = class {
      /**
       * Return whether the specified zone contains a DST.
       * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
       * @return {boolean}
       */
      static hasDST(zone = Settings3.defaultZone) {
        const proto = DateTime2.now().setZone(zone).set({ month: 12 });
        return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
      }
      /**
       * Return whether the specified zone is a valid IANA specifier.
       * @param {string} zone - Zone to check
       * @return {boolean}
       */
      static isValidIANAZone(zone) {
        return IANAZone2.isValidZone(zone);
      }
      /**
       * Converts the input into a {@link Zone} instance.
       *
       * * If `input` is already a Zone instance, it is returned unchanged.
       * * If `input` is a string containing a valid time zone name, a Zone instance
       *   with that name is returned.
       * * If `input` is a string that doesn't refer to a known time zone, a Zone
       *   instance with {@link Zone#isValid} == false is returned.
       * * If `input is a number, a Zone instance with the specified fixed offset
       *   in minutes is returned.
       * * If `input` is `null` or `undefined`, the default zone is returned.
       * @param {string|Zone|number} [input] - the value to be converted
       * @return {Zone}
       */
      static normalizeZone(input) {
        return normalizeZone2(input, Settings3.defaultZone);
      }
      /**
       * Return an array of standalone month names.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @param {string} [opts.outputCalendar='gregory'] - the calendar
       * @example Info.months()[0] //=> 'January'
       * @example Info.months('short')[0] //=> 'Jan'
       * @example Info.months('numeric')[0] //=> '1'
       * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
       * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''
       * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'
       * @return {Array}
       */
      static months(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
        return (locObj || Locale2.create(locale, numberingSystem, outputCalendar)).months(length);
      }
      /**
       * Return an array of format month names.
       * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
       * changes the string.
       * See {@link Info#months}
       * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @param {string} [opts.outputCalendar='gregory'] - the calendar
       * @return {Array}
       */
      static monthsFormat(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
        return (locObj || Locale2.create(locale, numberingSystem, outputCalendar)).months(length, true);
      }
      /**
       * Return an array of standalone week names.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @example Info.weekdays()[0] //=> 'Monday'
       * @example Info.weekdays('short')[0] //=> 'Mon'
       * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
       * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''
       * @return {Array}
       */
      static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
        return (locObj || Locale2.create(locale, numberingSystem, null)).weekdays(length);
      }
      /**
       * Return an array of format week names.
       * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
       * changes the string.
       * See {@link Info#weekdays}
       * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale=null] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @return {Array}
       */
      static weekdaysFormat(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
        return (locObj || Locale2.create(locale, numberingSystem, null)).weekdays(length, true);
      }
      /**
       * Return an array of meridiems.
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @example Info.meridiems() //=> [ 'AM', 'PM' ]
       * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]
       * @return {Array}
       */
      static meridiems({ locale = null } = {}) {
        return Locale2.create(locale).meridiems();
      }
      /**
       * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
       * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @example Info.eras() //=> [ 'BC', 'AD' ]
       * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
       * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]
       * @return {Array}
       */
      static eras(length = "short", { locale = null } = {}) {
        return Locale2.create(locale, null, "gregory").eras(length);
      }
      /**
       * Return the set of available features in this environment.
       * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
       * Keys:
       * * `relative`: whether this environment supports relative time formatting
       * @example Info.features() //=> { relative: false }
       * @return {Object}
       */
      static features() {
        return { relative: hasRelative2() };
      }
    };
    function dayDiff2(earlier, later) {
      const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
      return Math.floor(Duration2.fromMillis(ms).as("days"));
    }
    function highOrderDiffs2(cursor, later, units) {
      const differs = [
        ["years", (a, b) => b.year - a.year],
        ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],
        ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12],
        [
          "weeks",
          (a, b) => {
            const days = dayDiff2(a, b);
            return (days - days % 7) / 7;
          }
        ],
        ["days", dayDiff2]
      ];
      const results = {};
      const earlier = cursor;
      let lowestOrder, highWater;
      for (const [unit, differ] of differs) {
        if (units.indexOf(unit) >= 0) {
          lowestOrder = unit;
          results[unit] = differ(cursor, later);
          highWater = earlier.plus(results);
          if (highWater > later) {
            results[unit]--;
            cursor = earlier.plus(results);
            if (cursor > later) {
              highWater = cursor;
              results[unit]--;
              cursor = earlier.plus(results);
            }
          } else {
            cursor = highWater;
          }
        }
      }
      return [cursor, results, highWater, lowestOrder];
    }
    function diff(earlier, later, units, opts) {
      let [cursor, results, highWater, lowestOrder] = highOrderDiffs2(earlier, later, units);
      const remainingMillis = later - cursor;
      const lowerOrderUnits = units.filter(
        (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
      );
      if (lowerOrderUnits.length === 0) {
        if (highWater < later) {
          highWater = cursor.plus({ [lowestOrder]: 1 });
        }
        if (highWater !== cursor) {
          results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
        }
      }
      const duration = Duration2.fromObject(results, opts);
      if (lowerOrderUnits.length > 0) {
        return Duration2.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
      } else {
        return duration;
      }
    }
    var numberingSystems2 = {
      arab: "[\u0660-\u0669]",
      arabext: "[\u06F0-\u06F9]",
      bali: "[\u1B50-\u1B59]",
      beng: "[\u09E6-\u09EF]",
      deva: "[\u0966-\u096F]",
      fullwide: "[\uFF10-\uFF19]",
      gujr: "[\u0AE6-\u0AEF]",
      hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
      khmr: "[\u17E0-\u17E9]",
      knda: "[\u0CE6-\u0CEF]",
      laoo: "[\u0ED0-\u0ED9]",
      limb: "[\u1946-\u194F]",
      mlym: "[\u0D66-\u0D6F]",
      mong: "[\u1810-\u1819]",
      mymr: "[\u1040-\u1049]",
      orya: "[\u0B66-\u0B6F]",
      tamldec: "[\u0BE6-\u0BEF]",
      telu: "[\u0C66-\u0C6F]",
      thai: "[\u0E50-\u0E59]",
      tibt: "[\u0F20-\u0F29]",
      latn: "\\d"
    };
    var numberingSystemsUTF162 = {
      arab: [1632, 1641],
      arabext: [1776, 1785],
      bali: [6992, 7001],
      beng: [2534, 2543],
      deva: [2406, 2415],
      fullwide: [65296, 65303],
      gujr: [2790, 2799],
      khmr: [6112, 6121],
      knda: [3302, 3311],
      laoo: [3792, 3801],
      limb: [6470, 6479],
      mlym: [3430, 3439],
      mong: [6160, 6169],
      mymr: [4160, 4169],
      orya: [2918, 2927],
      tamldec: [3046, 3055],
      telu: [3174, 3183],
      thai: [3664, 3673],
      tibt: [3872, 3881]
    };
    var hanidecChars2 = numberingSystems2.hanidec.replace(/[\[|\]]/g, "").split("");
    function parseDigits2(str) {
      let value = parseInt(str, 10);
      if (isNaN(value)) {
        value = "";
        for (let i = 0; i < str.length; i++) {
          const code = str.charCodeAt(i);
          if (str[i].search(numberingSystems2.hanidec) !== -1) {
            value += hanidecChars2.indexOf(str[i]);
          } else {
            for (const key in numberingSystemsUTF162) {
              const [min, max] = numberingSystemsUTF162[key];
              if (code >= min && code <= max) {
                value += code - min;
              }
            }
          }
        }
        return parseInt(value, 10);
      } else {
        return value;
      }
    }
    function digitRegex2({ numberingSystem }, append2 = "") {
      return new RegExp(`${numberingSystems2[numberingSystem || "latn"]}${append2}`);
    }
    var MISSING_FTP2 = "missing Intl.DateTimeFormat.formatToParts support";
    function intUnit2(regex, post = (i) => i) {
      return { regex, deser: ([s3]) => post(parseDigits2(s3)) };
    }
    var NBSP2 = String.fromCharCode(160);
    var spaceOrNBSP2 = `[ ${NBSP2}]`;
    var spaceOrNBSPRegExp2 = new RegExp(spaceOrNBSP2, "g");
    function fixListRegex2(s3) {
      return s3.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp2, spaceOrNBSP2);
    }
    function stripInsensitivities2(s3) {
      return s3.replace(/\./g, "").replace(spaceOrNBSPRegExp2, " ").toLowerCase();
    }
    function oneOf2(strings, startIndex) {
      if (strings === null) {
        return null;
      } else {
        return {
          regex: RegExp(strings.map(fixListRegex2).join("|")),
          deser: ([s3]) => strings.findIndex((i) => stripInsensitivities2(s3) === stripInsensitivities2(i)) + startIndex
        };
      }
    }
    function offset2(regex, groups) {
      return { regex, deser: ([, h, m]) => signedOffset2(h, m), groups };
    }
    function simple2(regex) {
      return { regex, deser: ([s3]) => s3 };
    }
    function escapeToken2(value) {
      return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    }
    function unitForToken2(token, loc) {
      const one = digitRegex2(loc), two = digitRegex2(loc, "{2}"), three = digitRegex2(loc, "{3}"), four = digitRegex2(loc, "{4}"), six = digitRegex2(loc, "{6}"), oneOrTwo = digitRegex2(loc, "{1,2}"), oneToThree = digitRegex2(loc, "{1,3}"), oneToSix = digitRegex2(loc, "{1,6}"), oneToNine = digitRegex2(loc, "{1,9}"), twoToFour = digitRegex2(loc, "{2,4}"), fourToSix = digitRegex2(loc, "{4,6}"), literal = (t) => ({ regex: RegExp(escapeToken2(t.val)), deser: ([s3]) => s3, literal: true }), unitate = (t) => {
        if (token.literal) {
          return literal(t);
        }
        switch (t.val) {
          case "G":
            return oneOf2(loc.eras("short"), 0);
          case "GG":
            return oneOf2(loc.eras("long"), 0);
          case "y":
            return intUnit2(oneToSix);
          case "yy":
            return intUnit2(twoToFour, untruncateYear2);
          case "yyyy":
            return intUnit2(four);
          case "yyyyy":
            return intUnit2(fourToSix);
          case "yyyyyy":
            return intUnit2(six);
          case "M":
            return intUnit2(oneOrTwo);
          case "MM":
            return intUnit2(two);
          case "MMM":
            return oneOf2(loc.months("short", true), 1);
          case "MMMM":
            return oneOf2(loc.months("long", true), 1);
          case "L":
            return intUnit2(oneOrTwo);
          case "LL":
            return intUnit2(two);
          case "LLL":
            return oneOf2(loc.months("short", false), 1);
          case "LLLL":
            return oneOf2(loc.months("long", false), 1);
          case "d":
            return intUnit2(oneOrTwo);
          case "dd":
            return intUnit2(two);
          case "o":
            return intUnit2(oneToThree);
          case "ooo":
            return intUnit2(three);
          case "HH":
            return intUnit2(two);
          case "H":
            return intUnit2(oneOrTwo);
          case "hh":
            return intUnit2(two);
          case "h":
            return intUnit2(oneOrTwo);
          case "mm":
            return intUnit2(two);
          case "m":
            return intUnit2(oneOrTwo);
          case "q":
            return intUnit2(oneOrTwo);
          case "qq":
            return intUnit2(two);
          case "s":
            return intUnit2(oneOrTwo);
          case "ss":
            return intUnit2(two);
          case "S":
            return intUnit2(oneToThree);
          case "SSS":
            return intUnit2(three);
          case "u":
            return simple2(oneToNine);
          case "uu":
            return simple2(oneOrTwo);
          case "uuu":
            return intUnit2(one);
          case "a":
            return oneOf2(loc.meridiems(), 0);
          case "kkkk":
            return intUnit2(four);
          case "kk":
            return intUnit2(twoToFour, untruncateYear2);
          case "W":
            return intUnit2(oneOrTwo);
          case "WW":
            return intUnit2(two);
          case "E":
          case "c":
            return intUnit2(one);
          case "EEE":
            return oneOf2(loc.weekdays("short", false), 1);
          case "EEEE":
            return oneOf2(loc.weekdays("long", false), 1);
          case "ccc":
            return oneOf2(loc.weekdays("short", true), 1);
          case "cccc":
            return oneOf2(loc.weekdays("long", true), 1);
          case "Z":
          case "ZZ":
            return offset2(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
          case "ZZZ":
            return offset2(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
          case "z":
            return simple2(/[a-z_+-/]{1,256}?/i);
          case " ":
            return simple2(/[^\S\n\r]/);
          default:
            return literal(t);
        }
      };
      const unit = unitate(token) || {
        invalidReason: MISSING_FTP2
      };
      unit.token = token;
      return unit;
    }
    var partTypeStyleToTokenVal2 = {
      year: {
        "2-digit": "yy",
        numeric: "yyyyy"
      },
      month: {
        numeric: "M",
        "2-digit": "MM",
        short: "MMM",
        long: "MMMM"
      },
      day: {
        numeric: "d",
        "2-digit": "dd"
      },
      weekday: {
        short: "EEE",
        long: "EEEE"
      },
      dayperiod: "a",
      dayPeriod: "a",
      hour12: {
        numeric: "h",
        "2-digit": "hh"
      },
      hour24: {
        numeric: "H",
        "2-digit": "HH"
      },
      minute: {
        numeric: "m",
        "2-digit": "mm"
      },
      second: {
        numeric: "s",
        "2-digit": "ss"
      },
      timeZoneName: {
        long: "ZZZZZ",
        short: "ZZZ"
      }
    };
    function tokenForPart2(part, formatOpts, resolvedOpts) {
      const { type, value } = part;
      if (type === "literal") {
        const isSpace = /^\s+$/.test(value);
        return {
          literal: !isSpace,
          val: isSpace ? " " : value
        };
      }
      const style = formatOpts[type];
      let actualType = type;
      if (type === "hour") {
        if (formatOpts.hour12 != null) {
          actualType = formatOpts.hour12 ? "hour12" : "hour24";
        } else if (formatOpts.hourCycle != null) {
          if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
            actualType = "hour12";
          } else {
            actualType = "hour24";
          }
        } else {
          actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
        }
      }
      let val = partTypeStyleToTokenVal2[actualType];
      if (typeof val === "object") {
        val = val[style];
      }
      if (val) {
        return {
          literal: false,
          val
        };
      }
      return void 0;
    }
    function buildRegex2(units) {
      const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
      return [`^${re}$`, units];
    }
    function match2(input, regex, handlers) {
      const matches = input.match(regex);
      if (matches) {
        const all = {};
        let matchIndex = 1;
        for (const i in handlers) {
          if (hasOwnProperty2(handlers, i)) {
            const h = handlers[i], groups = h.groups ? h.groups + 1 : 1;
            if (!h.literal && h.token) {
              all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
            }
            matchIndex += groups;
          }
        }
        return [matches, all];
      } else {
        return [matches, {}];
      }
    }
    function dateTimeFromMatches2(matches) {
      const toField = (token) => {
        switch (token) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
          case "H":
            return "hour";
          case "d":
            return "day";
          case "o":
            return "ordinal";
          case "L":
          case "M":
            return "month";
          case "y":
            return "year";
          case "E":
          case "c":
            return "weekday";
          case "W":
            return "weekNumber";
          case "k":
            return "weekYear";
          case "q":
            return "quarter";
          default:
            return null;
        }
      };
      let zone = null;
      let specificOffset;
      if (!isUndefined2(matches.z)) {
        zone = IANAZone2.create(matches.z);
      }
      if (!isUndefined2(matches.Z)) {
        if (!zone) {
          zone = new FixedOffsetZone2(matches.Z);
        }
        specificOffset = matches.Z;
      }
      if (!isUndefined2(matches.q)) {
        matches.M = (matches.q - 1) * 3 + 1;
      }
      if (!isUndefined2(matches.h)) {
        if (matches.h < 12 && matches.a === 1) {
          matches.h += 12;
        } else if (matches.h === 12 && matches.a === 0) {
          matches.h = 0;
        }
      }
      if (matches.G === 0 && matches.y) {
        matches.y = -matches.y;
      }
      if (!isUndefined2(matches.u)) {
        matches.S = parseMillis2(matches.u);
      }
      const vals = Object.keys(matches).reduce((r, k) => {
        const f = toField(k);
        if (f) {
          r[f] = matches[k];
        }
        return r;
      }, {});
      return [vals, zone, specificOffset];
    }
    var dummyDateTimeCache2 = null;
    function getDummyDateTime2() {
      if (!dummyDateTimeCache2) {
        dummyDateTimeCache2 = DateTime2.fromMillis(1555555555555);
      }
      return dummyDateTimeCache2;
    }
    function maybeExpandMacroToken2(token, locale) {
      if (token.literal) {
        return token;
      }
      const formatOpts = Formatter2.macroTokenToFormatOpts(token.val);
      const tokens = formatOptsToTokens2(formatOpts, locale);
      if (tokens == null || tokens.includes(void 0)) {
        return token;
      }
      return tokens;
    }
    function expandMacroTokens2(tokens, locale) {
      return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken2(t, locale)));
    }
    function explainFromTokens2(locale, input, format) {
      const tokens = expandMacroTokens2(Formatter2.parseFormat(format), locale), units = tokens.map((t) => unitForToken2(t, locale)), disqualifyingUnit = units.find((t) => t.invalidReason);
      if (disqualifyingUnit) {
        return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
      } else {
        const [regexString, handlers] = buildRegex2(units), regex = RegExp(regexString, "i"), [rawMatches, matches] = match2(input, regex, handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches2(matches) : [null, null, void 0];
        if (hasOwnProperty2(matches, "a") && hasOwnProperty2(matches, "H")) {
          throw new ConflictingSpecificationError2(
            "Can't include meridiem when specifying 24-hour format"
          );
        }
        return { input, tokens, regex, rawMatches, matches, result, zone, specificOffset };
      }
    }
    function parseFromTokens2(locale, input, format) {
      const { result, zone, specificOffset, invalidReason } = explainFromTokens2(locale, input, format);
      return [result, zone, specificOffset, invalidReason];
    }
    function formatOptsToTokens2(formatOpts, locale) {
      if (!formatOpts) {
        return null;
      }
      const formatter = Formatter2.create(locale, formatOpts);
      const df = formatter.dtFormatter(getDummyDateTime2());
      const parts = df.formatToParts();
      const resolvedOpts = df.resolvedOptions();
      return parts.map((p) => tokenForPart2(p, formatOpts, resolvedOpts));
    }
    var nonLeapLadder2 = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    var leapLadder2 = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
    function unitOutOfRange2(unit, value) {
      return new Invalid2(
        "unit out of range",
        `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
      );
    }
    function dayOfWeek2(year, month, day) {
      const d = new Date(Date.UTC(year, month - 1, day));
      if (year < 100 && year >= 0) {
        d.setUTCFullYear(d.getUTCFullYear() - 1900);
      }
      const js = d.getUTCDay();
      return js === 0 ? 7 : js;
    }
    function computeOrdinal2(year, month, day) {
      return day + (isLeapYear2(year) ? leapLadder2 : nonLeapLadder2)[month - 1];
    }
    function uncomputeOrdinal2(year, ordinal) {
      const table = isLeapYear2(year) ? leapLadder2 : nonLeapLadder2, month0 = table.findIndex((i) => i < ordinal), day = ordinal - table[month0];
      return { month: month0 + 1, day };
    }
    function gregorianToWeek2(gregObj) {
      const { year, month, day } = gregObj, ordinal = computeOrdinal2(year, month, day), weekday = dayOfWeek2(year, month, day);
      let weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;
      if (weekNumber < 1) {
        weekYear = year - 1;
        weekNumber = weeksInWeekYear2(weekYear);
      } else if (weekNumber > weeksInWeekYear2(year)) {
        weekYear = year + 1;
        weekNumber = 1;
      } else {
        weekYear = year;
      }
      return { weekYear, weekNumber, weekday, ...timeObject2(gregObj) };
    }
    function weekToGregorian2(weekData) {
      const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = dayOfWeek2(weekYear, 1, 4), yearInDays = daysInYear2(weekYear);
      let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
      if (ordinal < 1) {
        year = weekYear - 1;
        ordinal += daysInYear2(year);
      } else if (ordinal > yearInDays) {
        year = weekYear + 1;
        ordinal -= daysInYear2(weekYear);
      } else {
        year = weekYear;
      }
      const { month, day } = uncomputeOrdinal2(year, ordinal);
      return { year, month, day, ...timeObject2(weekData) };
    }
    function gregorianToOrdinal2(gregData) {
      const { year, month, day } = gregData;
      const ordinal = computeOrdinal2(year, month, day);
      return { year, ordinal, ...timeObject2(gregData) };
    }
    function ordinalToGregorian2(ordinalData) {
      const { year, ordinal } = ordinalData;
      const { month, day } = uncomputeOrdinal2(year, ordinal);
      return { year, month, day, ...timeObject2(ordinalData) };
    }
    function hasInvalidWeekData2(obj) {
      const validYear = isInteger2(obj.weekYear), validWeek = integerBetween2(obj.weekNumber, 1, weeksInWeekYear2(obj.weekYear)), validWeekday = integerBetween2(obj.weekday, 1, 7);
      if (!validYear) {
        return unitOutOfRange2("weekYear", obj.weekYear);
      } else if (!validWeek) {
        return unitOutOfRange2("week", obj.week);
      } else if (!validWeekday) {
        return unitOutOfRange2("weekday", obj.weekday);
      } else
        return false;
    }
    function hasInvalidOrdinalData2(obj) {
      const validYear = isInteger2(obj.year), validOrdinal = integerBetween2(obj.ordinal, 1, daysInYear2(obj.year));
      if (!validYear) {
        return unitOutOfRange2("year", obj.year);
      } else if (!validOrdinal) {
        return unitOutOfRange2("ordinal", obj.ordinal);
      } else
        return false;
    }
    function hasInvalidGregorianData2(obj) {
      const validYear = isInteger2(obj.year), validMonth = integerBetween2(obj.month, 1, 12), validDay = integerBetween2(obj.day, 1, daysInMonth2(obj.year, obj.month));
      if (!validYear) {
        return unitOutOfRange2("year", obj.year);
      } else if (!validMonth) {
        return unitOutOfRange2("month", obj.month);
      } else if (!validDay) {
        return unitOutOfRange2("day", obj.day);
      } else
        return false;
    }
    function hasInvalidTimeData2(obj) {
      const { hour, minute, second, millisecond } = obj;
      const validHour = integerBetween2(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween2(minute, 0, 59), validSecond = integerBetween2(second, 0, 59), validMillisecond = integerBetween2(millisecond, 0, 999);
      if (!validHour) {
        return unitOutOfRange2("hour", hour);
      } else if (!validMinute) {
        return unitOutOfRange2("minute", minute);
      } else if (!validSecond) {
        return unitOutOfRange2("second", second);
      } else if (!validMillisecond) {
        return unitOutOfRange2("millisecond", millisecond);
      } else
        return false;
    }
    var INVALID4 = "Invalid DateTime";
    var MAX_DATE2 = 864e13;
    function unsupportedZone2(zone) {
      return new Invalid2("unsupported zone", `the zone "${zone.name}" is not supported`);
    }
    function possiblyCachedWeekData2(dt) {
      if (dt.weekData === null) {
        dt.weekData = gregorianToWeek2(dt.c);
      }
      return dt.weekData;
    }
    function clone3(inst, alts) {
      const current = {
        ts: inst.ts,
        zone: inst.zone,
        c: inst.c,
        o: inst.o,
        loc: inst.loc,
        invalid: inst.invalid
      };
      return new DateTime2({ ...current, ...alts, old: current });
    }
    function fixOffset2(localTS, o, tz) {
      let utcGuess = localTS - o * 60 * 1e3;
      const o2 = tz.offset(utcGuess);
      if (o === o2) {
        return [utcGuess, o];
      }
      utcGuess -= (o2 - o) * 60 * 1e3;
      const o3 = tz.offset(utcGuess);
      if (o2 === o3) {
        return [utcGuess, o2];
      }
      return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
    }
    function tsToObj2(ts, offset3) {
      ts += offset3 * 60 * 1e3;
      const d = new Date(ts);
      return {
        year: d.getUTCFullYear(),
        month: d.getUTCMonth() + 1,
        day: d.getUTCDate(),
        hour: d.getUTCHours(),
        minute: d.getUTCMinutes(),
        second: d.getUTCSeconds(),
        millisecond: d.getUTCMilliseconds()
      };
    }
    function objToTS2(obj, offset3, zone) {
      return fixOffset2(objToLocalTS2(obj), offset3, zone);
    }
    function adjustTime2(inst, dur) {
      const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = {
        ...inst.c,
        year,
        month,
        day: Math.min(inst.c.day, daysInMonth2(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
      }, millisToAdd = Duration2.fromObject({
        years: dur.years - Math.trunc(dur.years),
        quarters: dur.quarters - Math.trunc(dur.quarters),
        months: dur.months - Math.trunc(dur.months),
        weeks: dur.weeks - Math.trunc(dur.weeks),
        days: dur.days - Math.trunc(dur.days),
        hours: dur.hours,
        minutes: dur.minutes,
        seconds: dur.seconds,
        milliseconds: dur.milliseconds
      }).as("milliseconds"), localTS = objToLocalTS2(c);
      let [ts, o] = fixOffset2(localTS, oPre, inst.zone);
      if (millisToAdd !== 0) {
        ts += millisToAdd;
        o = inst.zone.offset(ts);
      }
      return { ts, o };
    }
    function parseDataToDateTime2(parsed, parsedZone, opts, format, text2, specificOffset) {
      const { setZone, zone } = opts;
      if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
        const interpretationZone = parsedZone || zone, inst = DateTime2.fromObject(parsed, {
          ...opts,
          zone: interpretationZone,
          specificOffset
        });
        return setZone ? inst : inst.setZone(zone);
      } else {
        return DateTime2.invalid(
          new Invalid2("unparsable", `the input "${text2}" can't be parsed as ${format}`)
        );
      }
    }
    function toTechFormat2(dt, format, allowZ = true) {
      return dt.isValid ? Formatter2.create(Locale2.create("en-US"), {
        allowZ,
        forceSimple: true
      }).formatDateTimeFromString(dt, format) : null;
    }
    function toISODate2(o, extended) {
      const longFormat = o.c.year > 9999 || o.c.year < 0;
      let c = "";
      if (longFormat && o.c.year >= 0)
        c += "+";
      c += padStart2(o.c.year, longFormat ? 6 : 4);
      if (extended) {
        c += "-";
        c += padStart2(o.c.month);
        c += "-";
        c += padStart2(o.c.day);
      } else {
        c += padStart2(o.c.month);
        c += padStart2(o.c.day);
      }
      return c;
    }
    function toISOTime2(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
      let c = padStart2(o.c.hour);
      if (extended) {
        c += ":";
        c += padStart2(o.c.minute);
        if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
          c += ":";
        }
      } else {
        c += padStart2(o.c.minute);
      }
      if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
        c += padStart2(o.c.second);
        if (o.c.millisecond !== 0 || !suppressMilliseconds) {
          c += ".";
          c += padStart2(o.c.millisecond, 3);
        }
      }
      if (includeOffset) {
        if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
          c += "Z";
        } else if (o.o < 0) {
          c += "-";
          c += padStart2(Math.trunc(-o.o / 60));
          c += ":";
          c += padStart2(Math.trunc(-o.o % 60));
        } else {
          c += "+";
          c += padStart2(Math.trunc(o.o / 60));
          c += ":";
          c += padStart2(Math.trunc(o.o % 60));
        }
      }
      if (extendedZone) {
        c += "[" + o.zone.ianaName + "]";
      }
      return c;
    }
    var defaultUnitValues2 = {
      month: 1,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultWeekUnitValues2 = {
      weekNumber: 1,
      weekday: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultOrdinalUnitValues2 = {
      ordinal: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var orderedUnits3 = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
    var orderedWeekUnits2 = [
      "weekYear",
      "weekNumber",
      "weekday",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    var orderedOrdinalUnits2 = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
    function normalizeUnit2(unit) {
      const normalized = {
        year: "year",
        years: "year",
        month: "month",
        months: "month",
        day: "day",
        days: "day",
        hour: "hour",
        hours: "hour",
        minute: "minute",
        minutes: "minute",
        quarter: "quarter",
        quarters: "quarter",
        second: "second",
        seconds: "second",
        millisecond: "millisecond",
        milliseconds: "millisecond",
        weekday: "weekday",
        weekdays: "weekday",
        weeknumber: "weekNumber",
        weeksnumber: "weekNumber",
        weeknumbers: "weekNumber",
        weekyear: "weekYear",
        weekyears: "weekYear",
        ordinal: "ordinal"
      }[unit.toLowerCase()];
      if (!normalized)
        throw new InvalidUnitError2(unit);
      return normalized;
    }
    function quickDT2(obj, opts) {
      const zone = normalizeZone2(opts.zone, Settings3.defaultZone), loc = Locale2.fromObject(opts), tsNow = Settings3.now();
      let ts, o;
      if (!isUndefined2(obj.year)) {
        for (const u of orderedUnits3) {
          if (isUndefined2(obj[u])) {
            obj[u] = defaultUnitValues2[u];
          }
        }
        const invalid = hasInvalidGregorianData2(obj) || hasInvalidTimeData2(obj);
        if (invalid) {
          return DateTime2.invalid(invalid);
        }
        const offsetProvis = zone.offset(tsNow);
        [ts, o] = objToTS2(obj, offsetProvis, zone);
      } else {
        ts = tsNow;
      }
      return new DateTime2({ ts, zone, loc, o });
    }
    function diffRelative2(start, end, opts) {
      const round = isUndefined2(opts.round) ? true : opts.round, format = (c, unit) => {
        c = roundTo2(c, round || opts.calendary ? 0 : 2, true);
        const formatter = end.loc.clone(opts).relFormatter(opts);
        return formatter.format(c, unit);
      }, differ = (unit) => {
        if (opts.calendary) {
          if (!end.hasSame(start, unit)) {
            return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
          } else
            return 0;
        } else {
          return end.diff(start, unit).get(unit);
        }
      };
      if (opts.unit) {
        return format(differ(opts.unit), opts.unit);
      }
      for (const unit of opts.units) {
        const count = differ(unit);
        if (Math.abs(count) >= 1) {
          return format(count, unit);
        }
      }
      return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
    }
    function lastOpts2(argList) {
      let opts = {}, args;
      if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
        opts = argList[argList.length - 1];
        args = Array.from(argList).slice(0, argList.length - 1);
      } else {
        args = Array.from(argList);
      }
      return [opts, args];
    }
    var DateTime2 = class _DateTime {
      /**
       * @access private
       */
      constructor(config) {
        const zone = config.zone || Settings3.defaultZone;
        let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid2("invalid input") : null) || (!zone.isValid ? unsupportedZone2(zone) : null);
        this.ts = isUndefined2(config.ts) ? Settings3.now() : config.ts;
        let c = null, o = null;
        if (!invalid) {
          const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
          if (unchanged) {
            [c, o] = [config.old.c, config.old.o];
          } else {
            const ot = zone.offset(this.ts);
            c = tsToObj2(this.ts, ot);
            invalid = Number.isNaN(c.year) ? new Invalid2("invalid input") : null;
            c = invalid ? null : c;
            o = invalid ? null : ot;
          }
        }
        this._zone = zone;
        this.loc = config.loc || Locale2.create();
        this.invalid = invalid;
        this.weekData = null;
        this.c = c;
        this.o = o;
        this.isLuxonDateTime = true;
      }
      // CONSTRUCT
      /**
       * Create a DateTime for the current instant, in the system's time zone.
       *
       * Use Settings to override these default values if needed.
       * @example DateTime.now().toISO() //~> now in the ISO format
       * @return {DateTime}
       */
      static now() {
        return new _DateTime({});
      }
      /**
       * Create a local DateTime
       * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
       * @param {number} [month=1] - The month, 1-indexed
       * @param {number} [day=1] - The day of the month, 1-indexed
       * @param {number} [hour=0] - The hour of the day, in 24-hour time
       * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
       * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
       * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
       * @example DateTime.local()                                  //~> now
       * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
       * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
       * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
       * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
       * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
       * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
       * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
       * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
       * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
       * @return {DateTime}
       */
      static local() {
        const [opts, args] = lastOpts2(arguments), [year, month, day, hour, minute, second, millisecond] = args;
        return quickDT2({ year, month, day, hour, minute, second, millisecond }, opts);
      }
      /**
       * Create a DateTime in UTC
       * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
       * @param {number} [month=1] - The month, 1-indexed
       * @param {number} [day=1] - The day of the month
       * @param {number} [hour=0] - The hour of the day, in 24-hour time
       * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
       * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
       * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
       * @param {Object} options - configuration options for the DateTime
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
       * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
       * @example DateTime.utc()                                              //~> now
       * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
       * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
       * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
       * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
       * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
       * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
       * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
       * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
       * @return {DateTime}
       */
      static utc() {
        const [opts, args] = lastOpts2(arguments), [year, month, day, hour, minute, second, millisecond] = args;
        opts.zone = FixedOffsetZone2.utcInstance;
        return quickDT2({ year, month, day, hour, minute, second, millisecond }, opts);
      }
      /**
       * Create a DateTime from a JavaScript Date object. Uses the default zone.
       * @param {Date} date - a JavaScript Date object
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @return {DateTime}
       */
      static fromJSDate(date, options = {}) {
        const ts = isDate2(date) ? date.valueOf() : NaN;
        if (Number.isNaN(ts)) {
          return _DateTime.invalid("invalid input");
        }
        const zoneToUse = normalizeZone2(options.zone, Settings3.defaultZone);
        if (!zoneToUse.isValid) {
          return _DateTime.invalid(unsupportedZone2(zoneToUse));
        }
        return new _DateTime({
          ts,
          zone: zoneToUse,
          loc: Locale2.fromObject(options)
        });
      }
      /**
       * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
       * @param {number} milliseconds - a number of milliseconds since 1970 UTC
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromMillis(milliseconds, options = {}) {
        if (!isNumber2(milliseconds)) {
          throw new InvalidArgumentError2(
            `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
          );
        } else if (milliseconds < -MAX_DATE2 || milliseconds > MAX_DATE2) {
          return _DateTime.invalid("Timestamp out of range");
        } else {
          return new _DateTime({
            ts: milliseconds,
            zone: normalizeZone2(options.zone, Settings3.defaultZone),
            loc: Locale2.fromObject(options)
          });
        }
      }
      /**
       * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
       * @param {number} seconds - a number of seconds since 1970 UTC
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromSeconds(seconds, options = {}) {
        if (!isNumber2(seconds)) {
          throw new InvalidArgumentError2("fromSeconds requires a numerical input");
        } else {
          return new _DateTime({
            ts: seconds * 1e3,
            zone: normalizeZone2(options.zone, Settings3.defaultZone),
            loc: Locale2.fromObject(options)
          });
        }
      }
      /**
       * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
       * @param {Object} obj - the object to create the DateTime from
       * @param {number} obj.year - a year, such as 1987
       * @param {number} obj.month - a month, 1-12
       * @param {number} obj.day - a day of the month, 1-31, depending on the month
       * @param {number} obj.ordinal - day of the year, 1-365 or 366
       * @param {number} obj.weekYear - an ISO week year
       * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
       * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
       * @param {number} obj.hour - hour of the day, 0-23
       * @param {number} obj.minute - minute of the hour, 0-59
       * @param {number} obj.second - second of the minute, 0-59
       * @param {number} obj.millisecond - millisecond of the second, 0-999
       * @param {Object} opts - options for creating this DateTime
       * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
       * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
       * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
       * @return {DateTime}
       */
      static fromObject(obj, opts = {}) {
        obj = obj || {};
        const zoneToUse = normalizeZone2(opts.zone, Settings3.defaultZone);
        if (!zoneToUse.isValid) {
          return _DateTime.invalid(unsupportedZone2(zoneToUse));
        }
        const tsNow = Settings3.now(), offsetProvis = !isUndefined2(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), normalized = normalizeObject2(obj, normalizeUnit2), containsOrdinal = !isUndefined2(normalized.ordinal), containsGregorYear = !isUndefined2(normalized.year), containsGregorMD = !isUndefined2(normalized.month) || !isUndefined2(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale2.fromObject(opts);
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError2(
            "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
          );
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError2("Can't mix ordinal dates with month/day");
        }
        const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
        let units, defaultValues, objNow = tsToObj2(tsNow, offsetProvis);
        if (useWeekData) {
          units = orderedWeekUnits2;
          defaultValues = defaultWeekUnitValues2;
          objNow = gregorianToWeek2(objNow);
        } else if (containsOrdinal) {
          units = orderedOrdinalUnits2;
          defaultValues = defaultOrdinalUnitValues2;
          objNow = gregorianToOrdinal2(objNow);
        } else {
          units = orderedUnits3;
          defaultValues = defaultUnitValues2;
        }
        let foundFirst = false;
        for (const u of units) {
          const v = normalized[u];
          if (!isUndefined2(v)) {
            foundFirst = true;
          } else if (foundFirst) {
            normalized[u] = defaultValues[u];
          } else {
            normalized[u] = objNow[u];
          }
        }
        const higherOrderInvalid = useWeekData ? hasInvalidWeekData2(normalized) : containsOrdinal ? hasInvalidOrdinalData2(normalized) : hasInvalidGregorianData2(normalized), invalid = higherOrderInvalid || hasInvalidTimeData2(normalized);
        if (invalid) {
          return _DateTime.invalid(invalid);
        }
        const gregorian = useWeekData ? weekToGregorian2(normalized) : containsOrdinal ? ordinalToGregorian2(normalized) : normalized, [tsFinal, offsetFinal] = objToTS2(gregorian, offsetProvis, zoneToUse), inst = new _DateTime({
          ts: tsFinal,
          zone: zoneToUse,
          o: offsetFinal,
          loc
        });
        if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
          return _DateTime.invalid(
            "mismatched weekday",
            `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
          );
        }
        return inst;
      }
      /**
       * Create a DateTime from an ISO 8601 string
       * @param {string} text - the ISO string
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
       * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromISO('2016-05-25T09:08:34.123')
       * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
       * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
       * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
       * @example DateTime.fromISO('2016-W05-4')
       * @return {DateTime}
       */
      static fromISO(text2, opts = {}) {
        const [vals, parsedZone] = parseISODate2(text2);
        return parseDataToDateTime2(vals, parsedZone, opts, "ISO 8601", text2);
      }
      /**
       * Create a DateTime from an RFC 2822 string
       * @param {string} text - the RFC 2822 string
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
       * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
       * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
       * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
       * @return {DateTime}
       */
      static fromRFC2822(text2, opts = {}) {
        const [vals, parsedZone] = parseRFC2822Date2(text2);
        return parseDataToDateTime2(vals, parsedZone, opts, "RFC 2822", text2);
      }
      /**
       * Create a DateTime from an HTTP header date
       * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
       * @param {string} text - the HTTP header date
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
       * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
       * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
       * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
       * @return {DateTime}
       */
      static fromHTTP(text2, opts = {}) {
        const [vals, parsedZone] = parseHTTPDate2(text2);
        return parseDataToDateTime2(vals, parsedZone, opts, "HTTP", opts);
      }
      /**
       * Create a DateTime from an input string and format string.
       * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
       * @param {string} text - the string to parse
       * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
       * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromFormat(text2, fmt, opts = {}) {
        if (isUndefined2(text2) || isUndefined2(fmt)) {
          throw new InvalidArgumentError2("fromFormat requires an input string and a format");
        }
        const { locale = null, numberingSystem = null } = opts, localeToUse = Locale2.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens2(localeToUse, text2, fmt);
        if (invalid) {
          return _DateTime.invalid(invalid);
        } else {
          return parseDataToDateTime2(vals, parsedZone, opts, `format ${fmt}`, text2, specificOffset);
        }
      }
      /**
       * @deprecated use fromFormat instead
       */
      static fromString(text2, fmt, opts = {}) {
        return _DateTime.fromFormat(text2, fmt, opts);
      }
      /**
       * Create a DateTime from a SQL date, time, or datetime
       * Defaults to en-US if no locale has been specified, regardless of the system's locale
       * @param {string} text - the string to parse
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
       * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @example DateTime.fromSQL('2017-05-15')
       * @example DateTime.fromSQL('2017-05-15 09:12:34')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
       * @example DateTime.fromSQL('09:12:34.342')
       * @return {DateTime}
       */
      static fromSQL(text2, opts = {}) {
        const [vals, parsedZone] = parseSQL2(text2);
        return parseDataToDateTime2(vals, parsedZone, opts, "SQL", text2);
      }
      /**
       * Create an invalid DateTime.
       * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {DateTime}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError2("need to specify a reason the DateTime is invalid");
        }
        const invalid = reason instanceof Invalid2 ? reason : new Invalid2(reason, explanation);
        if (Settings3.throwOnInvalid) {
          throw new InvalidDateTimeError2(invalid);
        } else {
          return new _DateTime({ invalid });
        }
      }
      /**
       * Check if an object is an instance of DateTime. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isDateTime(o) {
        return o && o.isLuxonDateTime || false;
      }
      /**
       * Produce the format string for a set of options
       * @param formatOpts
       * @param localeOpts
       * @returns {string}
       */
      static parseFormatForOpts(formatOpts, localeOpts = {}) {
        const tokenList = formatOptsToTokens2(formatOpts, Locale2.fromObject(localeOpts));
        return !tokenList ? null : tokenList.map((t) => t ? t.val : null).join("");
      }
      /**
       * Produce the the fully expanded format token for the locale
       * Does NOT quote characters, so quoted tokens will not round trip correctly
       * @param fmt
       * @param localeOpts
       * @returns {string}
       */
      static expandFormat(fmt, localeOpts = {}) {
        const expanded = expandMacroTokens2(Formatter2.parseFormat(fmt), Locale2.fromObject(localeOpts));
        return expanded.map((t) => t.val).join("");
      }
      // INFO
      /**
       * Get the value of unit.
       * @param {string} unit - a unit such as 'minute' or 'day'
       * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
       * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
       * @return {number}
       */
      get(unit) {
        return this[unit];
      }
      /**
       * Returns whether the DateTime is valid. Invalid DateTimes occur when:
       * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
       * * The DateTime was created by an operation on another invalid date
       * @type {boolean}
       */
      get isValid() {
        return this.invalid === null;
      }
      /**
       * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
       * @type {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
       *
       * @type {string}
       */
      get locale() {
        return this.isValid ? this.loc.locale : null;
      }
      /**
       * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
       *
       * @type {string}
       */
      get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null;
      }
      /**
       * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
       *
       * @type {string}
       */
      get outputCalendar() {
        return this.isValid ? this.loc.outputCalendar : null;
      }
      /**
       * Get the time zone associated with this DateTime.
       * @type {Zone}
       */
      get zone() {
        return this._zone;
      }
      /**
       * Get the name of the time zone.
       * @type {string}
       */
      get zoneName() {
        return this.isValid ? this.zone.name : null;
      }
      /**
       * Get the year
       * @example DateTime.local(2017, 5, 25).year //=> 2017
       * @type {number}
       */
      get year() {
        return this.isValid ? this.c.year : NaN;
      }
      /**
       * Get the quarter
       * @example DateTime.local(2017, 5, 25).quarter //=> 2
       * @type {number}
       */
      get quarter() {
        return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
      }
      /**
       * Get the month (1-12).
       * @example DateTime.local(2017, 5, 25).month //=> 5
       * @type {number}
       */
      get month() {
        return this.isValid ? this.c.month : NaN;
      }
      /**
       * Get the day of the month (1-30ish).
       * @example DateTime.local(2017, 5, 25).day //=> 25
       * @type {number}
       */
      get day() {
        return this.isValid ? this.c.day : NaN;
      }
      /**
       * Get the hour of the day (0-23).
       * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
       * @type {number}
       */
      get hour() {
        return this.isValid ? this.c.hour : NaN;
      }
      /**
       * Get the minute of the hour (0-59).
       * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
       * @type {number}
       */
      get minute() {
        return this.isValid ? this.c.minute : NaN;
      }
      /**
       * Get the second of the minute (0-59).
       * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
       * @type {number}
       */
      get second() {
        return this.isValid ? this.c.second : NaN;
      }
      /**
       * Get the millisecond of the second (0-999).
       * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
       * @type {number}
       */
      get millisecond() {
        return this.isValid ? this.c.millisecond : NaN;
      }
      /**
       * Get the week year
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
       * @type {number}
       */
      get weekYear() {
        return this.isValid ? possiblyCachedWeekData2(this).weekYear : NaN;
      }
      /**
       * Get the week number of the week year (1-52ish).
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
       * @type {number}
       */
      get weekNumber() {
        return this.isValid ? possiblyCachedWeekData2(this).weekNumber : NaN;
      }
      /**
       * Get the day of the week.
       * 1 is Monday and 7 is Sunday
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2014, 11, 31).weekday //=> 4
       * @type {number}
       */
      get weekday() {
        return this.isValid ? possiblyCachedWeekData2(this).weekday : NaN;
      }
      /**
       * Get the ordinal (meaning the day of the year)
       * @example DateTime.local(2017, 5, 25).ordinal //=> 145
       * @type {number|DateTime}
       */
      get ordinal() {
        return this.isValid ? gregorianToOrdinal2(this.c).ordinal : NaN;
      }
      /**
       * Get the human readable short month name, such as 'Oct'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
       * @type {string}
       */
      get monthShort() {
        return this.isValid ? Info2.months("short", { locObj: this.loc })[this.month - 1] : null;
      }
      /**
       * Get the human readable long month name, such as 'October'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).monthLong //=> October
       * @type {string}
       */
      get monthLong() {
        return this.isValid ? Info2.months("long", { locObj: this.loc })[this.month - 1] : null;
      }
      /**
       * Get the human readable short weekday, such as 'Mon'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
       * @type {string}
       */
      get weekdayShort() {
        return this.isValid ? Info2.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
      }
      /**
       * Get the human readable long weekday, such as 'Monday'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
       * @type {string}
       */
      get weekdayLong() {
        return this.isValid ? Info2.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
      }
      /**
       * Get the UTC offset of this DateTime in minutes
       * @example DateTime.now().offset //=> -240
       * @example DateTime.utc().offset //=> 0
       * @type {number}
       */
      get offset() {
        return this.isValid ? +this.o : NaN;
      }
      /**
       * Get the short human name for the zone's current offset, for example "EST" or "EDT".
       * Defaults to the system's locale if no locale has been specified
       * @type {string}
       */
      get offsetNameShort() {
        if (this.isValid) {
          return this.zone.offsetName(this.ts, {
            format: "short",
            locale: this.locale
          });
        } else {
          return null;
        }
      }
      /**
       * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
       * Defaults to the system's locale if no locale has been specified
       * @type {string}
       */
      get offsetNameLong() {
        if (this.isValid) {
          return this.zone.offsetName(this.ts, {
            format: "long",
            locale: this.locale
          });
        } else {
          return null;
        }
      }
      /**
       * Get whether this zone's offset ever changes, as in a DST.
       * @type {boolean}
       */
      get isOffsetFixed() {
        return this.isValid ? this.zone.isUniversal : null;
      }
      /**
       * Get whether the DateTime is in a DST.
       * @type {boolean}
       */
      get isInDST() {
        if (this.isOffsetFixed) {
          return false;
        } else {
          return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
        }
      }
      /**
       * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
       * in this DateTime's zone. During DST changes local time can be ambiguous, for example
       * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
       * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
       * @returns {DateTime[]}
       */
      getPossibleOffsets() {
        if (!this.isValid || this.isOffsetFixed) {
          return [this];
        }
        const dayMs = 864e5;
        const minuteMs = 6e4;
        const localTS = objToLocalTS2(this.c);
        const oEarlier = this.zone.offset(localTS - dayMs);
        const oLater = this.zone.offset(localTS + dayMs);
        const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
        const o2 = this.zone.offset(localTS - oLater * minuteMs);
        if (o1 === o2) {
          return [this];
        }
        const ts1 = localTS - o1 * minuteMs;
        const ts2 = localTS - o2 * minuteMs;
        const c1 = tsToObj2(ts1, o1);
        const c2 = tsToObj2(ts2, o2);
        if (c1.hour === c2.hour && c1.minute === c2.minute && c1.second === c2.second && c1.millisecond === c2.millisecond) {
          return [clone3(this, { ts: ts1 }), clone3(this, { ts: ts2 })];
        }
        return [this];
      }
      /**
       * Returns true if this DateTime is in a leap year, false otherwise
       * @example DateTime.local(2016).isInLeapYear //=> true
       * @example DateTime.local(2013).isInLeapYear //=> false
       * @type {boolean}
       */
      get isInLeapYear() {
        return isLeapYear2(this.year);
      }
      /**
       * Returns the number of days in this DateTime's month
       * @example DateTime.local(2016, 2).daysInMonth //=> 29
       * @example DateTime.local(2016, 3).daysInMonth //=> 31
       * @type {number}
       */
      get daysInMonth() {
        return daysInMonth2(this.year, this.month);
      }
      /**
       * Returns the number of days in this DateTime's year
       * @example DateTime.local(2016).daysInYear //=> 366
       * @example DateTime.local(2013).daysInYear //=> 365
       * @type {number}
       */
      get daysInYear() {
        return this.isValid ? daysInYear2(this.year) : NaN;
      }
      /**
       * Returns the number of weeks in this DateTime's year
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2004).weeksInWeekYear //=> 53
       * @example DateTime.local(2013).weeksInWeekYear //=> 52
       * @type {number}
       */
      get weeksInWeekYear() {
        return this.isValid ? weeksInWeekYear2(this.weekYear) : NaN;
      }
      /**
       * Returns the resolved Intl options for this DateTime.
       * This is useful in understanding the behavior of formatting methods
       * @param {Object} opts - the same options as toLocaleString
       * @return {Object}
       */
      resolvedLocaleOptions(opts = {}) {
        const { locale, numberingSystem, calendar } = Formatter2.create(
          this.loc.clone(opts),
          opts
        ).resolvedOptions(this);
        return { locale, numberingSystem, outputCalendar: calendar };
      }
      // TRANSFORM
      /**
       * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
       *
       * Equivalent to {@link DateTime#setZone}('utc')
       * @param {number} [offset=0] - optionally, an offset from UTC in minutes
       * @param {Object} [opts={}] - options to pass to `setZone()`
       * @return {DateTime}
       */
      toUTC(offset3 = 0, opts = {}) {
        return this.setZone(FixedOffsetZone2.instance(offset3), opts);
      }
      /**
       * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
       *
       * Equivalent to `setZone('local')`
       * @return {DateTime}
       */
      toLocal() {
        return this.setZone(Settings3.defaultZone);
      }
      /**
       * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
       *
       * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
       * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
       * @param {Object} opts - options
       * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
       * @return {DateTime}
       */
      setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
        zone = normalizeZone2(zone, Settings3.defaultZone);
        if (zone.equals(this.zone)) {
          return this;
        } else if (!zone.isValid) {
          return _DateTime.invalid(unsupportedZone2(zone));
        } else {
          let newTS = this.ts;
          if (keepLocalTime || keepCalendarTime) {
            const offsetGuess = zone.offset(this.ts);
            const asObj = this.toObject();
            [newTS] = objToTS2(asObj, offsetGuess, zone);
          }
          return clone3(this, { ts: newTS, zone });
        }
      }
      /**
       * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
       * @param {Object} properties - the properties to set
       * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
       * @return {DateTime}
       */
      reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
        const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
        return clone3(this, { loc });
      }
      /**
       * "Set" the locale. Returns a newly-constructed DateTime.
       * Just a convenient alias for reconfigure({ locale })
       * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
       * @return {DateTime}
       */
      setLocale(locale) {
        return this.reconfigure({ locale });
      }
      /**
       * "Set" the values of specified units. Returns a newly-constructed DateTime.
       * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
       * @param {Object} values - a mapping of units to numbers
       * @example dt.set({ year: 2017 })
       * @example dt.set({ hour: 8, minute: 30 })
       * @example dt.set({ weekday: 5 })
       * @example dt.set({ year: 2005, ordinal: 234 })
       * @return {DateTime}
       */
      set(values) {
        if (!this.isValid)
          return this;
        const normalized = normalizeObject2(values, normalizeUnit2), settingWeekStuff = !isUndefined2(normalized.weekYear) || !isUndefined2(normalized.weekNumber) || !isUndefined2(normalized.weekday), containsOrdinal = !isUndefined2(normalized.ordinal), containsGregorYear = !isUndefined2(normalized.year), containsGregorMD = !isUndefined2(normalized.month) || !isUndefined2(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError2(
            "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
          );
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError2("Can't mix ordinal dates with month/day");
        }
        let mixed;
        if (settingWeekStuff) {
          mixed = weekToGregorian2({ ...gregorianToWeek2(this.c), ...normalized });
        } else if (!isUndefined2(normalized.ordinal)) {
          mixed = ordinalToGregorian2({ ...gregorianToOrdinal2(this.c), ...normalized });
        } else {
          mixed = { ...this.toObject(), ...normalized };
          if (isUndefined2(normalized.day)) {
            mixed.day = Math.min(daysInMonth2(mixed.year, mixed.month), mixed.day);
          }
        }
        const [ts, o] = objToTS2(mixed, this.o, this.zone);
        return clone3(this, { ts, o });
      }
      /**
       * Add a period of time to this DateTime and return the resulting DateTime
       *
       * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
       * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @example DateTime.now().plus(123) //~> in 123 milliseconds
       * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
       * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
       * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
       * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
       * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
       * @return {DateTime}
       */
      plus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration2.fromDurationLike(duration);
        return clone3(this, adjustTime2(this, dur));
      }
      /**
       * Subtract a period of time to this DateTime and return the resulting DateTime
       * See {@link DateTime#plus}
       * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       @return {DateTime}
       */
      minus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration2.fromDurationLike(duration).negate();
        return clone3(this, adjustTime2(this, dur));
      }
      /**
       * "Set" this DateTime to the beginning of a unit of time.
       * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
       * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
       * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
       * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
       * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
       * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
       * @return {DateTime}
       */
      startOf(unit) {
        if (!this.isValid)
          return this;
        const o = {}, normalizedUnit = Duration2.normalizeUnit(unit);
        switch (normalizedUnit) {
          case "years":
            o.month = 1;
          case "quarters":
          case "months":
            o.day = 1;
          case "weeks":
          case "days":
            o.hour = 0;
          case "hours":
            o.minute = 0;
          case "minutes":
            o.second = 0;
          case "seconds":
            o.millisecond = 0;
            break;
        }
        if (normalizedUnit === "weeks") {
          o.weekday = 1;
        }
        if (normalizedUnit === "quarters") {
          const q = Math.ceil(this.month / 3);
          o.month = (q - 1) * 3 + 1;
        }
        return this.set(o);
      }
      /**
       * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
       * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
       * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
       * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
       * @return {DateTime}
       */
      endOf(unit) {
        return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit).minus(1) : this;
      }
      // OUTPUT
      /**
       * Returns a string representation of this DateTime formatted according to the specified format string.
       * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
       * Defaults to en-US if no locale has been specified, regardless of the system's locale.
       * @param {string} fmt - the format string
       * @param {Object} opts - opts to override the configuration options on this DateTime
       * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
       * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
       * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
       * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
       * @return {string}
       */
      toFormat(fmt, opts = {}) {
        return this.isValid ? Formatter2.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID4;
      }
      /**
       * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
       * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
       * of the DateTime in the assigned locale.
       * Defaults to the system's locale if no locale has been specified
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
       * @param {Object} opts - opts to override the configuration options on this DateTime
       * @example DateTime.now().toLocaleString(); //=> 4/20/2017
       * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
       * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
       * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 aot 2022'
       * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
       * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
       * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
       * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
       * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
       * @return {string}
       */
      toLocaleString(formatOpts = DATE_SHORT2, opts = {}) {
        return this.isValid ? Formatter2.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID4;
      }
      /**
       * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
       * Defaults to the system's locale if no locale has been specified
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
       * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
       * @example DateTime.now().toLocaleParts(); //=> [
       *                                   //=>   { type: 'day', value: '25' },
       *                                   //=>   { type: 'literal', value: '/' },
       *                                   //=>   { type: 'month', value: '05' },
       *                                   //=>   { type: 'literal', value: '/' },
       *                                   //=>   { type: 'year', value: '1982' }
       *                                   //=> ]
       */
      toLocaleParts(opts = {}) {
        return this.isValid ? Formatter2.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
       * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
       * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
       * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
       * @return {string}
       */
      toISO({
        format = "extended",
        suppressSeconds = false,
        suppressMilliseconds = false,
        includeOffset = true,
        extendedZone = false
      } = {}) {
        if (!this.isValid) {
          return null;
        }
        const ext = format === "extended";
        let c = toISODate2(this, ext);
        c += "T";
        c += toISOTime2(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
        return c;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's date component
       * @param {Object} opts - options
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
       * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
       * @return {string}
       */
      toISODate({ format = "extended" } = {}) {
        if (!this.isValid) {
          return null;
        }
        return toISODate2(this, format === "extended");
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's week date
       * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
       * @return {string}
       */
      toISOWeekDate() {
        return toTechFormat2(this, "kkkk-'W'WW-c");
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's time component
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
       * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
       * @return {string}
       */
      toISOTime({
        suppressMilliseconds = false,
        suppressSeconds = false,
        includeOffset = true,
        includePrefix = false,
        extendedZone = false,
        format = "extended"
      } = {}) {
        if (!this.isValid) {
          return null;
        }
        let c = includePrefix ? "T" : "";
        return c + toISOTime2(
          this,
          format === "extended",
          suppressSeconds,
          suppressMilliseconds,
          includeOffset,
          extendedZone
        );
      }
      /**
       * Returns an RFC 2822-compatible string representation of this DateTime
       * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
       * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
       * @return {string}
       */
      toRFC2822() {
        return toTechFormat2(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
       * Specifically, the string conforms to RFC 1123.
       * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
       * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
       * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
       * @return {string}
       */
      toHTTP() {
        return toTechFormat2(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL Date
       * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
       * @return {string}
       */
      toSQLDate() {
        if (!this.isValid) {
          return null;
        }
        return toISODate2(this, true);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL Time
       * @param {Object} opts - options
       * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
       * @example DateTime.utc().toSQL() //=> '05:15:16.345'
       * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
       * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
       * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
       * @return {string}
       */
      toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
        let fmt = "HH:mm:ss.SSS";
        if (includeZone || includeOffset) {
          if (includeOffsetSpace) {
            fmt += " ";
          }
          if (includeZone) {
            fmt += "z";
          } else if (includeOffset) {
            fmt += "ZZ";
          }
        }
        return toTechFormat2(this, fmt, true);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL DateTime
       * @param {Object} opts - options
       * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
       * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
       * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
       * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
       * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
       * @return {string}
       */
      toSQL(opts = {}) {
        if (!this.isValid) {
          return null;
        }
        return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
      }
      /**
       * Returns a string representation of this DateTime appropriate for debugging
       * @return {string}
       */
      toString() {
        return this.isValid ? this.toISO() : INVALID4;
      }
      /**
       * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
       * @return {number}
       */
      valueOf() {
        return this.toMillis();
      }
      /**
       * Returns the epoch milliseconds of this DateTime.
       * @return {number}
       */
      toMillis() {
        return this.isValid ? this.ts : NaN;
      }
      /**
       * Returns the epoch seconds of this DateTime.
       * @return {number}
       */
      toSeconds() {
        return this.isValid ? this.ts / 1e3 : NaN;
      }
      /**
       * Returns the epoch seconds (as a whole number) of this DateTime.
       * @return {number}
       */
      toUnixInteger() {
        return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
      }
      /**
       * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
       * @return {string}
       */
      toJSON() {
        return this.toISO();
      }
      /**
       * Returns a BSON serializable equivalent to this DateTime.
       * @return {Date}
       */
      toBSON() {
        return this.toJSDate();
      }
      /**
       * Returns a JavaScript object with this DateTime's year, month, day, and so on.
       * @param opts - options for generating the object
       * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
       * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
       * @return {Object}
       */
      toObject(opts = {}) {
        if (!this.isValid)
          return {};
        const base = { ...this.c };
        if (opts.includeConfig) {
          base.outputCalendar = this.outputCalendar;
          base.numberingSystem = this.loc.numberingSystem;
          base.locale = this.loc.locale;
        }
        return base;
      }
      /**
       * Returns a JavaScript Date equivalent to this DateTime.
       * @return {Date}
       */
      toJSDate() {
        return new Date(this.isValid ? this.ts : NaN);
      }
      // COMPARE
      /**
       * Return the difference between two DateTimes as a Duration.
       * @param {DateTime} otherDateTime - the DateTime to compare this one to
       * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @example
       * var i1 = DateTime.fromISO('1982-05-25T09:45'),
       *     i2 = DateTime.fromISO('1983-10-14T10:30');
       * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
       * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
       * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
       * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
       * @return {Duration}
       */
      diff(otherDateTime, unit = "milliseconds", opts = {}) {
        if (!this.isValid || !otherDateTime.isValid) {
          return Duration2.invalid("created by diffing an invalid DateTime");
        }
        const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
        const units = maybeArray2(unit).map(Duration2.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff(earlier, later, units, durOpts);
        return otherIsLater ? diffed.negate() : diffed;
      }
      /**
       * Return the difference between this DateTime and right now.
       * See {@link DateTime#diff}
       * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @return {Duration}
       */
      diffNow(unit = "milliseconds", opts = {}) {
        return this.diff(_DateTime.now(), unit, opts);
      }
      /**
       * Return an Interval spanning between this DateTime and another DateTime
       * @param {DateTime} otherDateTime - the other end point of the Interval
       * @return {Interval}
       */
      until(otherDateTime) {
        return this.isValid ? Interval2.fromDateTimes(this, otherDateTime) : this;
      }
      /**
       * Return whether this DateTime is in the same unit of time as another DateTime.
       * Higher-order units must also be identical for this function to return `true`.
       * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
       * @param {DateTime} otherDateTime - the other DateTime
       * @param {string} unit - the unit of time to check sameness on
       * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
       * @return {boolean}
       */
      hasSame(otherDateTime, unit) {
        if (!this.isValid)
          return false;
        const inputMs = otherDateTime.valueOf();
        const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
        return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
      }
      /**
       * Equality check
       * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
       * To compare just the millisecond values, use `+dt1 === +dt2`.
       * @param {DateTime} other - the other DateTime
       * @return {boolean}
       */
      equals(other) {
        return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
      }
      /**
       * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
       * platform supports Intl.RelativeTimeFormat. Rounds down by default.
       * @param {Object} options - options that affect the output
       * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
       * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
       * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
       * @param {boolean} [options.round=true] - whether to round the numbers in the output.
       * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
       * @param {string} options.locale - override the locale of this DateTime
       * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
       * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
       * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 da"
       * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
       * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
       * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
       * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
       */
      toRelative(options = {}) {
        if (!this.isValid)
          return null;
        const base = options.base || _DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
        let units = ["years", "months", "days", "hours", "minutes", "seconds"];
        let unit = options.unit;
        if (Array.isArray(options.unit)) {
          units = options.unit;
          unit = void 0;
        }
        return diffRelative2(base, this.plus(padding), {
          ...options,
          numeric: "always",
          units,
          unit
        });
      }
      /**
       * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
       * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
       * @param {Object} options - options that affect the output
       * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
       * @param {string} options.locale - override the locale of this DateTime
       * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
       * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
       * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
       * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""maana"
       * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
       * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
       */
      toRelativeCalendar(options = {}) {
        if (!this.isValid)
          return null;
        return diffRelative2(options.base || _DateTime.fromObject({}, { zone: this.zone }), this, {
          ...options,
          numeric: "auto",
          units: ["years", "months", "days"],
          calendary: true
        });
      }
      /**
       * Return the min of several date times
       * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
       * @return {DateTime} the min DateTime, or undefined if called with no argument
       */
      static min(...dateTimes) {
        if (!dateTimes.every(_DateTime.isDateTime)) {
          throw new InvalidArgumentError2("min requires all arguments be DateTimes");
        }
        return bestBy2(dateTimes, (i) => i.valueOf(), Math.min);
      }
      /**
       * Return the max of several date times
       * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
       * @return {DateTime} the max DateTime, or undefined if called with no argument
       */
      static max(...dateTimes) {
        if (!dateTimes.every(_DateTime.isDateTime)) {
          throw new InvalidArgumentError2("max requires all arguments be DateTimes");
        }
        return bestBy2(dateTimes, (i) => i.valueOf(), Math.max);
      }
      // MISC
      /**
       * Explain how a string would be parsed by fromFormat()
       * @param {string} text - the string to parse
       * @param {string} fmt - the format the string is expected to be in (see description)
       * @param {Object} options - options taken by fromFormat()
       * @return {Object}
       */
      static fromFormatExplain(text2, fmt, options = {}) {
        const { locale = null, numberingSystem = null } = options, localeToUse = Locale2.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        });
        return explainFromTokens2(localeToUse, text2, fmt);
      }
      /**
       * @deprecated use fromFormatExplain instead
       */
      static fromStringExplain(text2, fmt, options = {}) {
        return _DateTime.fromFormatExplain(text2, fmt, options);
      }
      // FORMAT PRESETS
      /**
       * {@link DateTime#toLocaleString} format like 10/14/1983
       * @type {Object}
       */
      static get DATE_SHORT() {
        return DATE_SHORT2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
       * @type {Object}
       */
      static get DATE_MED() {
        return DATE_MED2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
       * @type {Object}
       */
      static get DATE_MED_WITH_WEEKDAY() {
        return DATE_MED_WITH_WEEKDAY2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983'
       * @type {Object}
       */
      static get DATE_FULL() {
        return DATE_FULL2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
       * @type {Object}
       */
      static get DATE_HUGE() {
        return DATE_HUGE2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_SIMPLE() {
        return TIME_SIMPLE2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_SECONDS() {
        return TIME_WITH_SECONDS2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_SHORT_OFFSET() {
        return TIME_WITH_SHORT_OFFSET2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_LONG_OFFSET() {
        return TIME_WITH_LONG_OFFSET2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_SIMPLE() {
        return TIME_24_SIMPLE2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_SECONDS() {
        return TIME_24_WITH_SECONDS2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_SHORT_OFFSET() {
        return TIME_24_WITH_SHORT_OFFSET2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_LONG_OFFSET() {
        return TIME_24_WITH_LONG_OFFSET2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_SHORT() {
        return DATETIME_SHORT2;
      }
      /**
       * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_SHORT_WITH_SECONDS() {
        return DATETIME_SHORT_WITH_SECONDS2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED() {
        return DATETIME_MED2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED_WITH_SECONDS() {
        return DATETIME_MED_WITH_SECONDS2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED_WITH_WEEKDAY() {
        return DATETIME_MED_WITH_WEEKDAY2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_FULL() {
        return DATETIME_FULL2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_FULL_WITH_SECONDS() {
        return DATETIME_FULL_WITH_SECONDS2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_HUGE() {
        return DATETIME_HUGE2;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_HUGE_WITH_SECONDS() {
        return DATETIME_HUGE_WITH_SECONDS2;
      }
    };
    function friendlyDateTime2(dateTimeish) {
      if (DateTime2.isDateTime(dateTimeish)) {
        return dateTimeish;
      } else if (dateTimeish && dateTimeish.valueOf && isNumber2(dateTimeish.valueOf())) {
        return DateTime2.fromJSDate(dateTimeish);
      } else if (dateTimeish && typeof dateTimeish === "object") {
        return DateTime2.fromObject(dateTimeish);
      } else {
        throw new InvalidArgumentError2(
          `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
        );
      }
    }
    var DEFAULT_QUERY_SETTINGS = {
      renderNullAs: "\\-",
      taskCompletionTracking: false,
      taskCompletionUseEmojiShorthand: false,
      taskCompletionText: "completion",
      taskCompletionDateFormat: "yyyy-MM-dd",
      recursiveSubTaskCompletion: false,
      warnOnEmptyResult: true,
      refreshEnabled: true,
      refreshInterval: 2500,
      defaultDateFormat: "MMMM dd, yyyy",
      defaultDateTimeFormat: "h:mm a - MMMM dd, yyyy",
      maxRecursiveRenderDepth: 4,
      tableIdColumnName: "File",
      tableGroupColumnName: "Group",
      showResultCount: true
    };
    var DEFAULT_EXPORT_SETTINGS = {
      allowHtml: true
    };
    ({
      ...DEFAULT_QUERY_SETTINGS,
      ...DEFAULT_EXPORT_SETTINGS,
      ...{
        inlineQueryPrefix: "=",
        inlineJsQueryPrefix: "$=",
        inlineQueriesInCodeblocks: true,
        enableInlineDataview: true,
        enableDataviewJs: false,
        enableInlineDataviewJs: false,
        prettyRenderInlineFields: true,
        prettyRenderInlineFieldsInLivePreview: true,
        dataviewJsKeyword: "dataviewjs"
      }
    });
    var Success = class _Success {
      constructor(value) {
        this.value = value;
        this.successful = true;
      }
      map(f) {
        return new _Success(f(this.value));
      }
      flatMap(f) {
        return f(this.value);
      }
      mapErr(f) {
        return this;
      }
      bimap(succ2, _fail) {
        return this.map(succ2);
      }
      orElse(_value) {
        return this.value;
      }
      cast() {
        return this;
      }
      orElseThrow(_message) {
        return this.value;
      }
    };
    var Failure = class _Failure {
      constructor(error) {
        this.error = error;
        this.successful = false;
      }
      map(_f) {
        return this;
      }
      flatMap(_f) {
        return this;
      }
      mapErr(f) {
        return new _Failure(f(this.error));
      }
      bimap(_succ, fail2) {
        return this.mapErr(fail2);
      }
      orElse(value) {
        return value;
      }
      cast() {
        return this;
      }
      orElseThrow(message) {
        if (message)
          throw new Error(message(this.error));
        else
          throw new Error("" + this.error);
      }
    };
    var Result;
    (function(Result2) {
      function success(value) {
        return new Success(value);
      }
      Result2.success = success;
      function failure(error) {
        return new Failure(error);
      }
      Result2.failure = failure;
      function flatMap2(first, second, f) {
        if (first.successful) {
          if (second.successful)
            return f(first.value, second.value);
          else
            return failure(second.error);
        } else {
          return failure(first.error);
        }
      }
      Result2.flatMap2 = flatMap2;
      function map2(first, second, f) {
        return flatMap2(first, second, (a, b) => success(f(a, b)));
      }
      Result2.map2 = map2;
    })(Result || (Result = {}));
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    var parsimmon_umd_min = { exports: {} };
    parsimmon_umd_min.exports;
    (function(module3, exports2) {
      !function(n3, t) {
        module3.exports = t();
      }("undefined" != typeof self ? self : commonjsGlobal, function() {
        return function(n3) {
          var t = {};
          function r(e) {
            if (t[e])
              return t[e].exports;
            var u = t[e] = { i: e, l: false, exports: {} };
            return n3[e].call(u.exports, u, u.exports, r), u.l = true, u.exports;
          }
          return r.m = n3, r.c = t, r.d = function(n4, t2, e) {
            r.o(n4, t2) || Object.defineProperty(n4, t2, { configurable: false, enumerable: true, get: e });
          }, r.r = function(n4) {
            Object.defineProperty(n4, "__esModule", { value: true });
          }, r.n = function(n4) {
            var t2 = n4 && n4.__esModule ? function() {
              return n4.default;
            } : function() {
              return n4;
            };
            return r.d(t2, "a", t2), t2;
          }, r.o = function(n4, t2) {
            return Object.prototype.hasOwnProperty.call(n4, t2);
          }, r.p = "", r(r.s = 0);
        }([function(n3, t, r) {
          function e(n4) {
            if (!(this instanceof e))
              return new e(n4);
            this._ = n4;
          }
          var u = e.prototype;
          function o(n4, t2) {
            for (var r2 = 0; r2 < n4; r2++)
              t2(r2);
          }
          function i(n4, t2, r2) {
            return function(n5, t3) {
              o(t3.length, function(r3) {
                n5(t3[r3], r3, t3);
              });
            }(function(r3, e2, u2) {
              t2 = n4(t2, r3, e2, u2);
            }, r2), t2;
          }
          function a(n4, t2) {
            return i(function(t3, r2, e2, u2) {
              return t3.concat([n4(r2, e2, u2)]);
            }, [], t2);
          }
          function f(n4, t2) {
            var r2 = { v: 0, buf: t2 };
            return o(n4, function() {
              var n5;
              r2 = { v: r2.v << 1 | (n5 = r2.buf, n5[0] >> 7), buf: function(n6) {
                var t3 = i(function(n7, t4, r3, e2) {
                  return n7.concat(r3 === e2.length - 1 ? Buffer.from([t4, 0]).readUInt16BE(0) : e2.readUInt16BE(r3));
                }, [], n6);
                return Buffer.from(a(function(n7) {
                  return (n7 << 1 & 65535) >> 8;
                }, t3));
              }(r2.buf) };
            }), r2;
          }
          function c() {
            return "undefined" != typeof Buffer;
          }
          function s3() {
            if (!c())
              throw new Error("Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.");
          }
          function l3(n4) {
            s3();
            var t2 = i(function(n5, t3) {
              return n5 + t3;
            }, 0, n4);
            if (t2 % 8 != 0)
              throw new Error("The bits [" + n4.join(", ") + "] add up to " + t2 + " which is not an even number of bytes; the total should be divisible by 8");
            var r2, u2 = t2 / 8, o2 = (r2 = function(n5) {
              return n5 > 48;
            }, i(function(n5, t3) {
              return n5 || (r2(t3) ? t3 : n5);
            }, null, n4));
            if (o2)
              throw new Error(o2 + " bit range requested exceeds 48 bit (6 byte) Number max.");
            return new e(function(t3, r3) {
              var e2 = u2 + r3;
              return e2 > t3.length ? x(r3, u2.toString() + " bytes") : b(e2, i(function(n5, t4) {
                var r4 = f(t4, n5.buf);
                return { coll: n5.coll.concat(r4.v), buf: r4.buf };
              }, { coll: [], buf: t3.slice(r3, e2) }, n4).coll);
            });
          }
          function h(n4, t2) {
            return new e(function(r2, e2) {
              return s3(), e2 + t2 > r2.length ? x(e2, t2 + " bytes for " + n4) : b(e2 + t2, r2.slice(e2, e2 + t2));
            });
          }
          function p(n4, t2) {
            if ("number" != typeof (r2 = t2) || Math.floor(r2) !== r2 || t2 < 0 || t2 > 6)
              throw new Error(n4 + " requires integer length in range [0, 6].");
            var r2;
          }
          function d(n4) {
            return p("uintBE", n4), h("uintBE(" + n4 + ")", n4).map(function(t2) {
              return t2.readUIntBE(0, n4);
            });
          }
          function v(n4) {
            return p("uintLE", n4), h("uintLE(" + n4 + ")", n4).map(function(t2) {
              return t2.readUIntLE(0, n4);
            });
          }
          function g(n4) {
            return p("intBE", n4), h("intBE(" + n4 + ")", n4).map(function(t2) {
              return t2.readIntBE(0, n4);
            });
          }
          function m(n4) {
            return p("intLE", n4), h("intLE(" + n4 + ")", n4).map(function(t2) {
              return t2.readIntLE(0, n4);
            });
          }
          function y(n4) {
            return n4 instanceof e;
          }
          function E(n4) {
            return "[object Array]" === {}.toString.call(n4);
          }
          function w(n4) {
            return c() && Buffer.isBuffer(n4);
          }
          function b(n4, t2) {
            return { status: true, index: n4, value: t2, furthest: -1, expected: [] };
          }
          function x(n4, t2) {
            return E(t2) || (t2 = [t2]), { status: false, index: -1, value: null, furthest: n4, expected: t2 };
          }
          function B(n4, t2) {
            if (!t2)
              return n4;
            if (n4.furthest > t2.furthest)
              return n4;
            var r2 = n4.furthest === t2.furthest ? function(n5, t3) {
              if (function() {
                if (void 0 !== e._supportsSet)
                  return e._supportsSet;
                var n6 = "undefined" != typeof Set;
                return e._supportsSet = n6, n6;
              }() && Array.from) {
                for (var r3 = new Set(n5), u2 = 0; u2 < t3.length; u2++)
                  r3.add(t3[u2]);
                var o2 = Array.from(r3);
                return o2.sort(), o2;
              }
              for (var i2 = {}, a2 = 0; a2 < n5.length; a2++)
                i2[n5[a2]] = true;
              for (var f2 = 0; f2 < t3.length; f2++)
                i2[t3[f2]] = true;
              var c2 = [];
              for (var s4 in i2)
                ({}).hasOwnProperty.call(i2, s4) && c2.push(s4);
              return c2.sort(), c2;
            }(n4.expected, t2.expected) : t2.expected;
            return { status: n4.status, index: n4.index, value: n4.value, furthest: t2.furthest, expected: r2 };
          }
          var j = {};
          function S(n4, t2) {
            if (w(n4))
              return { offset: t2, line: -1, column: -1 };
            n4 in j || (j[n4] = {});
            for (var r2 = j[n4], e2 = 0, u2 = 0, o2 = 0, i2 = t2; i2 >= 0; ) {
              if (i2 in r2) {
                e2 = r2[i2].line, 0 === o2 && (o2 = r2[i2].lineStart);
                break;
              }
              ("\n" === n4.charAt(i2) || "\r" === n4.charAt(i2) && "\n" !== n4.charAt(i2 + 1)) && (u2++, 0 === o2 && (o2 = i2 + 1)), i2--;
            }
            var a2 = e2 + u2, f2 = t2 - o2;
            return r2[t2] = { line: a2, lineStart: o2 }, { offset: t2, line: a2 + 1, column: f2 + 1 };
          }
          function _(n4) {
            if (!y(n4))
              throw new Error("not a parser: " + n4);
          }
          function L(n4, t2) {
            return "string" == typeof n4 ? n4.charAt(t2) : n4[t2];
          }
          function O(n4) {
            if ("number" != typeof n4)
              throw new Error("not a number: " + n4);
          }
          function k(n4) {
            if ("function" != typeof n4)
              throw new Error("not a function: " + n4);
          }
          function P(n4) {
            if ("string" != typeof n4)
              throw new Error("not a string: " + n4);
          }
          var q = 2, A = 3, I = 8, F = 5 * I, M = 4 * I, z = "  ";
          function R(n4, t2) {
            return new Array(t2 + 1).join(n4);
          }
          function U(n4, t2, r2) {
            var e2 = t2 - n4.length;
            return e2 <= 0 ? n4 : R(r2, e2) + n4;
          }
          function W(n4, t2, r2, e2) {
            return { from: n4 - t2 > 0 ? n4 - t2 : 0, to: n4 + r2 > e2 ? e2 : n4 + r2 };
          }
          function D(n4, t2) {
            var r2, e2, u2, o2, f2, c2 = t2.index, s4 = c2.offset, l4 = 1;
            if (s4 === n4.length)
              return "Got the end of the input";
            if (w(n4)) {
              var h2 = s4 - s4 % I, p2 = s4 - h2, d2 = W(h2, F, M + I, n4.length), v2 = a(function(n5) {
                return a(function(n6) {
                  return U(n6.toString(16), 2, "0");
                }, n5);
              }, function(n5, t3) {
                var r3 = n5.length, e3 = [], u3 = 0;
                if (r3 <= t3)
                  return [n5.slice()];
                for (var o3 = 0; o3 < r3; o3++)
                  e3[u3] || e3.push([]), e3[u3].push(n5[o3]), (o3 + 1) % t3 == 0 && u3++;
                return e3;
              }(n4.slice(d2.from, d2.to).toJSON().data, I));
              o2 = function(n5) {
                return 0 === n5.from && 1 === n5.to ? { from: n5.from, to: n5.to } : { from: n5.from / I, to: Math.floor(n5.to / I) };
              }(d2), e2 = h2 / I, r2 = 3 * p2, p2 >= 4 && (r2 += 1), l4 = 2, u2 = a(function(n5) {
                return n5.length <= 4 ? n5.join(" ") : n5.slice(0, 4).join(" ") + "  " + n5.slice(4).join(" ");
              }, v2), (f2 = (8 * (o2.to > 0 ? o2.to - 1 : o2.to)).toString(16).length) < 2 && (f2 = 2);
            } else {
              var g2 = n4.split(/\r\n|[\n\r\u2028\u2029]/);
              r2 = c2.column - 1, e2 = c2.line - 1, o2 = W(e2, q, A, g2.length), u2 = g2.slice(o2.from, o2.to), f2 = o2.to.toString().length;
            }
            var m2 = e2 - o2.from;
            return w(n4) && (f2 = (8 * (o2.to > 0 ? o2.to - 1 : o2.to)).toString(16).length) < 2 && (f2 = 2), i(function(t3, e3, u3) {
              var i2, a2 = u3 === m2, c3 = a2 ? "> " : z;
              return i2 = w(n4) ? U((8 * (o2.from + u3)).toString(16), f2, "0") : U((o2.from + u3 + 1).toString(), f2, " "), [].concat(t3, [c3 + i2 + " | " + e3], a2 ? [z + R(" ", f2) + " | " + U("", r2, " ") + R("^", l4)] : []);
            }, [], u2).join("\n");
          }
          function N(n4, t2) {
            return ["\n", "-- PARSING FAILED " + R("-", 50), "\n\n", D(n4, t2), "\n\n", (r2 = t2.expected, 1 === r2.length ? "Expected:\n\n" + r2[0] : "Expected one of the following: \n\n" + r2.join(", ")), "\n"].join("");
            var r2;
          }
          function G(n4) {
            return void 0 !== n4.flags ? n4.flags : [n4.global ? "g" : "", n4.ignoreCase ? "i" : "", n4.multiline ? "m" : "", n4.unicode ? "u" : "", n4.sticky ? "y" : ""].join("");
          }
          function C() {
            for (var n4 = [].slice.call(arguments), t2 = n4.length, r2 = 0; r2 < t2; r2 += 1)
              _(n4[r2]);
            return e(function(r3, e2) {
              for (var u2, o2 = new Array(t2), i2 = 0; i2 < t2; i2 += 1) {
                if (!(u2 = B(n4[i2]._(r3, e2), u2)).status)
                  return u2;
                o2[i2] = u2.value, e2 = u2.index;
              }
              return B(b(e2, o2), u2);
            });
          }
          function J() {
            var n4 = [].slice.call(arguments);
            if (0 === n4.length)
              throw new Error("seqMap needs at least one argument");
            var t2 = n4.pop();
            return k(t2), C.apply(null, n4).map(function(n5) {
              return t2.apply(null, n5);
            });
          }
          function T() {
            var n4 = [].slice.call(arguments), t2 = n4.length;
            if (0 === t2)
              return Y("zero alternates");
            for (var r2 = 0; r2 < t2; r2 += 1)
              _(n4[r2]);
            return e(function(t3, r3) {
              for (var e2, u2 = 0; u2 < n4.length; u2 += 1)
                if ((e2 = B(n4[u2]._(t3, r3), e2)).status)
                  return e2;
              return e2;
            });
          }
          function V(n4, t2) {
            return H(n4, t2).or(X([]));
          }
          function H(n4, t2) {
            return _(n4), _(t2), J(n4, t2.then(n4).many(), function(n5, t3) {
              return [n5].concat(t3);
            });
          }
          function K(n4) {
            P(n4);
            var t2 = "'" + n4 + "'";
            return e(function(r2, e2) {
              var u2 = e2 + n4.length, o2 = r2.slice(e2, u2);
              return o2 === n4 ? b(u2, o2) : x(e2, t2);
            });
          }
          function Q(n4, t2) {
            !function(n5) {
              if (!(n5 instanceof RegExp))
                throw new Error("not a regexp: " + n5);
              for (var t3 = G(n5), r3 = 0; r3 < t3.length; r3++) {
                var e2 = t3.charAt(r3);
                if ("i" !== e2 && "m" !== e2 && "u" !== e2 && "s" !== e2)
                  throw new Error('unsupported regexp flag "' + e2 + '": ' + n5);
              }
            }(n4), arguments.length >= 2 ? O(t2) : t2 = 0;
            var r2 = function(n5) {
              return RegExp("^(?:" + n5.source + ")", G(n5));
            }(n4), u2 = "" + n4;
            return e(function(n5, e2) {
              var o2 = r2.exec(n5.slice(e2));
              if (o2) {
                if (0 <= t2 && t2 <= o2.length) {
                  var i2 = o2[0], a2 = o2[t2];
                  return b(e2 + i2.length, a2);
                }
                return x(e2, "valid match group (0 to " + o2.length + ") in " + u2);
              }
              return x(e2, u2);
            });
          }
          function X(n4) {
            return e(function(t2, r2) {
              return b(r2, n4);
            });
          }
          function Y(n4) {
            return e(function(t2, r2) {
              return x(r2, n4);
            });
          }
          function Z(n4) {
            if (y(n4))
              return e(function(t2, r2) {
                var e2 = n4._(t2, r2);
                return e2.index = r2, e2.value = "", e2;
              });
            if ("string" == typeof n4)
              return Z(K(n4));
            if (n4 instanceof RegExp)
              return Z(Q(n4));
            throw new Error("not a string, regexp, or parser: " + n4);
          }
          function $(n4) {
            return _(n4), e(function(t2, r2) {
              var e2 = n4._(t2, r2), u2 = t2.slice(r2, e2.index);
              return e2.status ? x(r2, 'not "' + u2 + '"') : b(r2, null);
            });
          }
          function nn(n4) {
            return k(n4), e(function(t2, r2) {
              var e2 = L(t2, r2);
              return r2 < t2.length && n4(e2) ? b(r2 + 1, e2) : x(r2, "a character/byte matching " + n4);
            });
          }
          function tn(n4, t2) {
            arguments.length < 2 && (t2 = n4, n4 = void 0);
            var r2 = e(function(n5, e2) {
              return r2._ = t2()._, r2._(n5, e2);
            });
            return n4 ? r2.desc(n4) : r2;
          }
          function rn() {
            return Y("fantasy-land/empty");
          }
          u.parse = function(n4) {
            if ("string" != typeof n4 && !w(n4))
              throw new Error(".parse must be called with a string or Buffer as its argument");
            var t2, r2 = this.skip(an)._(n4, 0);
            return t2 = r2.status ? { status: true, value: r2.value } : { status: false, index: S(n4, r2.furthest), expected: r2.expected }, delete j[n4], t2;
          }, u.tryParse = function(n4) {
            var t2 = this.parse(n4);
            if (t2.status)
              return t2.value;
            var r2 = N(n4, t2), e2 = new Error(r2);
            throw e2.type = "ParsimmonError", e2.result = t2, e2;
          }, u.assert = function(n4, t2) {
            return this.chain(function(r2) {
              return n4(r2) ? X(r2) : Y(t2);
            });
          }, u.or = function(n4) {
            return T(this, n4);
          }, u.trim = function(n4) {
            return this.wrap(n4, n4);
          }, u.wrap = function(n4, t2) {
            return J(n4, this, t2, function(n5, t3) {
              return t3;
            });
          }, u.thru = function(n4) {
            return n4(this);
          }, u.then = function(n4) {
            return _(n4), C(this, n4).map(function(n5) {
              return n5[1];
            });
          }, u.many = function() {
            var n4 = this;
            return e(function(t2, r2) {
              for (var e2 = [], u2 = void 0; ; ) {
                if (!(u2 = B(n4._(t2, r2), u2)).status)
                  return B(b(r2, e2), u2);
                if (r2 === u2.index)
                  throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause");
                r2 = u2.index, e2.push(u2.value);
              }
            });
          }, u.tieWith = function(n4) {
            return P(n4), this.map(function(t2) {
              if (function(n5) {
                if (!E(n5))
                  throw new Error("not an array: " + n5);
              }(t2), t2.length) {
                P(t2[0]);
                for (var r2 = t2[0], e2 = 1; e2 < t2.length; e2++)
                  P(t2[e2]), r2 += n4 + t2[e2];
                return r2;
              }
              return "";
            });
          }, u.tie = function() {
            return this.tieWith("");
          }, u.times = function(n4, t2) {
            var r2 = this;
            return arguments.length < 2 && (t2 = n4), O(n4), O(t2), e(function(e2, u2) {
              for (var o2 = [], i2 = void 0, a2 = void 0, f2 = 0; f2 < n4; f2 += 1) {
                if (a2 = B(i2 = r2._(e2, u2), a2), !i2.status)
                  return a2;
                u2 = i2.index, o2.push(i2.value);
              }
              for (; f2 < t2 && (a2 = B(i2 = r2._(e2, u2), a2), i2.status); f2 += 1)
                u2 = i2.index, o2.push(i2.value);
              return B(b(u2, o2), a2);
            });
          }, u.result = function(n4) {
            return this.map(function() {
              return n4;
            });
          }, u.atMost = function(n4) {
            return this.times(0, n4);
          }, u.atLeast = function(n4) {
            return J(this.times(n4), this.many(), function(n5, t2) {
              return n5.concat(t2);
            });
          }, u.map = function(n4) {
            k(n4);
            var t2 = this;
            return e(function(r2, e2) {
              var u2 = t2._(r2, e2);
              return u2.status ? B(b(u2.index, n4(u2.value)), u2) : u2;
            });
          }, u.contramap = function(n4) {
            k(n4);
            var t2 = this;
            return e(function(r2, e2) {
              var u2 = t2.parse(n4(r2.slice(e2)));
              return u2.status ? b(e2 + r2.length, u2.value) : u2;
            });
          }, u.promap = function(n4, t2) {
            return k(n4), k(t2), this.contramap(n4).map(t2);
          }, u.skip = function(n4) {
            return C(this, n4).map(function(n5) {
              return n5[0];
            });
          }, u.mark = function() {
            return J(en, this, en, function(n4, t2, r2) {
              return { start: n4, value: t2, end: r2 };
            });
          }, u.node = function(n4) {
            return J(en, this, en, function(t2, r2, e2) {
              return { name: n4, value: r2, start: t2, end: e2 };
            });
          }, u.sepBy = function(n4) {
            return V(this, n4);
          }, u.sepBy1 = function(n4) {
            return H(this, n4);
          }, u.lookahead = function(n4) {
            return this.skip(Z(n4));
          }, u.notFollowedBy = function(n4) {
            return this.skip($(n4));
          }, u.desc = function(n4) {
            E(n4) || (n4 = [n4]);
            var t2 = this;
            return e(function(r2, e2) {
              var u2 = t2._(r2, e2);
              return u2.status || (u2.expected = n4), u2;
            });
          }, u.fallback = function(n4) {
            return this.or(X(n4));
          }, u.ap = function(n4) {
            return J(n4, this, function(n5, t2) {
              return n5(t2);
            });
          }, u.chain = function(n4) {
            var t2 = this;
            return e(function(r2, e2) {
              var u2 = t2._(r2, e2);
              return u2.status ? B(n4(u2.value)._(r2, u2.index), u2) : u2;
            });
          }, u.concat = u.or, u.empty = rn, u.of = X, u["fantasy-land/ap"] = u.ap, u["fantasy-land/chain"] = u.chain, u["fantasy-land/concat"] = u.concat, u["fantasy-land/empty"] = u.empty, u["fantasy-land/of"] = u.of, u["fantasy-land/map"] = u.map;
          var en = e(function(n4, t2) {
            return b(t2, S(n4, t2));
          }), un = e(function(n4, t2) {
            return t2 >= n4.length ? x(t2, "any character/byte") : b(t2 + 1, L(n4, t2));
          }), on = e(function(n4, t2) {
            return b(n4.length, n4.slice(t2));
          }), an = e(function(n4, t2) {
            return t2 < n4.length ? x(t2, "EOF") : b(t2, null);
          }), fn = Q(/[0-9]/).desc("a digit"), cn = Q(/[0-9]*/).desc("optional digits"), sn = Q(/[a-z]/i).desc("a letter"), ln = Q(/[a-z]*/i).desc("optional letters"), hn = Q(/\s*/).desc("optional whitespace"), pn = Q(/\s+/).desc("whitespace"), dn = K("\r"), vn = K("\n"), gn = K("\r\n"), mn = T(gn, vn, dn).desc("newline"), yn = T(mn, an);
          e.all = on, e.alt = T, e.any = un, e.cr = dn, e.createLanguage = function(n4) {
            var t2 = {};
            for (var r2 in n4)
              ({}).hasOwnProperty.call(n4, r2) && function(r3) {
                t2[r3] = tn(function() {
                  return n4[r3](t2);
                });
              }(r2);
            return t2;
          }, e.crlf = gn, e.custom = function(n4) {
            return e(n4(b, x));
          }, e.digit = fn, e.digits = cn, e.empty = rn, e.end = yn, e.eof = an, e.fail = Y, e.formatError = N, e.index = en, e.isParser = y, e.lazy = tn, e.letter = sn, e.letters = ln, e.lf = vn, e.lookahead = Z, e.makeFailure = x, e.makeSuccess = b, e.newline = mn, e.noneOf = function(n4) {
            return nn(function(t2) {
              return n4.indexOf(t2) < 0;
            }).desc("none of '" + n4 + "'");
          }, e.notFollowedBy = $, e.of = X, e.oneOf = function(n4) {
            for (var t2 = n4.split(""), r2 = 0; r2 < t2.length; r2++)
              t2[r2] = "'" + t2[r2] + "'";
            return nn(function(t3) {
              return n4.indexOf(t3) >= 0;
            }).desc(t2);
          }, e.optWhitespace = hn, e.Parser = e, e.range = function(n4, t2) {
            return nn(function(r2) {
              return n4 <= r2 && r2 <= t2;
            }).desc(n4 + "-" + t2);
          }, e.regex = Q, e.regexp = Q, e.sepBy = V, e.sepBy1 = H, e.seq = C, e.seqMap = J, e.seqObj = function() {
            for (var n4, t2 = {}, r2 = 0, u2 = (n4 = arguments, Array.prototype.slice.call(n4)), o2 = u2.length, i2 = 0; i2 < o2; i2 += 1) {
              var a2 = u2[i2];
              if (!y(a2)) {
                if (E(a2) && 2 === a2.length && "string" == typeof a2[0] && y(a2[1])) {
                  var f2 = a2[0];
                  if (Object.prototype.hasOwnProperty.call(t2, f2))
                    throw new Error("seqObj: duplicate key " + f2);
                  t2[f2] = true, r2++;
                  continue;
                }
                throw new Error("seqObj arguments must be parsers or [string, parser] array pairs.");
              }
            }
            if (0 === r2)
              throw new Error("seqObj expects at least one named parser, found zero");
            return e(function(n5, t3) {
              for (var r3, e2 = {}, i3 = 0; i3 < o2; i3 += 1) {
                var a3, f3;
                if (E(u2[i3]) ? (a3 = u2[i3][0], f3 = u2[i3][1]) : (a3 = null, f3 = u2[i3]), !(r3 = B(f3._(n5, t3), r3)).status)
                  return r3;
                a3 && (e2[a3] = r3.value), t3 = r3.index;
              }
              return B(b(t3, e2), r3);
            });
          }, e.string = K, e.succeed = X, e.takeWhile = function(n4) {
            return k(n4), e(function(t2, r2) {
              for (var e2 = r2; e2 < t2.length && n4(L(t2, e2)); )
                e2++;
              return b(e2, t2.slice(r2, e2));
            });
          }, e.test = nn, e.whitespace = pn, e["fantasy-land/empty"] = rn, e["fantasy-land/of"] = X, e.Binary = { bitSeq: l3, bitSeqObj: function(n4) {
            s3();
            var t2 = {}, r2 = 0, e2 = a(function(n5) {
              if (E(n5)) {
                var e3 = n5;
                if (2 !== e3.length)
                  throw new Error("[" + e3.join(", ") + "] should be length 2, got length " + e3.length);
                if (P(e3[0]), O(e3[1]), Object.prototype.hasOwnProperty.call(t2, e3[0]))
                  throw new Error("duplicate key in bitSeqObj: " + e3[0]);
                return t2[e3[0]] = true, r2++, e3;
              }
              return O(n5), [null, n5];
            }, n4);
            if (r2 < 1)
              throw new Error("bitSeqObj expects at least one named pair, got [" + n4.join(", ") + "]");
            var u2 = a(function(n5) {
              return n5[0];
            }, e2);
            return l3(a(function(n5) {
              return n5[1];
            }, e2)).map(function(n5) {
              return i(function(n6, t3) {
                return null !== t3[0] && (n6[t3[0]] = t3[1]), n6;
              }, {}, a(function(t3, r3) {
                return [t3, n5[r3]];
              }, u2));
            });
          }, byte: function(n4) {
            if (s3(), O(n4), n4 > 255)
              throw new Error("Value specified to byte constructor (" + n4 + "=0x" + n4.toString(16) + ") is larger in value than a single byte.");
            var t2 = (n4 > 15 ? "0x" : "0x0") + n4.toString(16);
            return e(function(r2, e2) {
              var u2 = L(r2, e2);
              return u2 === n4 ? b(e2 + 1, u2) : x(e2, t2);
            });
          }, buffer: function(n4) {
            return h("buffer", n4).map(function(n5) {
              return Buffer.from(n5);
            });
          }, encodedString: function(n4, t2) {
            return h("string", t2).map(function(t3) {
              return t3.toString(n4);
            });
          }, uintBE: d, uint8BE: d(1), uint16BE: d(2), uint32BE: d(4), uintLE: v, uint8LE: v(1), uint16LE: v(2), uint32LE: v(4), intBE: g, int8BE: g(1), int16BE: g(2), int32BE: g(4), intLE: m, int8LE: m(1), int16LE: m(2), int32LE: m(4), floatBE: h("floatBE", 4).map(function(n4) {
            return n4.readFloatBE(0);
          }), floatLE: h("floatLE", 4).map(function(n4) {
            return n4.readFloatLE(0);
          }), doubleBE: h("doubleBE", 8).map(function(n4) {
            return n4.readDoubleBE(0);
          }), doubleLE: h("doubleLE", 8).map(function(n4) {
            return n4.readDoubleLE(0);
          }) }, n3.exports = e;
        }]);
      });
    })(parsimmon_umd_min, parsimmon_umd_min.exports);
    var parsimmon_umd_minExports = parsimmon_umd_min.exports;
    var emojiRegex = () => {
      return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC3\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC08\uDC26](?:\u200D\u2B1B)?|[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
    };
    function normalizeDuration(dur) {
      if (dur === void 0 || dur === null)
        return dur;
      return dur.shiftToAll().normalize();
    }
    function getFileTitle(path4) {
      if (path4.includes("/"))
        path4 = path4.substring(path4.lastIndexOf("/") + 1);
      if (path4.endsWith(".md"))
        path4 = path4.substring(0, path4.length - 3);
      return path4;
    }
    parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regex(new RegExp(emojiRegex(), "")), parsimmon_umd_minExports.regex(/[0-9\p{Letter}_-]+/u).map((str) => str.toLocaleLowerCase()), parsimmon_umd_minExports.whitespace.map((_) => "-"), parsimmon_umd_minExports.any.map((_) => "")).many().map((result) => result.join(""));
    var HEADER_CANONICALIZER = parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regex(new RegExp(emojiRegex(), "")), parsimmon_umd_minExports.regex(/[0-9\p{Letter}_-]+/u), parsimmon_umd_minExports.whitespace.map((_) => " "), parsimmon_umd_minExports.any.map((_) => " ")).many().map((result) => {
      return result.join("").split(/\s+/).join(" ").trim();
    });
    function normalizeHeaderForLink(header) {
      return HEADER_CANONICALIZER.tryParse(header);
    }
    function renderMinimalDuration(dur) {
      dur = normalizeDuration(dur);
      dur = Duration2.fromObject(Object.fromEntries(Object.entries(dur.toObject()).filter(([, quantity]) => quantity != 0)));
      return dur.toHuman();
    }
    var Values;
    (function(Values2) {
      function toString(field, setting = DEFAULT_QUERY_SETTINGS, recursive = false) {
        let wrapped = wrapValue(field);
        if (!wrapped)
          return setting.renderNullAs;
        switch (wrapped.type) {
          case "null":
            return setting.renderNullAs;
          case "string":
            return wrapped.value;
          case "number":
          case "boolean":
            return "" + wrapped.value;
          case "html":
            return wrapped.value.outerHTML;
          case "widget":
            return wrapped.value.markdown();
          case "link":
            return wrapped.value.markdown();
          case "function":
            return "<function>";
          case "array":
            let result = "";
            if (recursive)
              result += "[";
            result += wrapped.value.map((f) => toString(f, setting, true)).join(", ");
            if (recursive)
              result += "]";
            return result;
          case "object":
            return "{ " + Object.entries(wrapped.value).map((e) => e[0] + ": " + toString(e[1], setting, true)).join(", ") + " }";
          case "date":
            if (wrapped.value.second == 0 && wrapped.value.hour == 0 && wrapped.value.minute == 0) {
              return wrapped.value.toFormat(setting.defaultDateFormat);
            }
            return wrapped.value.toFormat(setting.defaultDateTimeFormat);
          case "duration":
            return renderMinimalDuration(wrapped.value);
        }
      }
      Values2.toString = toString;
      function wrapValue(val) {
        if (isNull(val))
          return { type: "null", value: val };
        else if (isNumber3(val))
          return { type: "number", value: val };
        else if (isString3(val))
          return { type: "string", value: val };
        else if (isBoolean(val))
          return { type: "boolean", value: val };
        else if (isDuration(val))
          return { type: "duration", value: val };
        else if (isDate3(val))
          return { type: "date", value: val };
        else if (isWidget(val))
          return { type: "widget", value: val };
        else if (isArray(val))
          return { type: "array", value: val };
        else if (isLink(val))
          return { type: "link", value: val };
        else if (isFunction(val))
          return { type: "function", value: val };
        else if (isHtml(val))
          return { type: "html", value: val };
        else if (isObject(val))
          return { type: "object", value: val };
        else
          return void 0;
      }
      Values2.wrapValue = wrapValue;
      function mapLeaves(val, func) {
        if (isObject(val)) {
          let result = {};
          for (let [key, value] of Object.entries(val))
            result[key] = mapLeaves(value, func);
          return result;
        } else if (isArray(val)) {
          let result = [];
          for (let value of val)
            result.push(mapLeaves(value, func));
          return result;
        } else {
          return func(val);
        }
      }
      Values2.mapLeaves = mapLeaves;
      function compareValue(val1, val2, linkNormalizer) {
        var _a, _b;
        if (val1 === void 0)
          val1 = null;
        if (val2 === void 0)
          val2 = null;
        if (val1 === null && val2 === null)
          return 0;
        else if (val1 === null)
          return -1;
        else if (val2 === null)
          return 1;
        let wrap1 = wrapValue(val1);
        let wrap2 = wrapValue(val2);
        if (wrap1 === void 0 && wrap2 === void 0)
          return 0;
        else if (wrap1 === void 0)
          return -1;
        else if (wrap2 === void 0)
          return 1;
        if (wrap1.type != wrap2.type)
          return wrap1.type.localeCompare(wrap2.type);
        if (wrap1.value === wrap2.value)
          return 0;
        switch (wrap1.type) {
          case "string":
            return wrap1.value.localeCompare(wrap2.value);
          case "number":
            if (wrap1.value < wrap2.value)
              return -1;
            else if (wrap1.value == wrap2.value)
              return 0;
            return 1;
          case "null":
            return 0;
          case "boolean":
            if (wrap1.value == wrap2.value)
              return 0;
            else
              return wrap1.value ? 1 : -1;
          case "link":
            let link1 = wrap1.value;
            let link2 = wrap2.value;
            let normalize = linkNormalizer !== null && linkNormalizer !== void 0 ? linkNormalizer : (x) => x;
            let pathCompare = normalize(link1.path).localeCompare(normalize(link2.path));
            if (pathCompare != 0)
              return pathCompare;
            let typeCompare = link1.type.localeCompare(link2.type);
            if (typeCompare != 0)
              return typeCompare;
            if (link1.subpath && !link2.subpath)
              return 1;
            if (!link1.subpath && link2.subpath)
              return -1;
            if (!link1.subpath && !link2.subpath)
              return 0;
            return ((_a = link1.subpath) !== null && _a !== void 0 ? _a : "").localeCompare((_b = link2.subpath) !== null && _b !== void 0 ? _b : "");
          case "date":
            return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
          case "duration":
            return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
          case "array":
            let f1 = wrap1.value;
            let f2 = wrap2.value;
            for (let index = 0; index < Math.min(f1.length, f2.length); index++) {
              let comp = compareValue(f1[index], f2[index]);
              if (comp != 0)
                return comp;
            }
            return f1.length - f2.length;
          case "object":
            let o1 = wrap1.value;
            let o2 = wrap2.value;
            let k1 = Array.from(Object.keys(o1));
            let k2 = Array.from(Object.keys(o2));
            k1.sort();
            k2.sort();
            let keyCompare = compareValue(k1, k2);
            if (keyCompare != 0)
              return keyCompare;
            for (let key of k1) {
              let comp = compareValue(o1[key], o2[key]);
              if (comp != 0)
                return comp;
            }
            return 0;
          case "widget":
          case "html":
          case "function":
            return 0;
        }
      }
      Values2.compareValue = compareValue;
      function typeOf(val) {
        var _a;
        return (_a = wrapValue(val)) === null || _a === void 0 ? void 0 : _a.type;
      }
      Values2.typeOf = typeOf;
      function isTruthy(field) {
        let wrapped = wrapValue(field);
        if (!wrapped)
          return false;
        switch (wrapped.type) {
          case "number":
            return wrapped.value != 0;
          case "string":
            return wrapped.value.length > 0;
          case "boolean":
            return wrapped.value;
          case "link":
            return !!wrapped.value.path;
          case "date":
            return wrapped.value.toMillis() != 0;
          case "duration":
            return wrapped.value.as("seconds") != 0;
          case "object":
            return Object.keys(wrapped.value).length > 0;
          case "array":
            return wrapped.value.length > 0;
          case "null":
            return false;
          case "html":
          case "widget":
          case "function":
            return true;
        }
      }
      Values2.isTruthy = isTruthy;
      function deepCopy(field) {
        if (field === null || field === void 0)
          return field;
        if (Values2.isArray(field)) {
          return [].concat(field.map((v) => deepCopy(v)));
        } else if (Values2.isObject(field)) {
          let result = {};
          for (let [key, value] of Object.entries(field))
            result[key] = deepCopy(value);
          return result;
        } else {
          return field;
        }
      }
      Values2.deepCopy = deepCopy;
      function isString3(val) {
        return typeof val == "string";
      }
      Values2.isString = isString3;
      function isNumber3(val) {
        return typeof val == "number";
      }
      Values2.isNumber = isNumber3;
      function isDate3(val) {
        return val instanceof DateTime2;
      }
      Values2.isDate = isDate3;
      function isDuration(val) {
        return val instanceof Duration2;
      }
      Values2.isDuration = isDuration;
      function isNull(val) {
        return val === null || val === void 0;
      }
      Values2.isNull = isNull;
      function isArray(val) {
        return Array.isArray(val);
      }
      Values2.isArray = isArray;
      function isBoolean(val) {
        return typeof val === "boolean";
      }
      Values2.isBoolean = isBoolean;
      function isLink(val) {
        return val instanceof Link;
      }
      Values2.isLink = isLink;
      function isWidget(val) {
        return val instanceof Widget;
      }
      Values2.isWidget = isWidget;
      function isHtml(val) {
        if (typeof HTMLElement !== "undefined") {
          return val instanceof HTMLElement;
        } else {
          return false;
        }
      }
      Values2.isHtml = isHtml;
      function isObject(val) {
        return typeof val == "object" && !isHtml(val) && !isWidget(val) && !isArray(val) && !isDuration(val) && !isDate3(val) && !isLink(val) && val !== void 0 && !isNull(val);
      }
      Values2.isObject = isObject;
      function isFunction(val) {
        return typeof val == "function";
      }
      Values2.isFunction = isFunction;
    })(Values || (Values = {}));
    var Groupings;
    (function(Groupings2) {
      function isElementGroup(entry) {
        return Values.isObject(entry) && Object.keys(entry).length == 2 && "key" in entry && "rows" in entry;
      }
      Groupings2.isElementGroup = isElementGroup;
      function isGrouping(entry) {
        for (let element2 of entry)
          if (!isElementGroup(element2))
            return false;
        return true;
      }
      Groupings2.isGrouping = isGrouping;
      function count(elements) {
        if (isGrouping(elements)) {
          let result = 0;
          for (let subgroup of elements)
            result += count(subgroup.rows);
          return result;
        } else {
          return elements.length;
        }
      }
      Groupings2.count = count;
    })(Groupings || (Groupings = {}));
    var Link = class _Link {
      /** Create a link to a specific file. */
      static file(path4, embed = false, display) {
        return new _Link({
          path: path4,
          embed,
          display,
          subpath: void 0,
          type: "file"
        });
      }
      static infer(linkpath, embed = false, display) {
        if (linkpath.includes("#^")) {
          let split = linkpath.split("#^");
          return _Link.block(split[0], split[1], embed, display);
        } else if (linkpath.includes("#")) {
          let split = linkpath.split("#");
          return _Link.header(split[0], split[1], embed, display);
        } else
          return _Link.file(linkpath, embed, display);
      }
      /** Create a link to a specific file and header in that file. */
      static header(path4, header, embed, display) {
        return new _Link({
          path: path4,
          embed,
          display,
          subpath: normalizeHeaderForLink(header),
          type: "header"
        });
      }
      /** Create a link to a specific file and block in that file. */
      static block(path4, blockId, embed, display) {
        return new _Link({
          path: path4,
          embed,
          display,
          subpath: blockId,
          type: "block"
        });
      }
      static fromObject(object) {
        return new _Link(object);
      }
      constructor(fields) {
        Object.assign(this, fields);
      }
      /** Checks for link equality (i.e., that the links are pointing to the same exact location). */
      equals(other) {
        if (other == void 0 || other == null)
          return false;
        return this.path == other.path && this.type == other.type && this.subpath == other.subpath;
      }
      /** Convert this link to it's markdown representation. */
      toString() {
        return this.markdown();
      }
      /** Convert this link to a raw object which is serialization-friendly. */
      toObject() {
        return { path: this.path, type: this.type, subpath: this.subpath, display: this.display, embed: this.embed };
      }
      /** Update this link with a new path. */
      //@ts-ignore; error appeared after updating Obsidian to 0.15.4; it also updated other packages but didn't say which
      withPath(path4) {
        return new _Link(Object.assign({}, this, { path: path4 }));
      }
      /** Return a new link which points to the same location but with a new display value. */
      withDisplay(display) {
        return new _Link(Object.assign({}, this, { display }));
      }
      /** Convert a file link into a link to a specific header. */
      withHeader(header) {
        return _Link.header(this.path, header, this.embed, this.display);
      }
      /** Convert any link into a link to its file. */
      toFile() {
        return _Link.file(this.path, this.embed, this.display);
      }
      /** Convert this link into an embedded link. */
      toEmbed() {
        if (this.embed) {
          return this;
        } else {
          let link = new _Link(this);
          link.embed = true;
          return link;
        }
      }
      /** Convert this link into a non-embedded link. */
      fromEmbed() {
        if (!this.embed) {
          return this;
        } else {
          let link = new _Link(this);
          link.embed = false;
          return link;
        }
      }
      /** Convert this link to markdown so it can be rendered. */
      markdown() {
        let result = (this.embed ? "!" : "") + "[[" + this.obsidianLink();
        if (this.display) {
          result += "|" + this.display;
        } else {
          result += "|" + getFileTitle(this.path);
          if (this.type == "header" || this.type == "block")
            result += " > " + this.subpath;
        }
        result += "]]";
        return result;
      }
      /** Convert the inner part of the link to something that Obsidian can open / understand. */
      obsidianLink() {
        var _a, _b;
        const escaped = this.path.replace("|", "\\|");
        if (this.type == "header")
          return escaped + "#" + ((_a = this.subpath) === null || _a === void 0 ? void 0 : _a.replace("|", "\\|"));
        if (this.type == "block")
          return escaped + "#^" + ((_b = this.subpath) === null || _b === void 0 ? void 0 : _b.replace("|", "\\|"));
        else
          return escaped;
      }
      /** The stripped name of the file this link points to. */
      fileName() {
        return getFileTitle(this.path).replace(".md", "");
      }
    };
    var Widget = class {
      constructor($widget) {
        this.$widget = $widget;
      }
    };
    var ListPairWidget = class extends Widget {
      constructor(key, value) {
        super("dataview:list-pair");
        this.key = key;
        this.value = value;
      }
      markdown() {
        return `${Values.toString(this.key)}: ${Values.toString(this.value)}`;
      }
    };
    var ExternalLinkWidget = class extends Widget {
      constructor(url, display) {
        super("dataview:external-link");
        this.url = url;
        this.display = display;
      }
      markdown() {
        var _a;
        return `[${(_a = this.display) !== null && _a !== void 0 ? _a : this.url}](${this.url})`;
      }
    };
    var Widgets;
    (function(Widgets2) {
      function listPair(key, value) {
        return new ListPairWidget(key, value);
      }
      Widgets2.listPair = listPair;
      function externalLink(url, display) {
        return new ExternalLinkWidget(url, display);
      }
      Widgets2.externalLink = externalLink;
      function isListPair(widget) {
        return widget.$widget === "dataview:list-pair";
      }
      Widgets2.isListPair = isListPair;
      function isExternalLink(widget) {
        return widget.$widget === "dataview:external-link";
      }
      Widgets2.isExternalLink = isExternalLink;
      function isBuiltin(widget) {
        return isListPair(widget) || isExternalLink(widget);
      }
      Widgets2.isBuiltin = isBuiltin;
    })(Widgets || (Widgets = {}));
    var Fields;
    (function(Fields2) {
      function variable(name) {
        return { type: "variable", name };
      }
      Fields2.variable = variable;
      function literal(value) {
        return { type: "literal", value };
      }
      Fields2.literal = literal;
      function binaryOp(left, op, right) {
        return { type: "binaryop", left, op, right };
      }
      Fields2.binaryOp = binaryOp;
      function index(obj, index2) {
        return { type: "index", object: obj, index: index2 };
      }
      Fields2.index = index;
      function indexVariable(name) {
        let parts = name.split(".");
        let result = Fields2.variable(parts[0]);
        for (let index2 = 1; index2 < parts.length; index2++) {
          result = Fields2.index(result, Fields2.literal(parts[index2]));
        }
        return result;
      }
      Fields2.indexVariable = indexVariable;
      function lambda(args, value) {
        return { type: "lambda", arguments: args, value };
      }
      Fields2.lambda = lambda;
      function func(func2, args) {
        return { type: "function", func: func2, arguments: args };
      }
      Fields2.func = func;
      function list(values) {
        return { type: "list", values };
      }
      Fields2.list = list;
      function object(values) {
        return { type: "object", values };
      }
      Fields2.object = object;
      function negate(child) {
        return { type: "negated", child };
      }
      Fields2.negate = negate;
      function isCompareOp(op) {
        return op == "<=" || op == "<" || op == ">" || op == ">=" || op == "!=" || op == "=";
      }
      Fields2.isCompareOp = isCompareOp;
      Fields2.NULL = Fields2.literal(null);
    })(Fields || (Fields = {}));
    var Sources;
    (function(Sources2) {
      function tag(tag2) {
        return { type: "tag", tag: tag2 };
      }
      Sources2.tag = tag;
      function csv(path4) {
        return { type: "csv", path: path4 };
      }
      Sources2.csv = csv;
      function folder(prefix) {
        return { type: "folder", folder: prefix };
      }
      Sources2.folder = folder;
      function link(file, incoming) {
        return { type: "link", file, direction: incoming ? "incoming" : "outgoing" };
      }
      Sources2.link = link;
      function binaryOp(left, op, right) {
        return { type: "binaryop", left, op, right };
      }
      Sources2.binaryOp = binaryOp;
      function and(left, right) {
        return { type: "binaryop", left, op: "&", right };
      }
      Sources2.and = and;
      function or(left, right) {
        return { type: "binaryop", left, op: "|", right };
      }
      Sources2.or = or;
      function negate(child) {
        return { type: "negate", child };
      }
      Sources2.negate = negate;
      function empty2() {
        return { type: "empty" };
      }
      Sources2.empty = empty2;
    })(Sources || (Sources = {}));
    var EMOJI_REGEX = new RegExp(emojiRegex(), "");
    var DURATION_TYPES = {
      year: Duration2.fromObject({ years: 1 }),
      years: Duration2.fromObject({ years: 1 }),
      yr: Duration2.fromObject({ years: 1 }),
      yrs: Duration2.fromObject({ years: 1 }),
      month: Duration2.fromObject({ months: 1 }),
      months: Duration2.fromObject({ months: 1 }),
      mo: Duration2.fromObject({ months: 1 }),
      mos: Duration2.fromObject({ months: 1 }),
      week: Duration2.fromObject({ weeks: 1 }),
      weeks: Duration2.fromObject({ weeks: 1 }),
      wk: Duration2.fromObject({ weeks: 1 }),
      wks: Duration2.fromObject({ weeks: 1 }),
      w: Duration2.fromObject({ weeks: 1 }),
      day: Duration2.fromObject({ days: 1 }),
      days: Duration2.fromObject({ days: 1 }),
      d: Duration2.fromObject({ days: 1 }),
      hour: Duration2.fromObject({ hours: 1 }),
      hours: Duration2.fromObject({ hours: 1 }),
      hr: Duration2.fromObject({ hours: 1 }),
      hrs: Duration2.fromObject({ hours: 1 }),
      h: Duration2.fromObject({ hours: 1 }),
      minute: Duration2.fromObject({ minutes: 1 }),
      minutes: Duration2.fromObject({ minutes: 1 }),
      min: Duration2.fromObject({ minutes: 1 }),
      mins: Duration2.fromObject({ minutes: 1 }),
      m: Duration2.fromObject({ minutes: 1 }),
      second: Duration2.fromObject({ seconds: 1 }),
      seconds: Duration2.fromObject({ seconds: 1 }),
      sec: Duration2.fromObject({ seconds: 1 }),
      secs: Duration2.fromObject({ seconds: 1 }),
      s: Duration2.fromObject({ seconds: 1 })
    };
    var DATE_SHORTHANDS = {
      now: () => DateTime2.local(),
      today: () => DateTime2.local().startOf("day"),
      yesterday: () => DateTime2.local().startOf("day").minus(Duration2.fromObject({ days: 1 })),
      tomorrow: () => DateTime2.local().startOf("day").plus(Duration2.fromObject({ days: 1 })),
      sow: () => DateTime2.local().startOf("week"),
      "start-of-week": () => DateTime2.local().startOf("week"),
      eow: () => DateTime2.local().endOf("week"),
      "end-of-week": () => DateTime2.local().endOf("week"),
      soy: () => DateTime2.local().startOf("year"),
      "start-of-year": () => DateTime2.local().startOf("year"),
      eoy: () => DateTime2.local().endOf("year"),
      "end-of-year": () => DateTime2.local().endOf("year"),
      som: () => DateTime2.local().startOf("month"),
      "start-of-month": () => DateTime2.local().startOf("month"),
      eom: () => DateTime2.local().endOf("month"),
      "end-of-month": () => DateTime2.local().endOf("month")
    };
    var KEYWORDS = ["FROM", "WHERE", "LIMIT", "GROUP", "FLATTEN"];
    function splitOnUnescapedPipe(link) {
      let pipe = -1;
      while ((pipe = link.indexOf("|", pipe + 1)) >= 0) {
        if (pipe > 0 && link[pipe - 1] == "\\")
          continue;
        return [link.substring(0, pipe).replace(/\\\|/g, "|"), link.substring(pipe + 1)];
      }
      return [link.replace(/\\\|/g, "|"), void 0];
    }
    function parseInnerLink(rawlink) {
      let [link, display] = splitOnUnescapedPipe(rawlink);
      return Link.infer(link, false, display);
    }
    function createBinaryParser(child, sep, combine) {
      return parsimmon_umd_minExports.seqMap(child, parsimmon_umd_minExports.seq(parsimmon_umd_minExports.optWhitespace, sep, parsimmon_umd_minExports.optWhitespace, child).many(), (first, rest) => {
        if (rest.length == 0)
          return first;
        let node = combine(first, rest[0][1], rest[0][3]);
        for (let index = 1; index < rest.length; index++) {
          node = combine(node, rest[index][1], rest[index][3]);
        }
        return node;
      });
    }
    function chainOpt(base, ...funcs) {
      return parsimmon_umd_minExports.custom((success, failure) => {
        return (input, i) => {
          let result = base._(input, i);
          if (!result.status)
            return result;
          for (let func of funcs) {
            let next = func(result.value)._(input, result.index);
            if (!next.status)
              return result;
            result = next;
          }
          return result;
        };
      });
    }
    var EXPRESSION = parsimmon_umd_minExports.createLanguage({
      // A floating point number; the decimal point is optional.
      number: (q) => parsimmon_umd_minExports.regexp(/-?[0-9]+(\.[0-9]+)?/).map((str) => Number.parseFloat(str)).desc("number"),
      // A quote-surrounded string which supports escape characters ('\').
      string: (q) => parsimmon_umd_minExports.string('"').then(parsimmon_umd_minExports.alt(q.escapeCharacter, parsimmon_umd_minExports.noneOf('"\\')).atLeast(0).map((chars) => chars.join(""))).skip(parsimmon_umd_minExports.string('"')).desc("string"),
      escapeCharacter: (_) => parsimmon_umd_minExports.string("\\").then(parsimmon_umd_minExports.any).map((escaped) => {
        if (escaped === '"')
          return '"';
        if (escaped === "\\")
          return "\\";
        else
          return "\\" + escaped;
      }),
      // A boolean true/false value.
      bool: (_) => parsimmon_umd_minExports.regexp(/true|false|True|False/).map((str) => str.toLowerCase() == "true").desc("boolean ('true' or 'false')"),
      // A tag of the form '#stuff/hello-there'.
      tag: (_) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("#"), parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/[^\u2000-\u206F\u2E00-\u2E7F'!"#$%&()*+,.:;<=>?@^`{|}~\[\]\\\s]/).desc("text")).many(), (start, rest) => start + rest.join("")).desc("tag ('#hello/stuff')"),
      // A variable identifier, which is alphanumeric and must start with a letter or... emoji.
      identifier: (_) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/\p{Letter}/u), parsimmon_umd_minExports.regexp(EMOJI_REGEX).desc("text")), parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/[0-9\p{Letter}_-]/u), parsimmon_umd_minExports.regexp(EMOJI_REGEX).desc("text")).many(), (first, rest) => first + rest.join("")).desc("variable identifier"),
      // An Obsidian link of the form [[<link>]].
      link: (_) => parsimmon_umd_minExports.regexp(/\[\[([^\[\]]*?)\]\]/u, 1).map((linkInner) => parseInnerLink(linkInner)).desc("file link"),
      // An embeddable link which can start with '!'. This overlaps with the normal negation operator, so it is only
      // provided for metadata parsing.
      embedLink: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("!").atMost(1), q.link, (p, l3) => {
        if (p.length > 0)
          l3.embed = true;
        return l3;
      }).desc("file link"),
      // Binary plus or minus operator.
      binaryPlusMinus: (_) => parsimmon_umd_minExports.regexp(/\+|-/).map((str) => str).desc("'+' or '-'"),
      // Binary times or divide operator.
      binaryMulDiv: (_) => parsimmon_umd_minExports.regexp(/\*|\/|%/).map((str) => str).desc("'*' or '/' or '%'"),
      // Binary comparison operator.
      binaryCompareOp: (_) => parsimmon_umd_minExports.regexp(/>=|<=|!=|>|<|=/).map((str) => str).desc("'>=' or '<=' or '!=' or '=' or '>' or '<'"),
      // Binary boolean combination operator.
      binaryBooleanOp: (_) => parsimmon_umd_minExports.regexp(/and|or|&|\|/i).map((str) => {
        if (str.toLowerCase() == "and")
          return "&";
        else if (str.toLowerCase() == "or")
          return "|";
        else
          return str;
      }).desc("'and' or 'or'"),
      // A date which can be YYYY-MM[-DDTHH:mm:ss].
      rootDate: (_) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/\d{4}/), parsimmon_umd_minExports.string("-"), parsimmon_umd_minExports.regexp(/\d{2}/), (year, _2, month) => {
        return DateTime2.fromObject({ year: Number.parseInt(year), month: Number.parseInt(month) });
      }).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
      dateShorthand: (_) => parsimmon_umd_minExports.alt(...Object.keys(DATE_SHORTHANDS).sort((a, b) => b.length - a.length).map(parsimmon_umd_minExports.string)),
      date: (q) => chainOpt(q.rootDate, (ym) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("-"), parsimmon_umd_minExports.regexp(/\d{2}/), (_, day) => ym.set({ day: Number.parseInt(day) })), (ymd) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("T"), parsimmon_umd_minExports.regexp(/\d{2}/), (_, hour) => ymd.set({ hour: Number.parseInt(hour) })), (ymdh) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string(":"), parsimmon_umd_minExports.regexp(/\d{2}/), (_, minute) => ymdh.set({ minute: Number.parseInt(minute) })), (ymdhm) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string(":"), parsimmon_umd_minExports.regexp(/\d{2}/), (_, second) => ymdhm.set({ second: Number.parseInt(second) })), (ymdhms) => parsimmon_umd_minExports.alt(
        parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("."), parsimmon_umd_minExports.regexp(/\d{3}/), (_, millisecond) => ymdhms.set({ millisecond: Number.parseInt(millisecond) })),
        parsimmon_umd_minExports.succeed(ymdhms)
        // pass
      ), (dt) => parsimmon_umd_minExports.alt(parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("+").or(parsimmon_umd_minExports.string("-")), parsimmon_umd_minExports.regexp(/\d{1,2}(:\d{2})?/), (pm, hr) => dt.setZone("UTC" + pm + hr, { keepLocalTime: true })), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("Z"), () => dt.setZone("utc", { keepLocalTime: true })), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("["), parsimmon_umd_minExports.regexp(/[0-9A-Za-z+-\/]+/u), parsimmon_umd_minExports.string("]"), (_a, zone, _b) => dt.setZone(zone, { keepLocalTime: true })))).assert((dt) => dt.isValid, "valid date").desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
      // A date, plus various shorthand times of day it could be.
      datePlus: (q) => parsimmon_umd_minExports.alt(q.dateShorthand.map((d) => DATE_SHORTHANDS[d]()), q.date).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS] or in shorthand"),
      // A duration of time.
      durationType: (_) => parsimmon_umd_minExports.alt(...Object.keys(DURATION_TYPES).sort((a, b) => b.length - a.length).map(parsimmon_umd_minExports.string)),
      duration: (q) => parsimmon_umd_minExports.seqMap(q.number, parsimmon_umd_minExports.optWhitespace, q.durationType, (count, _, t) => DURATION_TYPES[t].mapUnits((x) => x * count)).sepBy1(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace).or(parsimmon_umd_minExports.optWhitespace)).map((durations) => durations.reduce((p, c) => p.plus(c))).desc("duration like 4hr2min"),
      // A raw null value.
      rawNull: (_) => parsimmon_umd_minExports.string("null"),
      // Source parsing.
      tagSource: (q) => q.tag.map((tag) => Sources.tag(tag)),
      csvSource: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("csv(").skip(parsimmon_umd_minExports.optWhitespace), q.string, parsimmon_umd_minExports.string(")"), (_1, path4, _2) => Sources.csv(path4)),
      linkIncomingSource: (q) => q.link.map((link) => Sources.link(link.path, true)),
      linkOutgoingSource: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("outgoing(").skip(parsimmon_umd_minExports.optWhitespace), q.link, parsimmon_umd_minExports.string(")"), (_1, link, _2) => Sources.link(link.path, false)),
      folderSource: (q) => q.string.map((str) => Sources.folder(str)),
      parensSource: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("("), parsimmon_umd_minExports.optWhitespace, q.source, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (_1, _2, field, _3, _4) => field),
      negateSource: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.alt(parsimmon_umd_minExports.string("-"), parsimmon_umd_minExports.string("!")), q.atomSource, (_, source) => Sources.negate(source)),
      atomSource: (q) => parsimmon_umd_minExports.alt(q.parensSource, q.negateSource, q.linkOutgoingSource, q.linkIncomingSource, q.folderSource, q.tagSource, q.csvSource),
      binaryOpSource: (q) => createBinaryParser(q.atomSource, q.binaryBooleanOp.map((s3) => s3), Sources.binaryOp),
      source: (q) => q.binaryOpSource,
      // Field parsing.
      variableField: (q) => q.identifier.chain((r) => {
        if (KEYWORDS.includes(r.toUpperCase())) {
          return parsimmon_umd_minExports.fail("Variable fields cannot be a keyword (" + KEYWORDS.join(" or ") + ")");
        } else {
          return parsimmon_umd_minExports.succeed(Fields.variable(r));
        }
      }).desc("variable"),
      numberField: (q) => q.number.map((val) => Fields.literal(val)).desc("number"),
      stringField: (q) => q.string.map((val) => Fields.literal(val)).desc("string"),
      boolField: (q) => q.bool.map((val) => Fields.literal(val)).desc("boolean"),
      dateField: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("date("), parsimmon_umd_minExports.optWhitespace, q.datePlus, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (prefix, _1, date, _2, postfix) => Fields.literal(date)).desc("date"),
      durationField: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("dur("), parsimmon_umd_minExports.optWhitespace, q.duration, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (prefix, _1, dur, _2, postfix) => Fields.literal(dur)).desc("duration"),
      nullField: (q) => q.rawNull.map((_) => Fields.NULL),
      linkField: (q) => q.link.map((f) => Fields.literal(f)),
      listField: (q) => q.field.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)).wrap(parsimmon_umd_minExports.string("[").skip(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.optWhitespace.then(parsimmon_umd_minExports.string("]"))).map((l3) => Fields.list(l3)).desc("list ('[1, 2, 3]')"),
      objectField: (q) => parsimmon_umd_minExports.seqMap(q.identifier.or(q.string), parsimmon_umd_minExports.string(":").trim(parsimmon_umd_minExports.optWhitespace), q.field, (name, _sep, value) => {
        return { name, value };
      }).sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)).wrap(parsimmon_umd_minExports.string("{").skip(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.optWhitespace.then(parsimmon_umd_minExports.string("}"))).map((vals) => {
        let res = {};
        for (let entry of vals)
          res[entry.name] = entry.value;
        return Fields.object(res);
      }).desc("object ('{ a: 1, b: 2 }')"),
      atomInlineField: (q) => parsimmon_umd_minExports.alt(q.date, q.duration.map((d) => normalizeDuration(d)), q.string, q.tag, q.embedLink, q.bool, q.number, q.rawNull),
      inlineFieldList: (q) => q.atomInlineField.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace).lookahead(q.atomInlineField)),
      inlineField: (q) => parsimmon_umd_minExports.alt(parsimmon_umd_minExports.seqMap(q.atomInlineField, parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace), q.inlineFieldList, (f, _s, l3) => [f].concat(l3)), q.atomInlineField),
      atomField: (q) => parsimmon_umd_minExports.alt(
        // Place embed links above negated fields as they are the special parser case '![[thing]]' and are generally unambigious.
        q.embedLink.map((l3) => Fields.literal(l3)),
        q.negatedField,
        q.linkField,
        q.listField,
        q.objectField,
        q.lambdaField,
        q.parensField,
        q.boolField,
        q.numberField,
        q.stringField,
        q.dateField,
        q.durationField,
        q.nullField,
        q.variableField
      ),
      indexField: (q) => parsimmon_umd_minExports.seqMap(q.atomField, parsimmon_umd_minExports.alt(q.dotPostfix, q.indexPostfix, q.functionPostfix).many(), (obj, postfixes) => {
        let result = obj;
        for (let post of postfixes) {
          switch (post.type) {
            case "dot":
              result = Fields.index(result, Fields.literal(post.field));
              break;
            case "index":
              result = Fields.index(result, post.field);
              break;
            case "function":
              result = Fields.func(result, post.fields);
              break;
          }
        }
        return result;
      }),
      negatedField: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("!"), q.indexField, (_, field) => Fields.negate(field)).desc("negated field"),
      parensField: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("("), parsimmon_umd_minExports.optWhitespace, q.field, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (_1, _2, field, _3, _4) => field),
      lambdaField: (q) => parsimmon_umd_minExports.seqMap(q.identifier.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)).wrap(parsimmon_umd_minExports.string("(").trim(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.string(")").trim(parsimmon_umd_minExports.optWhitespace)), parsimmon_umd_minExports.string("=>").trim(parsimmon_umd_minExports.optWhitespace), q.field, (ident, _ignore, value) => {
        return { type: "lambda", arguments: ident, value };
      }),
      dotPostfix: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("."), q.identifier, (_, field) => {
        return { type: "dot", field };
      }),
      indexPostfix: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("["), parsimmon_umd_minExports.optWhitespace, q.field, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string("]"), (_, _2, field, _3, _4) => {
        return { type: "index", field };
      }),
      functionPostfix: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("("), parsimmon_umd_minExports.optWhitespace, q.field.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)), parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (_, _1, fields, _2, _3) => {
        return { type: "function", fields };
      }),
      // The precedence hierarchy of operators - multiply/divide, add/subtract, compare, and then boolean operations.
      binaryMulDivField: (q) => createBinaryParser(q.indexField, q.binaryMulDiv, Fields.binaryOp),
      binaryPlusMinusField: (q) => createBinaryParser(q.binaryMulDivField, q.binaryPlusMinus, Fields.binaryOp),
      binaryCompareField: (q) => createBinaryParser(q.binaryPlusMinusField, q.binaryCompareOp, Fields.binaryOp),
      binaryBooleanField: (q) => createBinaryParser(q.binaryCompareField, q.binaryBooleanOp, Fields.binaryOp),
      binaryOpField: (q) => q.binaryBooleanField,
      field: (q) => q.binaryOpField
    });
    function parseField(text2) {
      try {
        return Result.success(EXPRESSION.field.tryParse(text2));
      } catch (error) {
        return Result.failure("" + error);
      }
    }
    var QueryFields;
    (function(QueryFields2) {
      function named(name, field) {
        return { name, field };
      }
      QueryFields2.named = named;
      function sortBy(field, dir) {
        return { field, direction: dir };
      }
      QueryFields2.sortBy = sortBy;
    })(QueryFields || (QueryFields = {}));
    function captureRaw(base) {
      return parsimmon_umd_minExports.custom((success, failure) => {
        return (input, i) => {
          let result = base._(input, i);
          if (!result.status)
            return result;
          return Object.assign({}, result, { value: [result.value, input.substring(i, result.index)] });
        };
      });
    }
    function stripNewlines(text2) {
      return text2.split(/[\r\n]+/).map((t) => t.trim()).join("");
    }
    function precededByWhitespaceIfNotEof(if_eof, parser) {
      return parsimmon_umd_minExports.eof.map(if_eof).or(parsimmon_umd_minExports.whitespace.then(parser));
    }
    var QUERY_LANGUAGE = parsimmon_umd_minExports.createLanguage({
      // Simple atom parsing, like words, identifiers, numbers.
      queryType: (q) => parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/TABLE|LIST|TASK|CALENDAR/i)).map((str) => str.toLowerCase()).desc("query type ('TABLE', 'LIST', 'TASK', or 'CALENDAR')"),
      explicitNamedField: (q) => parsimmon_umd_minExports.seqMap(EXPRESSION.field.skip(parsimmon_umd_minExports.whitespace), parsimmon_umd_minExports.regexp(/AS/i).skip(parsimmon_umd_minExports.whitespace), EXPRESSION.identifier.or(EXPRESSION.string), (field, _as, ident) => QueryFields.named(ident, field)),
      namedField: (q) => parsimmon_umd_minExports.alt(q.explicitNamedField, captureRaw(EXPRESSION.field).map(([value, text2]) => QueryFields.named(stripNewlines(text2), value))),
      sortField: (q) => parsimmon_umd_minExports.seqMap(EXPRESSION.field.skip(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.regexp(/ASCENDING|DESCENDING|ASC|DESC/i).atMost(1), (field, dir) => {
        let direction = dir.length == 0 ? "ascending" : dir[0].toLowerCase();
        if (direction == "desc")
          direction = "descending";
        if (direction == "asc")
          direction = "ascending";
        return {
          field,
          direction
        };
      }),
      headerClause: (q) => q.queryType.chain((type) => {
        switch (type) {
          case "table": {
            return precededByWhitespaceIfNotEof(() => ({ type, fields: [], showId: true }), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/WITHOUT\s+ID/i).skip(parsimmon_umd_minExports.optWhitespace).atMost(1), parsimmon_umd_minExports.sepBy(q.namedField, parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)), (withoutId, fields) => {
              return { type, fields, showId: withoutId.length == 0 };
            }));
          }
          case "list":
            return precededByWhitespaceIfNotEof(() => ({ type, format: void 0, showId: true }), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/WITHOUT\s+ID/i).skip(parsimmon_umd_minExports.optWhitespace).atMost(1), EXPRESSION.field.atMost(1), (withoutId, format) => {
              return {
                type,
                format: format.length == 1 ? format[0] : void 0,
                showId: withoutId.length == 0
              };
            }));
          case "task":
            return parsimmon_umd_minExports.succeed({ type });
          case "calendar":
            return parsimmon_umd_minExports.whitespace.then(parsimmon_umd_minExports.seqMap(q.namedField, (field) => {
              return {
                type,
                showId: true,
                field
              };
            }));
          default:
            return parsimmon_umd_minExports.fail(`Unrecognized query type '${type}'`);
        }
      }).desc("TABLE or LIST or TASK or CALENDAR"),
      fromClause: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/FROM/i), parsimmon_umd_minExports.whitespace, EXPRESSION.source, (_1, _2, source) => source),
      whereClause: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/WHERE/i), parsimmon_umd_minExports.whitespace, EXPRESSION.field, (where, _, field) => {
        return { type: "where", clause: field };
      }).desc("WHERE <expression>"),
      sortByClause: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/SORT/i), parsimmon_umd_minExports.whitespace, q.sortField.sepBy1(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)), (sort, _1, fields) => {
        return { type: "sort", fields };
      }).desc("SORT field [ASC/DESC]"),
      limitClause: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/LIMIT/i), parsimmon_umd_minExports.whitespace, EXPRESSION.field, (limit, _1, field) => {
        return { type: "limit", amount: field };
      }).desc("LIMIT <value>"),
      flattenClause: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/FLATTEN/i).skip(parsimmon_umd_minExports.whitespace), q.namedField, (_, field) => {
        return { type: "flatten", field };
      }).desc("FLATTEN <value> [AS <name>]"),
      groupByClause: (q) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/GROUP BY/i).skip(parsimmon_umd_minExports.whitespace), q.namedField, (_, field) => {
        return { type: "group", field };
      }).desc("GROUP BY <value> [AS <name>]"),
      // Full query parsing.
      clause: (q) => parsimmon_umd_minExports.alt(q.fromClause, q.whereClause, q.sortByClause, q.limitClause, q.groupByClause, q.flattenClause),
      query: (q) => parsimmon_umd_minExports.seqMap(q.headerClause.trim(parsimmon_umd_minExports.optWhitespace), q.fromClause.trim(parsimmon_umd_minExports.optWhitespace).atMost(1), q.clause.trim(parsimmon_umd_minExports.optWhitespace).many(), (header, from, clauses) => {
        return {
          header,
          source: from.length == 0 ? Sources.folder("") : from[0],
          operations: clauses,
          settings: DEFAULT_QUERY_SETTINGS
        };
      })
    });
    var getAPI = (app) => {
      var _a;
      if (app)
        return (_a = app.plugins.plugins.dataview) === null || _a === void 0 ? void 0 : _a.api;
      else
        return window.DataviewAPI;
    };
    var isPluginEnabled = (app) => app.plugins.enabledPlugins.has("dataview");
    exports.DATE_SHORTHANDS = DATE_SHORTHANDS;
    exports.DURATION_TYPES = DURATION_TYPES;
    exports.EXPRESSION = EXPRESSION;
    exports.KEYWORDS = KEYWORDS;
    exports.QUERY_LANGUAGE = QUERY_LANGUAGE;
    exports.getAPI = getAPI;
    exports.isPluginEnabled = isPluginEnabled;
    exports.parseField = parseField;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BreadcrumbsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian27 = require("obsidian");

// src/const/graph.ts
var EXPLICIT_EDGE_SOURCES = [
  "typed_link",
  "tag_note",
  "list_note",
  "dendron_note",
  "dataview_note",
  "date_note",
  "folder_note",
  "regex_note"
];
var SIMPLE_EDGE_SORT_FIELDS = [
  // The order they were added to the graph
  // Hidden because I don't think anyone really cares about that order
  // "graph",
  "basename",
  "path",
  "field",
  // Whether the edge is explicit or not
  // Uses source and implied_kind as tie-breakers for explicit == true and false, respectively
  "explicit"
];
var COMPLEX_EDGE_SORT_FIELD_PREFIXES = [
  // BREAKING: rather use neighbour-field
  "neighbour",
  "neighbour-field",
  "neighbour-dir"
];

// src/utils/strings.ts
var split_and_trim = (str, delimiter = ",") => {
  if (!str || str === "")
    return [];
  else
    return str.split(delimiter).map((str2) => str2.trim());
};
var ensure_starts_with = (str, prefix) => str.startsWith(prefix) ? str : prefix + str;
var ensure_ends_with = (str, suffix) => str.endsWith(suffix) ? str : str + suffix;

// src/utils/paths.ts
var ensure_ext = (path4, ext = "md") => ensure_ends_with(path4, "." + ext);
var drop_ext = (path4) => path4.replace(/\.[^/.]+$/, "");
var drop_folder = (path4) => path4.split("/").pop();
var show = (path4, show_node_options) => {
  let output = path4.slice();
  if (!(show_node_options == null ? void 0 : show_node_options.folder)) {
    output = drop_folder(output);
  }
  if (!(show_node_options == null ? void 0 : show_node_options.ext)) {
    output = drop_ext(output);
  }
  return output;
};
var Paths = {
  ensure_ext,
  // update_name,
  drop_ext,
  drop_folder,
  show
};

// src/graph/utils.ts
var is_self_loop = (edge) => edge.source_id === edge.target_id;
var stringify_node = (node_id, node_attr, options) => {
  var _a, _b;
  if (((_a = options == null ? void 0 : options.show_node_options) == null ? void 0 : _a.alias) && ((_b = node_attr.aliases) == null ? void 0 : _b.length)) {
    return node_attr.aliases.at(0);
  } else if (options == null ? void 0 : options.trim_basename_delimiter) {
    return Paths.drop_ext(node_id).split("/").pop().split(options.trim_basename_delimiter).last();
  } else {
    return Paths.show(node_id, options == null ? void 0 : options.show_node_options);
  }
};
var get_edge_sorter = (sort, graph) => {
  switch (sort.field) {
    case "path": {
      return (a, b) => {
        const [a_field, b_field] = [a.target_id, b.target_id];
        return a_field.localeCompare(b_field) * sort.order;
      };
    }
    case "basename": {
      return (a, b) => {
        const [a_field, b_field] = [
          Paths.drop_folder(a.target_id),
          Paths.drop_folder(b.target_id)
        ];
        return a_field.localeCompare(b_field) * sort.order;
      };
    }
    case "field": {
      return (a, b) => {
        var _a, _b;
        const [a_field, b_field] = [
          (_a = a.attr.field) != null ? _a : "null",
          (_b = b.attr.field) != null ? _b : "null"
        ];
        return a_field.localeCompare(b_field) * sort.order;
      };
    }
    case "explicit": {
      return (a, b) => {
        if (a.attr.explicit === true && b.attr.explicit === true) {
          return a.attr.source.localeCompare(b.attr.source) * sort.order;
        } else if (a.attr.explicit === false && b.attr.explicit === false) {
          return a.attr.implied_kind.localeCompare(b.attr.implied_kind) * sort.order;
        } else {
          return a.attr.explicit ? sort.order : -sort.order;
        }
      };
    }
    default: {
      if (!COMPLEX_EDGE_SORT_FIELD_PREFIXES.some(
        (f) => sort.field.startsWith(f + ":")
      )) {
        throw new Error(`Invalid sort field: ${sort.field}`);
      }
      switch (sort.field.split(":")[0]) {
        case "neighbour":
        case "neighbour-field": {
          const field = sort.field.split(":", 2).at(1);
          const cache = {};
          return (a, b) => {
            var _a, _b, _c, _d;
            const [a_neighbour, b_neighbour] = [
              (_b = cache[_a = a.target_id]) != null ? _b : cache[_a] = graph.get_out_edges(a.target_id).filter((e) => has_edge_attrs(e, { field })).at(0),
              (_d = cache[_c = b.target_id]) != null ? _d : cache[_c] = graph.get_out_edges(b.target_id).filter((e) => has_edge_attrs(e, { field })).at(0)
            ];
            if (!a_neighbour || !b_neighbour) {
              return a_neighbour ? -sort.order : b_neighbour ? sort.order : 0;
            } else {
              return a_neighbour.target_id.localeCompare(
                b_neighbour.target_id
              ) * sort.order;
            }
          };
        }
        case "neighbour-dir": {
          const cache = {};
          const dir = sort.field.split(":", 2).at(1);
          return (a, b) => {
            var _a, _b, _c, _d;
            const [a_neighbour, b_neighbour] = [
              (_b = cache[_a = a.target_id]) != null ? _b : cache[_a] = graph.get_out_edges(a.target_id).filter(
                (e) => has_edge_attrs(e, {
                  dir,
                  hierarchy_i: a.attr.hierarchy_i
                })
              ).at(0),
              (_d = cache[_c = b.target_id]) != null ? _d : cache[_c] = graph.get_out_edges(b.target_id).filter(
                (e) => has_edge_attrs(e, {
                  dir,
                  hierarchy_i: b.attr.hierarchy_i
                })
              ).at(0)
            ];
            if (!a_neighbour || !b_neighbour) {
              return a_neighbour ? -sort.order : b_neighbour ? sort.order : 0;
            } else {
              return a_neighbour.target_id.localeCompare(
                b_neighbour.target_id
              ) * sort.order;
            }
          };
        }
        default: {
          return (_a, _b) => sort.order;
        }
      }
    }
  }
};
var has_edge_attrs = (edge, attrs) => {
  var _a;
  return attrs === void 0 || [
    attrs.dir === void 0 || edge.attr.dir === attrs.dir,
    attrs.field === void 0 || edge.attr.field === attrs.field,
    attrs.explicit === void 0 || edge.attr.explicit === attrs.explicit,
    attrs.hierarchy_i === void 0 || edge.attr.hierarchy_i === attrs.hierarchy_i,
    attrs.$or_dirs === void 0 || attrs.$or_dirs.includes(edge.attr.dir),
    attrs.$or_fields === void 0 || attrs.$or_fields.includes((_a = edge.attr.field) != null ? _a : "null"),
    attrs.$or_target_ids === void 0 || attrs.$or_target_ids.includes(edge.target_id)
  ].every(Boolean);
};

// src/graph/traverse.ts
var depth_first = (graph, start_node, callback, edge_filter) => {
  const visited = /* @__PURE__ */ new Set();
  const stack = graph.get_out_edges(start_node).filter((e) => !is_self_loop(e) && (!edge_filter || edge_filter(e, 0))).map((edge) => ({
    // NOTE: It's a little redundant to add the start_edge,
    //    but it makes the code simpler (e.g. GridView)
    path: [edge]
  }));
  while (stack.length > 0) {
    const stack_item = stack.pop();
    const current_edge = stack_item.path.at(-1);
    if (visited.has(current_edge.id)) {
      continue;
    } else {
      visited.add(current_edge.id);
    }
    const filtered_out_edges = graph.get_out_edges(current_edge.target_id).filter(
      (e) => !is_self_loop(e) && // In the case of a loop of more than one node
      !visited.has(e.id) && (!edge_filter || edge_filter(e, stack_item.path.length))
    );
    callback(stack_item, filtered_out_edges);
    filtered_out_edges.forEach((out_edge) => {
      stack.push({ path: stack_item.path.concat(out_edge) });
    });
  }
};
var alg = {
  depth_first
};
var all_paths = (alg_name, graph, start_node, edge_filter) => {
  const paths = [];
  alg[alg_name](
    graph,
    start_node,
    ({ path: path4 }, filtered_out_edges) => {
      if (!filtered_out_edges.length) {
        paths.push(path4);
      }
    },
    edge_filter
  );
  return paths;
};
var nest_all_paths = (all_paths2) => {
  const nested_edges = [];
  all_paths2.forEach((path4) => {
    let current_nest = nested_edges;
    path4.forEach((edge, depth) => {
      const existing_nest = current_nest.find(
        (nest) => nest.edge.target_id === edge.target_id && nest.depth === depth
      );
      if (existing_nest) {
        current_nest = existing_nest.children;
      } else {
        const new_nest = {
          edge,
          depth,
          children: []
        };
        current_nest.push(new_nest);
        current_nest = new_nest.children;
      }
    });
  });
  return nested_edges;
};
var flatten_all_paths = (paths) => {
  const visited = /* @__PURE__ */ new Set();
  const flattened = [];
  paths.forEach((path4) => {
    path4.forEach((edge, depth) => {
      const key = `${depth}-${edge.source_id}-${edge.target_id}`;
      if (!visited.has(key)) {
        visited.add(key);
        flattened.push({ edge, depth });
      }
    });
  });
  return flattened;
};
var sort_nested_paths = (nested_paths, sorter) => {
  nested_paths.forEach((nested_path) => {
    nested_path.children = sort_nested_paths(nested_path.children, sorter);
  });
  return nested_paths.sort((a, b) => sorter(a.edge, b.edge));
};
var Traverse = {
  alg,
  all_paths,
  flatten_all_paths,
  // flatten_nested_paths,
  nest_all_paths,
  sort_nested_paths
};

// src/utils/links.ts
var import_path = __toESM(require("path"));
var resolve_to_absolute_path = (app, relative_path, source_path) => {
  const folder = app.fileManager.getNewFileParent(source_path, relative_path);
  return import_path.default.join(
    folder.path === "/" ? "" : folder.path,
    import_path.default.basename(relative_path)
  );
};
var ify = (path4, display, {
  link_kind
}) => {
  switch (link_kind) {
    case "none": {
      return display;
    }
    case "wiki": {
      return display === path4 ? `[[${path4}]]` : `[[${path4}|${display}]]`;
    }
    case "markdown": {
      return display === path4 ? `[${path4}](${path4})` : `[${display}](${path4})`;
    }
  }
};
var Links = {
  ify,
  resolve_to_absolute_path
};

// src/commands/list_index/index.ts
var ListIndex;
((ListIndex2) => {
  ListIndex2.DEFAULT_OPTIONS = {
    dir: "down",
    indent: "\\t",
    hierarchy_i: -1,
    link_kind: "wiki",
    edge_sort_id: {
      order: 1,
      field: "basename"
    },
    show_node_options: { ext: false, alias: true, folder: false }
  };
  const flat_paths_to_list_index = (flat_paths, {
    indent,
    link_kind,
    show_node_options
  }) => {
    let index = "";
    const real_indent = indent.replace(/\\t/g, "	");
    flat_paths.forEach(({ depth, edge }) => {
      const display = stringify_node(edge.target_id, edge.target_attr, {
        show_node_options
      });
      const link = Links.ify(edge.target_id, display, {
        link_kind
      });
      index += real_indent.repeat(depth) + `- ${link}
`;
    });
    return index;
  };
  const nested_paths_to_list_index = (nested_paths, {
    indent,
    link_kind,
    show_node_options
  }) => {
    let index = "";
    const real_indent = indent.replace(/\\t/g, "	");
    nested_paths.forEach(({ children: children2, depth, edge }) => {
      const display = stringify_node(edge.target_id, edge.target_attr, {
        show_node_options
      });
      const link = Links.ify(edge.target_id, display, {
        link_kind
      });
      index += real_indent.repeat(depth) + `- ${link}
`;
      index += nested_paths_to_list_index(children2, {
        indent,
        link_kind,
        show_node_options
      });
    });
    return index;
  };
  ListIndex2.build = (graph, start_node, options) => nested_paths_to_list_index(
    Traverse.sort_nested_paths(
      Traverse.nest_all_paths(
        Traverse.all_paths(
          "depth_first",
          graph,
          start_node,
          (e) => e.attr.dir === options.dir && (options.hierarchy_i === -1 || e.attr.hierarchy_i === options.hierarchy_i)
        )
      ),
      get_edge_sorter(options.edge_sort_id, graph)
    ),
    options
  );
})(ListIndex || (ListIndex = {}));

// src/const/hierarchies.ts
var DIRECTIONS = ["up", "same", "down", "next", "prev"];
var ARROW_DIRECTIONS = {
  up: "\u2191",
  same: "\u2194",
  down: "\u2193",
  next: "\u2192",
  prev: "\u2190"
};

// src/utils/hierarchies.ts
var blank_hierarchy = () => ({
  dirs: {
    up: [""],
    same: [""],
    down: [""],
    next: [""],
    prev: [""]
  },
  // NOTE: In a "blank" hierarchy, should everything be off, or should it be reasonable defaults?
  implied_relationships: {
    opposite_direction: { rounds: 1 },
    self_is_sibling: { rounds: 0 },
    parents_sibling_is_parent: { rounds: 0 },
    cousin_is_sibling: { rounds: 0 },
    same_parent_is_sibling: { rounds: 0 },
    same_sibling_is_sibling: { rounds: 0 },
    siblings_parent_is_parent: { rounds: 0 }
  }
});
var get_opposite_direction = (dir) => {
  switch (dir) {
    case "up":
      return "down";
    case "down":
      return "up";
    case "same":
      return "same";
    case "next":
      return "prev";
    case "prev":
      return "next";
  }
};
var get_field_hierarchy = (hierarchies, field) => {
  let dir = null;
  let fields = null;
  let hierarchy_i = null;
  let implied_relationships = null;
  outer:
    for (const [i, hierarchy] of hierarchies.entries()) {
      for (const direction of DIRECTIONS) {
        const hierarchy_fields = hierarchy.dirs[direction];
        if (hierarchy_fields.includes(field)) {
          dir = direction;
          hierarchy_i = i;
          fields = hierarchy_fields;
          implied_relationships = hierarchy.implied_relationships;
          break outer;
        }
      }
    }
  if (dir === null || fields === null || hierarchy_i === null || implied_relationships === null) {
    return null;
  }
  return {
    dir,
    fields,
    hierarchy_i,
    implied_relationships
  };
};
var stringify_hierarchy = (hierarchy) => DIRECTIONS.map((dir) => hierarchy.dirs[dir].join(", ")).join(" | ");
var get_all_hierarchy_fields = (hierarchies) => hierarchies.map((hierarchy) => Object.values(hierarchy.dirs)).flat(2);

// src/const/settings.ts
var IMPLIED_RELATIONSHIP_MAX_ROUNDS = 10;
var DEFAULT_SHOW_NODE_OPTIONS = {
  ext: false,
  folder: false,
  alias: false
};
var DEFAULT_SETTINGS = {
  hierarchies: [
    {
      dirs: {
        up: ["up"],
        same: ["same"],
        down: ["down"],
        next: ["next"],
        prev: ["prev"]
      },
      implied_relationships: blank_hierarchy().implied_relationships
    }
  ],
  explicit_edge_sources: {
    list_note: {},
    typed_link: {},
    tag_note: {
      default_field: "up"
    },
    regex_note: {
      default_field: "up"
    },
    dendron_note: {
      enabled: false,
      delimiter: ".",
      default_field: "up",
      display_trimmed: false
    },
    date_note: {
      enabled: false,
      date_format: "yyyy-MM-dd",
      default_field: "next"
    }
  },
  custom_implied_relations: {
    transitive: []
  },
  views: {
    page: {
      all: {
        sticky: false,
        readable_line_width: true
      },
      trail: {
        enabled: true,
        format: "grid",
        default_depth: 999,
        selection: "all",
        no_path_message: "",
        show_node_options: { ...DEFAULT_SHOW_NODE_OPTIONS }
      },
      prev_next: {
        enabled: true,
        show_node_options: { ...DEFAULT_SHOW_NODE_OPTIONS }
      }
    },
    side: {
      matrix: {
        show_node_options: { ...DEFAULT_SHOW_NODE_OPTIONS }
      },
      tree: {
        default_dir: "down",
        show_node_options: { ...DEFAULT_SHOW_NODE_OPTIONS }
      }
    }
  },
  commands: {
    rebuild_graph: {
      notify: true,
      trigger: {
        note_save: false,
        layout_change: false
      }
    },
    list_index: {
      default_options: ListIndex.DEFAULT_OPTIONS
    },
    freeze_implied_edges: {
      default_options: {
        destination: "frontmatter"
      }
    }
  },
  codeblocks: {
    show_node_options: { ...DEFAULT_SHOW_NODE_OPTIONS }
  }
};

// src/const/views.ts
var VIEW_IDS = {
  matrix: "bc-matrix-view",
  tree: "bc-tree-view"
};

// src/graph/MyMultiGraph.ts
var import_graphology = __toESM(require_graphology_umd_min());

// src/graph/objectify_mappers.ts
var objectify_edge_mapper = (cb) => (edge_id, attr2, source_id, target_id, source_attr, target_attr, undirected) => cb({
  id: edge_id,
  attr: attr2,
  source_id,
  target_id,
  source_attr,
  target_attr,
  undirected
});

// src/graph/MyMultiGraph.ts
var EDGE_ATTRIBUTES = [
  "hierarchy_i",
  "dir",
  "field",
  "explicit",
  "source",
  "implied_kind",
  "round"
];
var BCGraph = class extends import_graphology.MultiGraph {
  constructor(input) {
    var _a, _b;
    super();
    /** Uniquely identify an edge based on its:
     * - source_id
     * - target_id
     * - field
     */
    this.make_edge_id = (source_id, target_id, attr2) => `${source_id}|${attr2.field}|${target_id}`;
    // NOTE: These fields are redundant. The `field` field defines which hierarchy_i and dir is chosen anyway,
    //   so it's not adding any extra information to the dedupe key
    // |${attr.hierarchy_i}|${attr.dir}
    // NOTE: These fields shouldn't actually dedupe an edge... I think what the user would consider an edge to be the same
    //   even if it was added for different reasons, but still to and from the same nodes, using the same field.
    //   Consider the commands/freeze-crumbs/index.md note as an example. If these fields were included, the implied relations would still show
    //   even tho there are now frozen real relations serving the exact same purpose.
    // |${attr.explicit ? "explicit|" + attr.source : "implied|" + attr.implied_kind}
    this.safe_add_directed_edge = (source_id, target_id, attr2) => {
      const edge_id = this.make_edge_id(source_id, target_id, attr2);
      if (!this.hasDirectedEdge(edge_id)) {
        this.addDirectedEdgeWithKey(edge_id, source_id, target_id, attr2);
        return true;
      } else {
        return false;
      }
    };
    this.get_out_edges = (node_id) => node_id ? this.mapOutEdges(
      node_id,
      objectify_edge_mapper((e) => e)
    ) : this.mapOutEdges(objectify_edge_mapper((e) => e));
    /** Find aall paths of nodes connected by edges that pair-wise match the attrs in the chain */
    this.get_attrs_chain_path = (start_node, attr_chain, edge_filter) => {
      const visited_nodes = /* @__PURE__ */ new Set();
      return Traverse.all_paths(
        "depth_first",
        this,
        start_node,
        (edge, depth) => {
          const chain_item = attr_chain.at(depth);
          if (!visited_nodes.has(edge.target_id) && (!edge_filter || edge_filter(edge)) && // This will naturally end the path when depth > field_chain.length
          chain_item && has_edge_attrs(edge, chain_item)) {
            visited_nodes.add(edge.target_id);
            return true;
          } else {
            return false;
          }
        }
      ).filter((path4) => path4.length === attr_chain.length);
    };
    if (input) {
      (_a = input.nodes) == null ? void 0 : _a.forEach(
        ({ id, attr: attr2 }) => this.safe_add_node(id, attr2)
      );
      (_b = input.edges) == null ? void 0 : _b.forEach((edge) => {
        this.safe_add_node(edge.source_id, { resolved: true });
        this.safe_add_node(edge.target_id, { resolved: true });
        this.safe_add_directed_edge(
          edge.source_id,
          edge.target_id,
          edge.attr
        );
      });
    }
  }
  safe_add_node(id, attr2) {
    try {
      this.addNode(id, attr2);
      return true;
    } catch (error) {
      return false;
    }
  }
  /** Upsert a node by it's id (path). If it exists, patch attr, else addNode */
  upsert_node(id, attr2) {
    if (this.hasNode(id)) {
      Object.keys(attr2).forEach((key) => {
        this.setNodeAttribute(
          id,
          key,
          attr2[key]
        );
      });
    } else {
      this.addNode(id, attr2);
    }
  }
  safe_rename_node(old_id, new_id) {
    const [old_exists, new_exists] = [
      this.hasNode(old_id),
      this.hasNode(new_id)
    ];
    if (old_exists && !new_exists) {
      this.addNode(new_id, this.getNodeAttributes(old_id));
      const old_in_edges = this.mapInEdges(
        old_id,
        objectify_edge_mapper((e) => e)
      );
      const old_out_edges = this.get_out_edges(old_id);
      this.dropNode(old_id);
      old_in_edges.forEach((old_in_edge) => {
        is_self_loop(old_in_edge) ? this.addDirectedEdge(new_id, new_id, old_in_edge.attr) : this.addDirectedEdge(
          old_in_edge.source_id,
          new_id,
          old_in_edge.attr
        );
      });
      old_out_edges.forEach((old_out_edge) => {
        !is_self_loop(old_out_edge) && this.addDirectedEdge(
          new_id,
          old_out_edge.target_id,
          old_out_edge.attr
        );
      });
    } else {
      console.log("can't safe_rename_node:", old_id, "->", new_id, {
        old_exists,
        new_exists
      });
    }
    return { old_exists, new_exists };
  }
};

// src/graph/builders/explicit/list_note.ts
var import_obsidian = require("obsidian");

// src/const/metadata_fields.ts
var METADATA_FIELDS_LIST = [
  "BC-tag-note-tag",
  "BC-tag-note-field",
  "BC-tag-note-exact",
  //
  "BC-regex-note-regex",
  "BC-regex-note-flags",
  "BC-regex-note-field",
  //
  "BC-folder-note-field",
  "BC-folder-note-recurse",
  //
  "BC-list-note-field",
  "BC-list-note-neighbour-field",
  "BC-list-note-exclude-index",
  //
  "BC-dendron-note-field",
  //
  "BC-dataview-note-query",
  "BC-dataview-note-field"
];
var META_FIELD = {
  "tag-note-tag": "BC-tag-note-tag",
  "tag-note-field": "BC-tag-note-field",
  "tag-note-exact": "BC-tag-note-exact",
  //
  "regex-note-regex": "BC-regex-note-regex",
  "regex-note-flags": "BC-regex-note-flags",
  "regex-note-field": "BC-regex-note-field",
  //
  "folder-note-field": "BC-folder-note-field",
  "folder-note-recurse": "BC-folder-note-recurse",
  //
  "list-note-field": "BC-list-note-field",
  "list-note-neighbour-field": "BC-list-note-neighbour-field",
  "list-note-exclude-index": "BC-list-note-exclude-index",
  //
  "dendron-note-field": "BC-dendron-note-field",
  //
  "dataview-note-query": "BC-dataview-note-query",
  "dataview-note-field": "BC-dataview-note-field"
};
if (Object.keys(META_FIELD).length !== METADATA_FIELDS_LIST.length) {
  throw new Error("Missing keys in META_FIELD");
}

// src/utils/obsidian.ts
var resolve_relative_target_path = (app, relative_target_path, source_path) => {
  var _a;
  const extensioned = Paths.ensure_ext(relative_target_path);
  const target_file = app.metadataCache.getFirstLinkpathDest(
    extensioned,
    source_path
  );
  const target_path = (_a = target_file == null ? void 0 : target_file.path) != null ? _a : Links.resolve_to_absolute_path(app, extensioned, source_path);
  return [target_path, target_file];
};

// src/utils/result.ts
var succ = (data) => ({
  ok: true,
  data,
  log: (prefix) => console.log(`${prefix != null ? prefix : ""} data ${data}`)
});
var fail = (error) => ({
  ok: false,
  error,
  log: (prefix) => console.log(`${prefix != null ? prefix : ""} error ${error}`)
});
var graph_build_fail = (error) => fail(error);

// src/graph/builders/explicit/list_note.ts
var get_list_note_info = (plugin, metadata, path4) => {
  if (!metadata) {
    return fail(void 0);
  }
  const field = metadata[META_FIELD["list-note-field"]];
  if (!field) {
    return fail(void 0);
  } else if (typeof field !== "string") {
    return graph_build_fail({
      path: path4,
      code: "invalid_field_value",
      message: "list-note-field is not a string"
    });
  }
  const field_hierarchy = get_field_hierarchy(
    plugin.settings.hierarchies,
    field
  );
  if (!field_hierarchy) {
    return graph_build_fail({
      path: path4,
      code: "invalid_field_value",
      message: `list-note-field is not a valid BC field: '${field}'`
    });
  }
  const neighbour_field = metadata[META_FIELD["list-note-neighbour-field"]];
  const neighbour_hierarchy = neighbour_field && typeof neighbour_field === "string" ? get_field_hierarchy(plugin.settings.hierarchies, neighbour_field) : null;
  const exclude_index = Boolean(
    metadata[META_FIELD["list-note-exclude-index"]]
  );
  return succ({
    field,
    exclude_index,
    dir: field_hierarchy.dir,
    hierarchy_i: field_hierarchy.hierarchy_i,
    neighbour: neighbour_hierarchy ? {
      dir: neighbour_hierarchy.dir,
      field: neighbour_field,
      hierarchy_i: neighbour_hierarchy.hierarchy_i
    } : void 0
  });
};
var FIELD_OVERRIDE_REGEX = /^\s*([-\w\s]+)\b/;
var resolve_field_override = (plugin, list_item, path4) => {
  var _a;
  const field_override = (_a = list_item.text.match(FIELD_OVERRIDE_REGEX)) == null ? void 0 : _a[1];
  if (!field_override)
    return succ(void 0);
  const resolved_field_hierarchy = get_field_hierarchy(
    plugin.settings.hierarchies,
    field_override
  );
  if (!resolved_field_hierarchy) {
    return graph_build_fail({
      path: path4,
      code: "invalid_field_value",
      message: `Field override is not a valid BC field: ${field_override}. Line: ${list_item.position.start.line}`
    });
  }
  return succ({
    field: field_override,
    dir: resolved_field_hierarchy.dir,
    hierarchy_i: resolved_field_hierarchy.hierarchy_i
  });
};
var handle_neighbour_list_item = ({
  graph,
  plugin,
  source_path,
  list_note_page,
  list_note_info,
  source_list_item_i
}) => {
  const source_list_item = (
    // NOTE: Known to exist, since we wouldn't have reached this function if it didn't
    list_note_page.file.lists.values[source_list_item_i]
  );
  let neighbour_list_item;
  for (let i = source_list_item_i + 1; i < list_note_page.file.lists.values.length; i++) {
    const item = list_note_page.file.lists.values[i];
    if (item.position.start.col < source_list_item.position.start.col) {
      break;
    } else if (item.position.start.col === source_list_item.position.start.col) {
      neighbour_list_item = item;
      break;
    }
  }
  if (!neighbour_list_item || !list_note_info.data.neighbour) {
    return;
  }
  const neighbour_link = neighbour_list_item.outlinks.at(0);
  if (!neighbour_link)
    return;
  const [path4, file] = resolve_relative_target_path(
    plugin.app,
    neighbour_link.path,
    list_note_page.file.path
  );
  if (!file) {
    graph.safe_add_node(path4, { resolved: false });
  }
  graph.safe_add_directed_edge(source_path, path4, {
    explicit: true,
    source: "list_note",
    dir: list_note_info.data.neighbour.dir,
    field: list_note_info.data.neighbour.field,
    hierarchy_i: list_note_info.data.neighbour.hierarchy_i
  });
};
var _add_explicit_edges_list_note = (graph, plugin, all_files) => {
  var _a, _b;
  const errors = [];
  (_a = all_files.obsidian) == null ? void 0 : _a.forEach(
    ({ file: list_note_file, cache: list_note_cache }) => {
      if (!list_note_cache)
        return;
      const list_note_info = get_list_note_info(
        plugin,
        list_note_cache == null ? void 0 : list_note_cache.frontmatter,
        list_note_file.path
      );
      if (!list_note_info.ok) {
        if (list_note_info.error)
          errors.push(list_note_info.error);
        return;
      } else {
        new import_obsidian.Notice(
          "list-notes are not implemented without Dataview enabled"
        );
      }
    }
  );
  (_b = all_files.dataview) == null ? void 0 : _b.forEach((list_note_page) => {
    const list_note_info = get_list_note_info(
      plugin,
      list_note_page,
      list_note_page.file.path
    );
    if (!list_note_info.ok) {
      if (list_note_info.error)
        errors.push(list_note_info.error);
      return;
    }
    list_note_page.file.lists.values.forEach(
      (source_list_item, source_list_item_i) => {
        var _a2;
        const source_link = source_list_item.outlinks.at(0);
        if (!source_link)
          return;
        const [source_path, source_file] = resolve_relative_target_path(
          plugin.app,
          source_link.path,
          list_note_page.file.path
        );
        if (!source_file) {
          graph.safe_add_node(source_path, { resolved: false });
        }
        if (!list_note_info.data.exclude_index && source_list_item.position.start.col === 0) {
          const source_field_hierarchy = resolve_field_override(
            plugin,
            source_list_item,
            list_note_page.file.path
          );
          if (!source_field_hierarchy.ok) {
            if (source_field_hierarchy.error) {
              errors.push(source_field_hierarchy.error);
            }
            return;
          }
          graph.safe_add_directed_edge(
            list_note_page.file.path,
            source_path,
            {
              explicit: true,
              source: "list_note",
              ...(_a2 = source_field_hierarchy.data) != null ? _a2 : list_note_info.data
            }
          );
        }
        handle_neighbour_list_item({
          graph,
          plugin,
          source_path,
          list_note_info,
          list_note_page,
          source_list_item_i
        });
        source_list_item.children.forEach((target_list_item) => {
          var _a3;
          const target_link = target_list_item.outlinks.at(0);
          if (!target_link)
            return;
          const target_field_hierarchy = resolve_field_override(
            plugin,
            target_list_item,
            list_note_page.file.path
          );
          if (!target_field_hierarchy.ok) {
            if (target_field_hierarchy.error) {
              errors.push(target_field_hierarchy.error);
            }
            return;
          }
          const [target_path] = resolve_relative_target_path(
            plugin.app,
            target_link.path,
            list_note_page.file.path
          );
          graph.safe_add_node(target_path, { resolved: false });
          graph.safe_add_directed_edge(source_path, target_path, {
            explicit: true,
            source: "list_note",
            ...(_a3 = target_field_hierarchy.data) != null ? _a3 : list_note_info.data
          });
        });
      }
    );
  });
  return { errors };
};

// src/graph/builders/explicit/tag_note.ts
var get_tag_note_info = (plugin, metadata, path4) => {
  var _a;
  if (!metadata) {
    return fail(void 0);
  }
  let raw_tag = metadata[META_FIELD["tag-note-tag"]];
  if (!raw_tag) {
    raw_tag = metadata["BC-tag-note"];
    if (raw_tag) {
      console.warn(
        `DEPRECATED: BC-tag-note is deprecated in favor of ${META_FIELD["tag-note-tag"]}`
      );
    }
  }
  if (!raw_tag) {
    return fail(void 0);
  } else if (typeof raw_tag !== "string") {
    return graph_build_fail({
      path: path4,
      code: "invalid_field_value",
      message: "tag-note-tag is not a string"
    });
  }
  const tag = ensure_starts_with(raw_tag, "#");
  const field = (_a = metadata[META_FIELD["tag-note-field"]]) != null ? _a : plugin.settings.explicit_edge_sources.tag_note.default_field;
  if (!field) {
    return fail(void 0);
  } else if (typeof field !== "string") {
    return graph_build_fail({
      path: path4,
      code: "invalid_field_value",
      message: "tag-note-field is not a string"
    });
  }
  const field_hierarchy = get_field_hierarchy(
    plugin.settings.hierarchies,
    field
  );
  if (!field_hierarchy) {
    return graph_build_fail({
      path: path4,
      code: "invalid_field_value",
      message: `tag-note-field is not a valid BC field: '${field}'`
    });
  }
  const exact = Boolean(metadata[META_FIELD["tag-note-exact"]]);
  return succ({ tag, field, exact, field_hierarchy });
};
var _add_explicit_edges_tag_note = (graph, plugin, all_files) => {
  var _a, _b;
  const errors = [];
  const tag_notes = [];
  const tag_paths_map = /* @__PURE__ */ new Map();
  (_a = all_files.obsidian) == null ? void 0 : _a.forEach(
    ({ file: tag_note_file, cache: tag_note_cache }) => {
      var _a2;
      if (!tag_note_cache)
        return;
      (_a2 = tag_note_cache == null ? void 0 : tag_note_cache.tags) == null ? void 0 : _a2.forEach(({ tag: tag2 }) => {
        var _a3;
        if (!((_a3 = tag_paths_map.get(tag2)) == null ? void 0 : _a3.push(tag_note_file.path))) {
          tag_paths_map.set(tag2, [tag_note_file.path]);
        }
      });
      const tag_note_info = get_tag_note_info(
        plugin,
        tag_note_cache == null ? void 0 : tag_note_cache.frontmatter,
        tag_note_file.path
      );
      if (!tag_note_info.ok) {
        if (tag_note_info.error)
          errors.push(tag_note_info.error);
        return;
      }
      const { tag, field, exact, field_hierarchy } = tag_note_info.data;
      tag_notes.push({
        tag,
        exact,
        field,
        dir: field_hierarchy.dir,
        source_path: tag_note_file.path,
        hierarchy_i: field_hierarchy.hierarchy_i
      });
    }
  );
  (_b = all_files.dataview) == null ? void 0 : _b.forEach((page) => {
    const tag_note_file = page.file;
    tag_note_file.etags.values.forEach((tag2) => {
      var _a2;
      if (!((_a2 = tag_paths_map.get(tag2)) == null ? void 0 : _a2.push(tag_note_file.path))) {
        tag_paths_map.set(tag2, [tag_note_file.path]);
      }
    });
    const tag_note_info = get_tag_note_info(
      plugin,
      page,
      tag_note_file.path
    );
    if (!tag_note_info.ok) {
      if (tag_note_info.error)
        errors.push(tag_note_info.error);
      return;
    }
    const { tag, field, exact, field_hierarchy } = tag_note_info.data;
    tag_notes.push({
      tag,
      exact,
      field,
      dir: field_hierarchy.dir,
      source_path: tag_note_file.path,
      hierarchy_i: field_hierarchy.hierarchy_i
    });
  });
  const tag_path_keys = [...tag_paths_map.keys()];
  tag_notes.forEach((tag_note) => {
    const target_paths = tag_note.exact ? tag_paths_map.get(tag_note.tag) : tag_path_keys.filter((tag) => tag.startsWith(tag_note.tag)).flatMap((tag) => tag_paths_map.get(tag));
    target_paths == null ? void 0 : target_paths.forEach((target_path) => {
      graph.safe_add_directed_edge(tag_note.source_path, target_path, {
        explicit: true,
        dir: tag_note.dir,
        source: "tag_note",
        field: tag_note.field,
        hierarchy_i: tag_note.hierarchy_i
      });
    });
  });
  return { errors };
};

// src/utils/arrays.ts
var swap_items = (i, j, arr) => {
  const max = arr.length - 1;
  if (i < 0 || i > max || j < 0 || j > max)
    return arr;
  const tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
  return arr;
};
var ensure_is_array = (maybe_array) => {
  if (Array.isArray(maybe_array))
    return maybe_array;
  return [maybe_array];
};
var ensure_square_array = (arr, fill, pre) => {
  const max_width = Math.max(...arr.map((row) => row.length));
  return arr.map((row) => {
    const diff = max_width - row.length;
    if (pre) {
      return Array(diff).fill(fill).concat(row);
    } else {
      return row.concat(Array(diff).fill(fill));
    }
  });
};
var transpose = (arr) => {
  const transposed = [];
  if (!arr.length)
    return transposed;
  for (let i = 0; i < arr.at(0).length; i++) {
    transposed.push([]);
    for (let j = 0; j < arr.length; j++) {
      transposed[i].push(arr[j][i]);
    }
  }
  return transposed;
};
var gather_by_runs = (arr, get_value) => {
  const runs = [];
  for (let i = 0; i < arr.length; i++) {
    const last_run = runs.at(-1);
    const value = get_value(arr[i]);
    if (last_run && last_run.value === value) {
      last_run.last = i;
    } else {
      runs.push({ value, first: i, last: i });
    }
  }
  return runs;
};
var group_by = (list, get_value, project = (item) => item) => {
  const grouped = {};
  list.forEach((item) => {
    const key = get_value(item);
    if (key === void 0)
      return;
    const group = grouped[key];
    const projected = project(item);
    if (!group)
      grouped[key] = [projected];
    else
      group.push(projected);
  });
  return grouped;
};
var remove_duplicates = (arr) => {
  const set = new Set(arr);
  return Array.from(set);
};

// src/graph/builders/explicit/typed_link.ts
var MARKDOWN_LINK_REGEX = /\[(.+?)\]\((.+?)\)/;
var _add_explicit_edges_typed_link = (graph, plugin, all_files) => {
  var _a, _b;
  const errors = [];
  (_a = all_files.obsidian) == null ? void 0 : _a.forEach(
    ({ file: source_file, cache: source_cache }) => {
      var _a2;
      (_a2 = source_cache == null ? void 0 : source_cache.frontmatterLinks) == null ? void 0 : _a2.forEach((target_link) => {
        const field = target_link.key.split(".")[0];
        const field_hierarchy = get_field_hierarchy(
          plugin.settings.hierarchies,
          field
        );
        if (!field_hierarchy)
          return;
        const [target_path, target_file] = resolve_relative_target_path(
          plugin.app,
          target_link.link,
          source_file.path
        );
        if (!target_file) {
          graph.safe_add_node(target_path, { resolved: false });
        }
        graph.safe_add_directed_edge(source_file.path, target_path, {
          field,
          explicit: true,
          source: "typed_link",
          dir: field_hierarchy.dir,
          hierarchy_i: field_hierarchy.hierarchy_i
        });
      });
    }
  );
  (_b = all_files.dataview) == null ? void 0 : _b.forEach((page) => {
    const source_file = page.file;
    Object.keys(page).forEach((field) => {
      if (["file", "aliases"].includes(field))
        return;
      const field_hierarchy = get_field_hierarchy(
        plugin.settings.hierarchies,
        field
      );
      if (!field_hierarchy)
        return;
      ensure_is_array(page[field]).flat().forEach((target_link) => {
        var _a2;
        let unsafe_target_path;
        if (typeof target_link === "string") {
          unsafe_target_path = (_a2 = target_link.match(MARKDOWN_LINK_REGEX)) == null ? void 0 : _a2[2];
        } else if (typeof target_link === "object" && (target_link == null ? void 0 : target_link.path)) {
          unsafe_target_path = target_link.path;
        } else {
          console.log("Invalid target_link type", target_link);
        }
        if (!unsafe_target_path) {
          return errors.push({
            code: "invalid_field_value",
            message: `Invalid field value for '${field}'`,
            path: source_file.path
          });
        }
        const [target_path, target_file] = resolve_relative_target_path(
          plugin.app,
          unsafe_target_path,
          source_file.path
        );
        if (!target_file) {
          graph.safe_add_node(target_path, { resolved: false });
        }
        graph.safe_add_directed_edge(
          source_file.path,
          target_path,
          {
            field,
            explicit: true,
            source: "typed_link",
            dir: field_hierarchy.dir,
            hierarchy_i: field_hierarchy.hierarchy_i
          }
        );
      });
    });
  });
  return { errors };
};

// src/graph/builders/explicit/dendron_note.ts
var import_path2 = __toESM(require("path"));
var get_dendron_note_info = (plugin, metadata, path4) => {
  var _a;
  const field = (_a = metadata == null ? void 0 : metadata[META_FIELD["dendron-note-field"]]) != null ? _a : (
    //   Which is why we have a default_field on dendron_note
    plugin.settings.explicit_edge_sources.dendron_note.default_field
  );
  if (!field) {
    return fail(void 0);
  } else if (typeof field !== "string") {
    return graph_build_fail({
      path: path4,
      code: "invalid_field_value",
      message: "dendron-note-field is not a string"
    });
  }
  const field_hierarchy = get_field_hierarchy(
    plugin.settings.hierarchies,
    field
  );
  if (!field_hierarchy) {
    return graph_build_fail({
      path: path4,
      code: "invalid_field_value",
      message: `dendron-note-field is not a valid BC field: '${field}'`
    });
  }
  return succ({ field, field_hierarchy });
};
var handle_dendron_note = (plugin, graph, source_path, source_metadata, errors) => {
  const { delimiter } = plugin.settings.explicit_edge_sources.dendron_note;
  const source_basename_splits = Paths.drop_ext(
    import_path2.default.basename(source_path)
  ).split(delimiter);
  if (source_basename_splits.length === 1)
    return;
  const dendron_note_info = get_dendron_note_info(
    plugin,
    source_metadata,
    source_path
  );
  if (!dendron_note_info.ok) {
    if (dendron_note_info.error) {
      errors.push(dendron_note_info.error);
    }
    return;
  }
  const target_basename = source_basename_splits.slice(0, -1).join(delimiter);
  const target_folder_splits = source_path.split("/").slice(0, -1);
  const target_folder = (
    // Check if it's in the root folder
    target_folder_splits.length === 0 ? (
      // Nodes are added as their full path, but without the leading /
      ""
    ) : target_folder_splits.join("/") + "/"
  );
  const target_path = `${target_folder}${target_basename}${import_path2.default.extname(source_path)}`;
  const target_file = plugin.app.vault.getAbstractFileByPath(target_path);
  const { field, field_hierarchy } = dendron_note_info.data;
  if (!target_file) {
    graph.safe_add_node(target_path, { resolved: false });
    handle_dendron_note(
      plugin,
      graph,
      target_path,
      // This is really quite elegant :)
      //   The unresolved note has no BC-dendron field, by definition
      //   Passing undefined would just use the settings.default field
      //   But we can propagate the field from the resolved source note, to stay in the same hierarchy
      { [META_FIELD["dendron-note-field"]]: field },
      errors
    );
  }
  graph.safe_add_directed_edge(source_path, target_path, {
    field,
    explicit: true,
    source: "dendron_note",
    dir: field_hierarchy.dir,
    hierarchy_i: field_hierarchy.hierarchy_i
  });
};
var _add_explicit_edges_dendron_note = (graph, plugin, all_files) => {
  var _a, _b;
  const errors = [];
  if (!plugin.settings.explicit_edge_sources.dendron_note.enabled) {
    return { errors };
  }
  (_a = all_files.obsidian) == null ? void 0 : _a.forEach(({ file, cache }) => {
    handle_dendron_note(
      plugin,
      graph,
      file.path,
      cache == null ? void 0 : cache.frontmatter,
      errors
    );
  });
  (_b = all_files.dataview) == null ? void 0 : _b.forEach((page) => {
    handle_dendron_note(plugin, graph, page.file.path, page, errors);
  });
  return { errors };
};

// src/graph/builders/explicit/dataview_note.ts
var import_obsidian4 = require("obsidian");

// src/external/dataview/index.ts
var import_obsidian_dataview = __toESM(require_lib());
var await_if_enabled = (plugin) => new Promise((resolve) => {
  var _a;
  if ((0, import_obsidian_dataview.isPluginEnabled)(plugin.app)) {
    if ((_a = (0, import_obsidian_dataview.getAPI)(plugin.app)) == null ? void 0 : _a.index.initialized) {
      console.log("dataview index already initialized");
      resolve();
    }
    plugin.registerEvent(
      plugin.app.metadataCache.on(
        //@ts-ignore: It's there if dataview is enabled
        "dataview:index-ready",
        () => resolve()
      )
    );
  } else {
    console.log("dataview not enabled");
    resolve();
  }
});
var dataview_plugin = {
  get_api: import_obsidian_dataview.getAPI,
  is_enabled: import_obsidian_dataview.isPluginEnabled,
  await_if_enabled
};

// src/graph/builders/explicit/dataview_note.ts
var get_dataview_note_info = (plugin, metadata, path4) => {
  if (!metadata) {
    return fail(void 0);
  }
  const query = metadata[META_FIELD["dataview-note-query"]];
  if (!query) {
    return fail(void 0);
  } else if (typeof query !== "string") {
    return graph_build_fail({
      path: path4,
      code: "invalid_field_value",
      message: "dataview-note-query is not a string"
    });
  }
  const field = metadata[META_FIELD["dataview-note-field"]];
  if (!field) {
    return fail(void 0);
  } else if (typeof field !== "string") {
    return graph_build_fail({
      path: path4,
      code: "invalid_field_value",
      message: "dataview-note-field is not a string"
    });
  }
  const field_hierarchy = get_field_hierarchy(
    plugin.settings.hierarchies,
    field
  );
  if (!field_hierarchy) {
    return graph_build_fail({
      path: path4,
      code: "invalid_field_value",
      message: `dataview-note-field is not a valid BC field: '${field}'`
    });
  }
  return succ({
    field,
    query,
    dir: field_hierarchy.dir,
    hierarchy_i: field_hierarchy.hierarchy_i
  });
};
var _add_explicit_edges_dataview_note = (graph, plugin, all_files) => {
  var _a, _b;
  const errors = [];
  (_a = all_files.obsidian) == null ? void 0 : _a.forEach(
    ({ file: dataview_note_file, cache: dataview_note_cache }) => {
      if (!dataview_note_cache)
        return;
      const dataview_note_info = get_dataview_note_info(
        plugin,
        dataview_note_cache == null ? void 0 : dataview_note_cache.frontmatter,
        dataview_note_file.path
      );
      if (!dataview_note_info.ok) {
        if (dataview_note_info.error)
          errors.push(dataview_note_info.error);
        return;
      } else {
        new import_obsidian4.Notice(
          "dataview-notes are not implemented without Dataview enabled"
        );
      }
    }
  );
  (_b = all_files.dataview) == null ? void 0 : _b.forEach((dataview_note_page) => {
    const dataview_note_info = get_dataview_note_info(
      plugin,
      dataview_note_page,
      dataview_note_page.file.path
    );
    if (!dataview_note_info.ok) {
      if (dataview_note_info.error)
        errors.push(dataview_note_info.error);
      return;
    }
    const { field, query, dir, hierarchy_i } = dataview_note_info.data;
    let pages = [];
    try {
      pages = dataview_plugin.get_api().pages(query).values;
    } catch (error) {
      console.log("dataview-note DV API error", error);
      return errors.push({
        code: "invalid_field_value",
        path: dataview_note_page.file.path,
        message: `dataview-note-query is not a valid dataview query: '${query}'`
      });
    }
    pages.forEach((page) => {
      graph.safe_add_directed_edge(
        dataview_note_page.file.path,
        page.file.path,
        {
          dir,
          field,
          hierarchy_i,
          explicit: true,
          source: "dataview_note"
        }
      );
    });
  });
  return { errors };
};

// node_modules/luxon/src/errors.js
var LuxonError = class extends Error {
};
var InvalidDateTimeError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid DateTime: ${reason.toMessage()}`);
  }
};
var InvalidIntervalError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Interval: ${reason.toMessage()}`);
  }
};
var InvalidDurationError = class extends LuxonError {
  constructor(reason) {
    super(`Invalid Duration: ${reason.toMessage()}`);
  }
};
var ConflictingSpecificationError = class extends LuxonError {
};
var InvalidUnitError = class extends LuxonError {
  constructor(unit) {
    super(`Invalid unit ${unit}`);
  }
};
var InvalidArgumentError = class extends LuxonError {
};
var ZoneIsAbstractError = class extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
};

// node_modules/luxon/src/impl/formats.js
var n = "numeric";
var s = "short";
var l = "long";
var DATE_SHORT = {
  year: n,
  month: n,
  day: n
};
var DATE_MED = {
  year: n,
  month: s,
  day: n
};
var DATE_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s
};
var DATE_FULL = {
  year: n,
  month: l,
  day: n
};
var DATE_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l
};
var TIME_SIMPLE = {
  hour: n,
  minute: n
};
var TIME_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n
};
var TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};
var TIME_24_SIMPLE = {
  hour: n,
  minute: n,
  hourCycle: "h23"
};
var TIME_24_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23"
};
var TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: s
};
var TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: l
};
var DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n
};
var DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s,
  day: n,
  hour: n,
  minute: n,
  second: n
};
var DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s,
  day: n,
  weekday: s,
  hour: n,
  minute: n
};
var DATETIME_FULL = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  timeZoneName: s
};
var DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s
};
var DATETIME_HUGE = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  timeZoneName: l
};
var DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l,
  day: n,
  weekday: l,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l
};

// node_modules/luxon/src/zone.js
var Zone = class {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new ZoneIsAbstractError();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new ZoneIsAbstractError();
  }
  get ianaName() {
    return this.name;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(ts, opts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(ts, format) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(otherZone) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new ZoneIsAbstractError();
  }
};

// node_modules/luxon/src/zones/systemZone.js
var singleton = null;
var SystemZone = class _SystemZone extends Zone {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    if (singleton === null) {
      singleton = new _SystemZone();
    }
    return singleton;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale);
  }
  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /** @override **/
  offset(ts) {
    return -new Date(ts).getTimezoneOffset();
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "system";
  }
  /** @override **/
  get isValid() {
    return true;
  }
};

// node_modules/luxon/src/zones/IANAZone.js
var dtfCache = {};
function makeDTF(zone) {
  if (!dtfCache[zone]) {
    dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: zone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short"
    });
  }
  return dtfCache[zone];
}
var typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function hackyOffset(dtf, date) {
  const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}
function partsOffset(dtf, date) {
  const formatted = dtf.formatToParts(date);
  const filled = [];
  for (let i = 0; i < formatted.length; i++) {
    const { type, value } = formatted[i];
    const pos = typeToPos[type];
    if (type === "era") {
      filled[pos] = value;
    } else if (!isUndefined(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}
var ianaZoneCache = {};
var IANAZone = class _IANAZone extends Zone {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(name) {
    if (!ianaZoneCache[name]) {
      ianaZoneCache[name] = new _IANAZone(name);
    }
    return ianaZoneCache[name];
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    ianaZoneCache = {};
    dtfCache = {};
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
   * @return {boolean}
   */
  static isValidSpecifier(s2) {
    return this.isValidZone(s2);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
      return true;
    } catch (e) {
      return false;
    }
  }
  constructor(name) {
    super();
    this.zoneName = name;
    this.valid = _IANAZone.isValidZone(name);
  }
  /** @override **/
  get type() {
    return "iana";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName(ts, { format, locale }) {
    return parseZoneInfo(ts, format, locale, this.name);
  }
  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /** @override **/
  offset(ts) {
    const date = new Date(ts);
    if (isNaN(date))
      return NaN;
    const dtf = makeDTF(this.name);
    let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
    if (adOrBc === "BC") {
      year = -Math.abs(year) + 1;
    }
    const adjustedHour = hour === 24 ? 0 : hour;
    const asUTC = objToLocalTS({
      year,
      month,
      day,
      hour: adjustedHour,
      minute,
      second,
      millisecond: 0
    });
    let asTS = +date;
    const over = asTS % 1e3;
    asTS -= over >= 0 ? over : 1e3 + over;
    return (asUTC - asTS) / (60 * 1e3);
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "iana" && otherZone.name === this.name;
  }
  /** @override **/
  get isValid() {
    return this.valid;
  }
};

// node_modules/luxon/src/impl/locale.js
var intlLFCache = {};
function getCachedLF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlLFCache[key];
  if (!dtf) {
    dtf = new Intl.ListFormat(locString, opts);
    intlLFCache[key] = dtf;
  }
  return dtf;
}
var intlDTCache = {};
function getCachedDTF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let dtf = intlDTCache[key];
  if (!dtf) {
    dtf = new Intl.DateTimeFormat(locString, opts);
    intlDTCache[key] = dtf;
  }
  return dtf;
}
var intlNumCache = {};
function getCachedINF(locString, opts = {}) {
  const key = JSON.stringify([locString, opts]);
  let inf = intlNumCache[key];
  if (!inf) {
    inf = new Intl.NumberFormat(locString, opts);
    intlNumCache[key] = inf;
  }
  return inf;
}
var intlRelCache = {};
function getCachedRTF(locString, opts = {}) {
  const { base, ...cacheKeyOpts } = opts;
  const key = JSON.stringify([locString, cacheKeyOpts]);
  let inf = intlRelCache[key];
  if (!inf) {
    inf = new Intl.RelativeTimeFormat(locString, opts);
    intlRelCache[key] = inf;
  }
  return inf;
}
var sysLocaleCache = null;
function systemLocale() {
  if (sysLocaleCache) {
    return sysLocaleCache;
  } else {
    sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
    return sysLocaleCache;
  }
}
var weekInfoCache = {};
function getCachedWeekInfo(locString) {
  let data = weekInfoCache[locString];
  if (!data) {
    const locale = new Intl.Locale(locString);
    data = "getWeekInfo" in locale ? locale.getWeekInfo() : locale.weekInfo;
    weekInfoCache[locString] = data;
  }
  return data;
}
function parseLocaleString(localeStr) {
  const xIndex = localeStr.indexOf("-x-");
  if (xIndex !== -1) {
    localeStr = localeStr.substring(0, xIndex);
  }
  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    let selectedStr;
    try {
      options = getCachedDTF(localeStr).resolvedOptions();
      selectedStr = localeStr;
    } catch (e) {
      const smaller = localeStr.substring(0, uIndex);
      options = getCachedDTF(smaller).resolvedOptions();
      selectedStr = smaller;
    }
    const { numberingSystem, calendar } = options;
    return [selectedStr, numberingSystem, calendar];
  }
}
function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    if (!localeStr.includes("-u-")) {
      localeStr += "-u";
    }
    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }
    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}
function mapMonths(f) {
  const ms = [];
  for (let i = 1; i <= 12; i++) {
    const dt = DateTime.utc(2009, i, 1);
    ms.push(f(dt));
  }
  return ms;
}
function mapWeekdays(f) {
  const ms = [];
  for (let i = 1; i <= 7; i++) {
    const dt = DateTime.utc(2016, 11, 13 + i);
    ms.push(f(dt));
  }
  return ms;
}
function listStuff(loc, length, englishFn, intlFn) {
  const mode = loc.listingMode();
  if (mode === "error") {
    return null;
  } else if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}
function supportsFastNumbers(loc) {
  if (loc.numberingSystem && loc.numberingSystem !== "latn") {
    return false;
  } else {
    return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
  }
}
var PolyNumberFormatter = class {
  constructor(intl, forceSimple, opts) {
    this.padTo = opts.padTo || 0;
    this.floor = opts.floor || false;
    const { padTo, floor, ...otherOpts } = opts;
    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = { useGrouping: false, ...opts };
      if (opts.padTo > 0)
        intlOpts.minimumIntegerDigits = opts.padTo;
      this.inf = getCachedINF(intl, intlOpts);
    }
  }
  format(i) {
    if (this.inf) {
      const fixed = this.floor ? Math.floor(i) : i;
      return this.inf.format(fixed);
    } else {
      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
      return padStart(fixed, this.padTo);
    }
  }
};
var PolyDateFormatter = class {
  constructor(dt, intl, opts) {
    this.opts = opts;
    this.originalZone = void 0;
    let z = void 0;
    if (this.opts.timeZone) {
      this.dt = dt;
    } else if (dt.zone.type === "fixed") {
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
        z = offsetZ;
        this.dt = dt;
      } else {
        z = "UTC";
        this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
        this.originalZone = dt.zone;
      }
    } else if (dt.zone.type === "system") {
      this.dt = dt;
    } else if (dt.zone.type === "iana") {
      this.dt = dt;
      z = dt.zone.name;
    } else {
      z = "UTC";
      this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
      this.originalZone = dt.zone;
    }
    const intlOpts = { ...this.opts };
    intlOpts.timeZone = intlOpts.timeZone || z;
    this.dtf = getCachedDTF(intl, intlOpts);
  }
  format() {
    if (this.originalZone) {
      return this.formatToParts().map(({ value }) => value).join("");
    }
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const parts = this.dtf.formatToParts(this.dt.toJSDate());
    if (this.originalZone) {
      return parts.map((part) => {
        if (part.type === "timeZoneName") {
          const offsetName = this.originalZone.offsetName(this.dt.ts, {
            locale: this.dt.locale,
            format: this.opts.timeZoneName
          });
          return {
            ...part,
            value: offsetName
          };
        } else {
          return part;
        }
      });
    }
    return parts;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
};
var PolyRelFormatter = class {
  constructor(intl, isEnglish, opts) {
    this.opts = { style: "long", ...opts };
    if (!isEnglish && hasRelative()) {
      this.rtf = getCachedRTF(intl, opts);
    }
  }
  format(count, unit) {
    if (this.rtf) {
      return this.rtf.format(count, unit);
    } else {
      return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
    }
  }
  formatToParts(count, unit) {
    if (this.rtf) {
      return this.rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  }
};
var fallbackWeekSettings = {
  firstDay: 1,
  minimalDays: 4,
  weekend: [6, 7]
};
var Locale = class _Locale {
  static fromOpts(opts) {
    return _Locale.create(
      opts.locale,
      opts.numberingSystem,
      opts.outputCalendar,
      opts.weekSettings,
      opts.defaultToEN
    );
  }
  static create(locale, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {
    const specifiedLocale = locale || Settings.defaultLocale;
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    const weekSettingsR = validateWeekSettings(weekSettings) || Settings.defaultWeekSettings;
    return new _Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);
  }
  static resetCache() {
    sysLocaleCache = null;
    intlDTCache = {};
    intlNumCache = {};
    intlRelCache = {};
  }
  static fromObject({ locale, numberingSystem, outputCalendar, weekSettings } = {}) {
    return _Locale.create(locale, numberingSystem, outputCalendar, weekSettings);
  }
  constructor(locale, numbering, outputCalendar, weekSettings, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
    this.locale = parsedLocale;
    this.numberingSystem = numbering || parsedNumberingSystem || null;
    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
    this.weekSettings = weekSettings;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = specifiedLocale;
    this.fastNumbersCached = null;
  }
  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }
    return this.fastNumbersCached;
  }
  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }
  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return _Locale.create(
        alts.locale || this.specifiedLocale,
        alts.numberingSystem || this.numberingSystem,
        alts.outputCalendar || this.outputCalendar,
        validateWeekSettings(alts.weekSettings) || this.weekSettings,
        alts.defaultToEN || false
      );
    }
  }
  redefaultToEN(alts = {}) {
    return this.clone({ ...alts, defaultToEN: true });
  }
  redefaultToSystem(alts = {}) {
    return this.clone({ ...alts, defaultToEN: false });
  }
  months(length, format = false) {
    return listStuff(this, length, months, () => {
      const intl = format ? { month: length, day: "numeric" } : { month: length }, formatStr = format ? "format" : "standalone";
      if (!this.monthsCache[formatStr][length]) {
        this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
      }
      return this.monthsCache[formatStr][length];
    });
  }
  weekdays(length, format = false) {
    return listStuff(this, length, weekdays, () => {
      const intl = format ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format ? "format" : "standalone";
      if (!this.weekdaysCache[formatStr][length]) {
        this.weekdaysCache[formatStr][length] = mapWeekdays(
          (dt) => this.extract(dt, intl, "weekday")
        );
      }
      return this.weekdaysCache[formatStr][length];
    });
  }
  meridiems() {
    return listStuff(
      this,
      void 0,
      () => meridiems,
      () => {
        if (!this.meridiemCache) {
          const intl = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
            (dt) => this.extract(dt, intl, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(length) {
    return listStuff(this, length, eras, () => {
      const intl = { era: length };
      if (!this.eraCache[length]) {
        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(
          (dt) => this.extract(dt, intl, "era")
        );
      }
      return this.eraCache[length];
    });
  }
  extract(dt, intlOpts, field) {
    const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m) => m.type.toLowerCase() === field);
    return matching ? matching.value : null;
  }
  numberFormatter(opts = {}) {
    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
  }
  dtFormatter(dt, intlOpts = {}) {
    return new PolyDateFormatter(dt, this.intl, intlOpts);
  }
  relFormatter(opts = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
  }
  listFormatter(opts = {}) {
    return getCachedLF(this.intl, opts);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  getWeekSettings() {
    if (this.weekSettings) {
      return this.weekSettings;
    } else if (!hasLocaleWeekInfo()) {
      return fallbackWeekSettings;
    } else {
      return getCachedWeekInfo(this.locale);
    }
  }
  getStartOfWeek() {
    return this.getWeekSettings().firstDay;
  }
  getMinDaysInFirstWeek() {
    return this.getWeekSettings().minimalDays;
  }
  getWeekendDays() {
    return this.getWeekSettings().weekend;
  }
  equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  }
};

// node_modules/luxon/src/zones/fixedOffsetZone.js
var singleton2 = null;
var FixedOffsetZone = class _FixedOffsetZone extends Zone {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    if (singleton2 === null) {
      singleton2 = new _FixedOffsetZone(0);
    }
    return singleton2;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(offset2) {
    return offset2 === 0 ? _FixedOffsetZone.utcInstance : new _FixedOffsetZone(offset2);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(s2) {
    if (s2) {
      const r = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (r) {
        return new _FixedOffsetZone(signedOffset(r[1], r[2]));
      }
    }
    return null;
  }
  constructor(offset2) {
    super();
    this.fixed = offset2;
  }
  /** @override **/
  get type() {
    return "fixed";
  }
  /** @override **/
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
    }
  }
  /** @override **/
  offsetName() {
    return this.name;
  }
  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.fixed, format);
  }
  /** @override **/
  get isUniversal() {
    return true;
  }
  /** @override **/
  offset() {
    return this.fixed;
  }
  /** @override **/
  equals(otherZone) {
    return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
  }
  /** @override **/
  get isValid() {
    return true;
  }
};

// node_modules/luxon/src/zones/invalidZone.js
var InvalidZone = class extends Zone {
  constructor(zoneName) {
    super();
    this.zoneName = zoneName;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return false;
  }
  /** @override **/
  get isValid() {
    return false;
  }
};

// node_modules/luxon/src/impl/zoneUtil.js
function normalizeZone(input, defaultZone2) {
  let offset2;
  if (isUndefined(input) || input === null) {
    return defaultZone2;
  } else if (input instanceof Zone) {
    return input;
  } else if (isString(input)) {
    const lowered = input.toLowerCase();
    if (lowered === "default")
      return defaultZone2;
    else if (lowered === "local" || lowered === "system")
      return SystemZone.instance;
    else if (lowered === "utc" || lowered === "gmt")
      return FixedOffsetZone.utcInstance;
    else
      return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
  } else if (isNumber(input)) {
    return FixedOffsetZone.instance(input);
  } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
    return input;
  } else {
    return new InvalidZone(input);
  }
}

// node_modules/luxon/src/settings.js
var now = () => Date.now();
var defaultZone = "system";
var defaultLocale = null;
var defaultNumberingSystem = null;
var defaultOutputCalendar = null;
var twoDigitCutoffYear = 60;
var throwOnInvalid;
var defaultWeekSettings = null;
var Settings = class {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return now;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(n2) {
    now = n2;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(zone) {
    defaultZone = zone;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return defaultLocale;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(locale) {
    defaultLocale = locale;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(numberingSystem) {
    defaultNumberingSystem = numberingSystem;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(outputCalendar) {
    defaultOutputCalendar = outputCalendar;
  }
  /**
   * @typedef {Object} WeekSettings
   * @property {number} firstDay
   * @property {number} minimalDays
   * @property {number[]} weekend
   */
  /**
   * @return {WeekSettings|null}
   */
  static get defaultWeekSettings() {
    return defaultWeekSettings;
  }
  /**
   * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and
   * how many days are required in the first week of a year.
   * Does not affect existing instances.
   *
   * @param {WeekSettings|null} weekSettings
   */
  static set defaultWeekSettings(weekSettings) {
    defaultWeekSettings = validateWeekSettings(weekSettings);
  }
  /**
   * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return twoDigitCutoffYear;
  }
  /**
   * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpreted as current century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
   */
  static set twoDigitCutoffYear(cutoffYear) {
    twoDigitCutoffYear = cutoffYear % 100;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return throwOnInvalid;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t) {
    throwOnInvalid = t;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
  }
};

// node_modules/luxon/src/impl/invalid.js
var Invalid = class {
  constructor(reason, explanation) {
    this.reason = reason;
    this.explanation = explanation;
  }
  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
};

// node_modules/luxon/src/impl/conversions.js
var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(unit, value) {
  return new Invalid(
    "unit out of range",
    `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
  );
}
function dayOfWeek(year, month, day) {
  const d = new Date(Date.UTC(year, month - 1, day));
  if (year < 100 && year >= 0) {
    d.setUTCFullYear(d.getUTCFullYear() - 1900);
  }
  const js = d.getUTCDay();
  return js === 0 ? 7 : js;
}
function computeOrdinal(year, month, day) {
  return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
}
function uncomputeOrdinal(year, ordinal) {
  const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i) => i < ordinal), day = ordinal - table[month0];
  return { month: month0 + 1, day };
}
function isoWeekdayToLocal(isoWeekday, startOfWeek) {
  return (isoWeekday - startOfWeek + 7) % 7 + 1;
}
function gregorianToWeek(gregObj, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = isoWeekdayToLocal(dayOfWeek(year, month, day), startOfWeek);
  let weekNumber = Math.floor((ordinal - weekday + 14 - minDaysInFirstWeek) / 7), weekYear;
  if (weekNumber < 1) {
    weekYear = year - 1;
    weekNumber = weeksInWeekYear(weekYear, minDaysInFirstWeek, startOfWeek);
  } else if (weekNumber > weeksInWeekYear(year, minDaysInFirstWeek, startOfWeek)) {
    weekYear = year + 1;
    weekNumber = 1;
  } else {
    weekYear = year;
  }
  return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
}
function weekToGregorian(weekData, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = isoWeekdayToLocal(dayOfWeek(weekYear, 1, minDaysInFirstWeek), startOfWeek), yearInDays = daysInYear(weekYear);
  let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 7 + minDaysInFirstWeek, year;
  if (ordinal < 1) {
    year = weekYear - 1;
    ordinal += daysInYear(year);
  } else if (ordinal > yearInDays) {
    year = weekYear + 1;
    ordinal -= daysInYear(weekYear);
  } else {
    year = weekYear;
  }
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(weekData) };
}
function gregorianToOrdinal(gregData) {
  const { year, month, day } = gregData;
  const ordinal = computeOrdinal(year, month, day);
  return { year, ordinal, ...timeObject(gregData) };
}
function ordinalToGregorian(ordinalData) {
  const { year, ordinal } = ordinalData;
  const { month, day } = uncomputeOrdinal(year, ordinal);
  return { year, month, day, ...timeObject(ordinalData) };
}
function usesLocalWeekValues(obj, loc) {
  const hasLocaleWeekData = !isUndefined(obj.localWeekday) || !isUndefined(obj.localWeekNumber) || !isUndefined(obj.localWeekYear);
  if (hasLocaleWeekData) {
    const hasIsoWeekData = !isUndefined(obj.weekday) || !isUndefined(obj.weekNumber) || !isUndefined(obj.weekYear);
    if (hasIsoWeekData) {
      throw new ConflictingSpecificationError(
        "Cannot mix locale-based week fields with ISO-based week fields"
      );
    }
    if (!isUndefined(obj.localWeekday))
      obj.weekday = obj.localWeekday;
    if (!isUndefined(obj.localWeekNumber))
      obj.weekNumber = obj.localWeekNumber;
    if (!isUndefined(obj.localWeekYear))
      obj.weekYear = obj.localWeekYear;
    delete obj.localWeekday;
    delete obj.localWeekNumber;
    delete obj.localWeekYear;
    return {
      minDaysInFirstWeek: loc.getMinDaysInFirstWeek(),
      startOfWeek: loc.getStartOfWeek()
    };
  } else {
    return { minDaysInFirstWeek: 4, startOfWeek: 1 };
  }
}
function hasInvalidWeekData(obj, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const validYear = isInteger(obj.weekYear), validWeek = integerBetween(
    obj.weekNumber,
    1,
    weeksInWeekYear(obj.weekYear, minDaysInFirstWeek, startOfWeek)
  ), validWeekday = integerBetween(obj.weekday, 1, 7);
  if (!validYear) {
    return unitOutOfRange("weekYear", obj.weekYear);
  } else if (!validWeek) {
    return unitOutOfRange("week", obj.weekNumber);
  } else if (!validWeekday) {
    return unitOutOfRange("weekday", obj.weekday);
  } else
    return false;
}
function hasInvalidOrdinalData(obj) {
  const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validOrdinal) {
    return unitOutOfRange("ordinal", obj.ordinal);
  } else
    return false;
}
function hasInvalidGregorianData(obj) {
  const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
  if (!validYear) {
    return unitOutOfRange("year", obj.year);
  } else if (!validMonth) {
    return unitOutOfRange("month", obj.month);
  } else if (!validDay) {
    return unitOutOfRange("day", obj.day);
  } else
    return false;
}
function hasInvalidTimeData(obj) {
  const { hour, minute, second, millisecond } = obj;
  const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
  if (!validHour) {
    return unitOutOfRange("hour", hour);
  } else if (!validMinute) {
    return unitOutOfRange("minute", minute);
  } else if (!validSecond) {
    return unitOutOfRange("second", second);
  } else if (!validMillisecond) {
    return unitOutOfRange("millisecond", millisecond);
  } else
    return false;
}

// node_modules/luxon/src/impl/util.js
function isUndefined(o) {
  return typeof o === "undefined";
}
function isNumber(o) {
  return typeof o === "number";
}
function isInteger(o) {
  return typeof o === "number" && o % 1 === 0;
}
function isString(o) {
  return typeof o === "string";
}
function isDate(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e) {
    return false;
  }
}
function hasLocaleWeekInfo() {
  try {
    return typeof Intl !== "undefined" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
  } catch (e) {
    return false;
  }
}
function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return void 0;
  }
  return arr.reduce((best, next) => {
    const pair = [by(next), next];
    if (!best) {
      return pair;
    } else if (compare(best[0], pair[0]) === best[0]) {
      return best;
    } else {
      return pair;
    }
  }, null)[1];
}
function pick(obj, keys) {
  return keys.reduce((a, k) => {
    a[k] = obj[k];
    return a;
  }, {});
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function validateWeekSettings(settings) {
  if (settings == null) {
    return null;
  } else if (typeof settings !== "object") {
    throw new InvalidArgumentError("Week settings must be an object");
  } else {
    if (!integerBetween(settings.firstDay, 1, 7) || !integerBetween(settings.minimalDays, 1, 7) || !Array.isArray(settings.weekend) || settings.weekend.some((v) => !integerBetween(v, 1, 7))) {
      throw new InvalidArgumentError("Invalid week settings");
    }
    return {
      firstDay: settings.firstDay,
      minimalDays: settings.minimalDays,
      weekend: Array.from(settings.weekend)
    };
  }
}
function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
}
function floorMod(x, n2) {
  return x - n2 * Math.floor(x / n2);
}
function padStart(input, n2 = 2) {
  const isNeg = input < 0;
  let padded;
  if (isNeg) {
    padded = "-" + ("" + -input).padStart(n2, "0");
  } else {
    padded = ("" + input).padStart(n2, "0");
  }
  return padded;
}
function parseInteger(string) {
  if (isUndefined(string) || string === null || string === "") {
    return void 0;
  } else {
    return parseInt(string, 10);
  }
}
function parseFloating(string) {
  if (isUndefined(string) || string === null || string === "") {
    return void 0;
  } else {
    return parseFloat(string);
  }
}
function parseMillis(fraction) {
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return void 0;
  } else {
    const f = parseFloat("0." + fraction) * 1e3;
    return Math.floor(f);
  }
}
function roundTo(number, digits, towardZero = false) {
  const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
  return rounder(number * factor) / factor;
}
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
  if (modMonth === 2) {
    return isLeapYear(modYear) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
  }
}
function objToLocalTS(obj) {
  let d = Date.UTC(
    obj.year,
    obj.month - 1,
    obj.day,
    obj.hour,
    obj.minute,
    obj.second,
    obj.millisecond
  );
  if (obj.year < 100 && obj.year >= 0) {
    d = new Date(d);
    d.setUTCFullYear(obj.year, obj.month - 1, obj.day);
  }
  return +d;
}
function firstWeekOffset(year, minDaysInFirstWeek, startOfWeek) {
  const fwdlw = isoWeekdayToLocal(dayOfWeek(year, 1, minDaysInFirstWeek), startOfWeek);
  return -fwdlw + minDaysInFirstWeek - 1;
}
function weeksInWeekYear(weekYear, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);
  const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);
  return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;
}
function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else
    return year > Settings.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
}
function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
  const date = new Date(ts), intlOpts = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  if (timeZone) {
    intlOpts.timeZone = timeZone;
  }
  const modified = { timeZoneName: offsetFormat, ...intlOpts };
  const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m) => m.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }
  const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}
function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
    throw new InvalidArgumentError(`Invalid unit value ${value}`);
  return numericValue;
}
function normalizeObject(obj, normalizer) {
  const normalized = {};
  for (const u in obj) {
    if (hasOwnProperty(obj, u)) {
      const v = obj[u];
      if (v === void 0 || v === null)
        continue;
      normalized[normalizer(u)] = asNumber(v);
    }
  }
  return normalized;
}
function formatOffset(offset2, format) {
  const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
  switch (format) {
    case "short":
      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(`Value format ${format} is out of range for property format`);
  }
}
function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}

// node_modules/luxon/src/impl/english.js
var monthsLong = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthsShort = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(length) {
  switch (length) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
var weekdaysLong = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
];
var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(length) {
  switch (length) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
var meridiems = ["AM", "PM"];
var erasLong = ["Before Christ", "Anno Domini"];
var erasShort = ["BC", "AD"];
var erasNarrow = ["B", "A"];
function eras(length) {
  switch (length) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}
function meridiemForDateTime(dt) {
  return meridiems[dt.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(dt, length) {
  return weekdays(length)[dt.weekday - 1];
}
function monthForDateTime(dt, length) {
  return months(length)[dt.month - 1];
}
function eraForDateTime(dt, length) {
  return eras(length)[dt.year < 0 ? 0 : 1];
}
function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
  const units = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  };
  const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
  if (numeric === "auto" && lastable) {
    const isDay = unit === "days";
    switch (count) {
      case 1:
        return isDay ? "tomorrow" : `next ${units[unit][0]}`;
      case -1:
        return isDay ? "yesterday" : `last ${units[unit][0]}`;
      case 0:
        return isDay ? "today" : `this ${units[unit][0]}`;
      default:
    }
  }
  const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
  return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
}

// node_modules/luxon/src/impl/formatter.js
function stringifyTokens(splits, tokenToString) {
  let s2 = "";
  for (const token of splits) {
    if (token.literal) {
      s2 += token.val;
    } else {
      s2 += tokenToString(token.val);
    }
  }
  return s2;
}
var macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};
var Formatter = class _Formatter {
  static create(locale, opts = {}) {
    return new _Formatter(locale, opts);
  }
  static parseFormat(fmt) {
    let current = null, currentFull = "", bracketed = false;
    const splits = [];
    for (let i = 0; i < fmt.length; i++) {
      const c = fmt.charAt(i);
      if (c === "'") {
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
        }
        current = null;
        currentFull = "";
        bracketed = !bracketed;
      } else if (bracketed) {
        currentFull += c;
      } else if (c === current) {
        currentFull += c;
      } else {
        if (currentFull.length > 0) {
          splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
        }
        currentFull = c;
        current = c;
      }
    }
    if (currentFull.length > 0) {
      splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
    }
    return splits;
  }
  static macroTokenToFormatOpts(token) {
    return macroTokenToFormatOpts[token];
  }
  constructor(locale, formatOpts) {
    this.opts = formatOpts;
    this.loc = locale;
    this.systemLoc = null;
  }
  formatWithSystemDefault(dt, opts) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
    return df.format();
  }
  dtFormatter(dt, opts = {}) {
    return this.loc.dtFormatter(dt, { ...this.opts, ...opts });
  }
  formatDateTime(dt, opts) {
    return this.dtFormatter(dt, opts).format();
  }
  formatDateTimeParts(dt, opts) {
    return this.dtFormatter(dt, opts).formatToParts();
  }
  formatInterval(interval, opts) {
    const df = this.dtFormatter(interval.start, opts);
    return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
  }
  resolvedOptions(dt, opts) {
    return this.dtFormatter(dt, opts).resolvedOptions();
  }
  num(n2, p = 0) {
    if (this.opts.forceSimple) {
      return padStart(n2, p);
    }
    const opts = { ...this.opts };
    if (p > 0) {
      opts.padTo = p;
    }
    return this.loc.numberFormatter(opts).format(n2);
  }
  formatDateTimeFromString(dt, fmt) {
    const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
      if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
        return "Z";
      }
      return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
    }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string(
      standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
      "weekday"
    ), maybeMacro = (token) => {
      const formatOpts = _Formatter.macroTokenToFormatOpts(token);
      if (formatOpts) {
        return this.formatWithSystemDefault(dt, formatOpts);
      } else {
        return token;
      }
    }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string({ era: length }, "era"), tokenToString = (token) => {
      switch (token) {
        case "S":
          return this.num(dt.millisecond);
        case "u":
        case "SSS":
          return this.num(dt.millisecond, 3);
        case "s":
          return this.num(dt.second);
        case "ss":
          return this.num(dt.second, 2);
        case "uu":
          return this.num(Math.floor(dt.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(dt.millisecond / 100));
        case "m":
          return this.num(dt.minute);
        case "mm":
          return this.num(dt.minute, 2);
        case "h":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
        case "hh":
          return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
        case "H":
          return this.num(dt.hour);
        case "HH":
          return this.num(dt.hour, 2);
        case "Z":
          return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return dt.zoneName;
        case "a":
          return meridiem();
        case "d":
          return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
        case "dd":
          return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
        case "c":
          return this.num(dt.weekday);
        case "ccc":
          return weekday("short", true);
        case "cccc":
          return weekday("long", true);
        case "ccccc":
          return weekday("narrow", true);
        case "E":
          return this.num(dt.weekday);
        case "EEE":
          return weekday("short", false);
        case "EEEE":
          return weekday("long", false);
        case "EEEEE":
          return weekday("narrow", false);
        case "L":
          return useDateTimeFormatter ? string({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
        case "LL":
          return useDateTimeFormatter ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
        case "LLL":
          return month("short", true);
        case "LLLL":
          return month("long", true);
        case "LLLLL":
          return month("narrow", true);
        case "M":
          return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month);
        case "MM":
          return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2);
        case "MMM":
          return month("short", false);
        case "MMMM":
          return month("long", false);
        case "MMMMM":
          return month("narrow", false);
        case "y":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
        case "yy":
          return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
        case "yyyy":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4);
        case "yyyyyy":
          return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6);
        case "G":
          return era("short");
        case "GG":
          return era("long");
        case "GGGGG":
          return era("narrow");
        case "kk":
          return this.num(dt.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(dt.weekYear, 4);
        case "W":
          return this.num(dt.weekNumber);
        case "WW":
          return this.num(dt.weekNumber, 2);
        case "n":
          return this.num(dt.localWeekNumber);
        case "nn":
          return this.num(dt.localWeekNumber, 2);
        case "ii":
          return this.num(dt.localWeekYear.toString().slice(-2), 2);
        case "iiii":
          return this.num(dt.localWeekYear, 4);
        case "o":
          return this.num(dt.ordinal);
        case "ooo":
          return this.num(dt.ordinal, 3);
        case "q":
          return this.num(dt.quarter);
        case "qq":
          return this.num(dt.quarter, 2);
        case "X":
          return this.num(Math.floor(dt.ts / 1e3));
        case "x":
          return this.num(dt.ts);
        default:
          return maybeMacro(token);
      }
    };
    return stringifyTokens(_Formatter.parseFormat(fmt), tokenToString);
  }
  formatDurationFromString(dur, fmt) {
    const tokenToField = (token) => {
      switch (token[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, tokenToString = (lildur) => (token) => {
      const mapped = tokenToField(token);
      if (mapped) {
        return this.num(lildur.get(mapped), token.length);
      } else {
        return token;
      }
    }, tokens = _Formatter.parseFormat(fmt), realTokens = tokens.reduce(
      (found, { literal, val }) => literal ? found : found.concat(val),
      []
    ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t));
    return stringifyTokens(tokens, tokenToString(collapsed));
  }
};

// node_modules/luxon/src/impl/regexParser.js
var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function combineRegexes(...regexes) {
  const full = regexes.reduce((f, r) => f + r.source, "");
  return RegExp(`^${full}$`);
}
function combineExtractors(...extractors) {
  return (m) => extractors.reduce(
    ([mergedVals, mergedZone, cursor], ex) => {
      const [val, zone, next] = ex(m, cursor);
      return [{ ...mergedVals, ...val }, zone || mergedZone, next];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function parse(s2, ...patterns) {
  if (s2 == null) {
    return [null, null];
  }
  for (const [regex, extractor] of patterns) {
    const m = regex.exec(s2);
    if (m) {
      return extractor(m);
    }
  }
  return [null, null];
}
function simpleParse(...keys) {
  return (match2, cursor) => {
    const ret = {};
    let i;
    for (i = 0; i < keys.length; i++) {
      ret[keys[i]] = parseInteger(match2[cursor + i]);
    }
    return [ret, null, cursor + i];
  };
}
var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
var extractISOOrdinalData = simpleParse("year", "ordinal");
var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
var sqlTimeRegex = RegExp(
  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
);
var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
function int(match2, pos, fallback) {
  const m = match2[pos];
  return isUndefined(m) ? fallback : parseInteger(m);
}
function extractISOYmd(match2, cursor) {
  const item = {
    year: int(match2, cursor),
    month: int(match2, cursor + 1, 1),
    day: int(match2, cursor + 2, 1)
  };
  return [item, null, cursor + 3];
}
function extractISOTime(match2, cursor) {
  const item = {
    hours: int(match2, cursor, 0),
    minutes: int(match2, cursor + 1, 0),
    seconds: int(match2, cursor + 2, 0),
    milliseconds: parseMillis(match2[cursor + 3])
  };
  return [item, null, cursor + 4];
}
function extractISOOffset(match2, cursor) {
  const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
  return [{}, zone, cursor + 3];
}
function extractIANAZone(match2, cursor) {
  const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
  return [{}, zone, cursor + 1];
}
var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(match2) {
  const [s2, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
  const hasNegativePrefix = s2[0] === "-";
  const negativeSeconds = secondStr && secondStr[0] === "-";
  const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
  return [
    {
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
    }
  ];
}
var obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  const result = {
    year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
    month: monthsShort.indexOf(monthStr) + 1,
    day: parseInteger(dayStr),
    hour: parseInteger(hourStr),
    minute: parseInteger(minuteStr)
  };
  if (secondStr)
    result.second = parseInteger(secondStr);
  if (weekdayStr) {
    result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
  }
  return result;
}
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(match2) {
  const [
    ,
    weekdayStr,
    dayStr,
    monthStr,
    yearStr,
    hourStr,
    minuteStr,
    secondStr,
    obsOffset,
    milOffset,
    offHourStr,
    offMinuteStr
  ] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  let offset2;
  if (obsOffset) {
    offset2 = obsOffsets[obsOffset];
  } else if (milOffset) {
    offset2 = 0;
  } else {
    offset2 = signedOffset(offHourStr, offMinuteStr);
  }
  return [result, new FixedOffsetZone(offset2)];
}
function preprocessRFC2822(s2) {
  return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(match2) {
  const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
function extractASCII(match2) {
  const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
  return [result, FixedOffsetZone.utcInstance];
}
var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
var extractISOYmdTimeAndOffset = combineExtractors(
  extractISOYmd,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOWeekTimeAndOffset = combineExtractors(
  extractISOWeekData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOOrdinalDateAndTime = combineExtractors(
  extractISOOrdinalData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
var extractISOTimeAndOffset = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseISODate(s2) {
  return parse(
    s2,
    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
    [isoTimeCombinedRegex, extractISOTimeAndOffset]
  );
}
function parseRFC2822Date(s2) {
  return parse(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(s2) {
  return parse(
    s2,
    [rfc1123, extractRFC1123Or850],
    [rfc850, extractRFC1123Or850],
    [ascii, extractASCII]
  );
}
function parseISODuration(s2) {
  return parse(s2, [isoDuration, extractISODuration]);
}
var extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(s2) {
  return parse(s2, [isoTimeOnly, extractISOTimeOnly]);
}
var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
var extractISOTimeOffsetAndIANAZone = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseSQL(s2) {
  return parse(
    s2,
    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
  );
}

// node_modules/luxon/src/duration.js
var INVALID = "Invalid Duration";
var lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
};
var casualMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
var daysInYearAccurate = 146097 / 400;
var daysInMonthAccurate = 146097 / 4800;
var accurateMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: daysInYearAccurate / 7,
    days: daysInYearAccurate,
    hours: daysInYearAccurate * 24,
    minutes: daysInYearAccurate * 24 * 60,
    seconds: daysInYearAccurate * 24 * 60 * 60,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: daysInYearAccurate / 28,
    days: daysInYearAccurate / 4,
    hours: daysInYearAccurate * 24 / 4,
    minutes: daysInYearAccurate * 24 * 60 / 4,
    seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: daysInMonthAccurate / 7,
    days: daysInMonthAccurate,
    hours: daysInMonthAccurate * 24,
    minutes: daysInMonthAccurate * 24 * 60,
    seconds: daysInMonthAccurate * 24 * 60 * 60,
    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
};
var orderedUnits = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
];
var reverseUnits = orderedUnits.slice(0).reverse();
function clone(dur, alts, clear = false) {
  const conf = {
    values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
    loc: dur.loc.clone(alts.loc),
    conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
    matrix: alts.matrix || dur.matrix
  };
  return new Duration(conf);
}
function durationToMillis(matrix, vals) {
  var _a;
  let sum = (_a = vals.milliseconds) != null ? _a : 0;
  for (const unit of reverseUnits.slice(1)) {
    if (vals[unit]) {
      sum += vals[unit] * matrix[unit]["milliseconds"];
    }
  }
  return sum;
}
function normalizeValues(matrix, vals) {
  const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
  orderedUnits.reduceRight((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        const previousVal = vals[previous] * factor;
        const conv = matrix[current][previous];
        const rollUp = Math.floor(previousVal / conv);
        vals[current] += rollUp * factor;
        vals[previous] -= rollUp * conv * factor;
      }
      return current;
    } else {
      return previous;
    }
  }, null);
  orderedUnits.reduce((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        const fraction = vals[previous] % 1;
        vals[previous] -= fraction;
        vals[current] += fraction * matrix[previous][current];
      }
      return current;
    } else {
      return previous;
    }
  }, null);
}
function removeZeroes(vals) {
  const newVals = {};
  for (const [key, value] of Object.entries(vals)) {
    if (value !== 0) {
      newVals[key] = value;
    }
  }
  return newVals;
}
var Duration = class _Duration {
  /**
   * @private
   */
  constructor(config) {
    const accurate = config.conversionAccuracy === "longterm" || false;
    let matrix = accurate ? accurateMatrix : casualMatrix;
    if (config.matrix) {
      matrix = config.matrix;
    }
    this.values = config.values;
    this.loc = config.loc || Locale.create();
    this.conversionAccuracy = accurate ? "longterm" : "casual";
    this.invalid = config.invalid || null;
    this.matrix = matrix;
    this.isLuxonDuration = true;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(count, opts) {
    return _Duration.fromObject({ milliseconds: count }, opts);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(
        `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
      );
    }
    return new _Duration({
      values: normalizeObject(obj, _Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
      matrix: opts.matrix
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(durationLike) {
    if (isNumber(durationLike)) {
      return _Duration.fromMillis(durationLike);
    } else if (_Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return _Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(
        `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
      );
    }
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(text2, opts) {
    const [parsed] = parseISODuration(text2);
    if (parsed) {
      return _Duration.fromObject(parsed, opts);
    } else {
      return _Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(text2, opts) {
    const [parsed] = parseISOTimeOnly(text2);
    if (parsed) {
      return _Duration.fromObject(parsed, opts);
    } else {
      return _Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new _Duration({ invalid });
    }
  }
  /**
   * @private
   */
  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit ? unit.toLowerCase() : unit];
    if (!normalized)
      throw new InvalidUnitError(unit);
    return normalized;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(o) {
    return o && o.isLuxonDuration || false;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    const fmtOpts = {
      ...opts,
      floor: opts.round !== false && opts.floor !== false
    };
    return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
   * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
   * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(opts = {}) {
    if (!this.isValid)
      return INVALID;
    const l2 = orderedUnits.map((unit) => {
      const val = this.values[unit];
      if (isUndefined(val)) {
        return null;
      }
      return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
    }).filter((n2) => n2);
    return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l2);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    if (!this.isValid)
      return {};
    return { ...this.values };
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid)
      return null;
    let s2 = "P";
    if (this.years !== 0)
      s2 += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0)
      s2 += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0)
      s2 += this.weeks + "W";
    if (this.days !== 0)
      s2 += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
      s2 += "T";
    if (this.hours !== 0)
      s2 += this.hours + "H";
    if (this.minutes !== 0)
      s2 += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0)
      s2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
    if (s2 === "P")
      s2 += "T0S";
    return s2;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(opts = {}) {
    if (!this.isValid)
      return null;
    const millis = this.toMillis();
    if (millis < 0 || millis >= 864e5)
      return null;
    opts = {
      suppressMilliseconds: false,
      suppressSeconds: false,
      includePrefix: false,
      format: "extended",
      ...opts,
      includeOffset: false
    };
    const dateTime = DateTime.fromMillis(millis, { zone: "UTC" });
    return dateTime.toISOTime(opts);
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns a string representation of this Duration appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `Duration { values: ${JSON.stringify(this.values)} }`;
    } else {
      return `Duration { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    if (!this.isValid)
      return NaN;
    return durationToMillis(this.matrix, this.values);
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(duration) {
    if (!this.isValid)
      return this;
    const dur = _Duration.fromDurationLike(duration), result = {};
    for (const k of orderedUnits) {
      if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
        result[k] = dur.get(k) + this.get(k);
      }
    }
    return clone(this, { values: result }, true);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(duration) {
    if (!this.isValid)
      return this;
    const dur = _Duration.fromDurationLike(duration);
    return this.plus(dur.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(fn) {
    if (!this.isValid)
      return this;
    const result = {};
    for (const k of Object.keys(this.values)) {
      result[k] = asNumber(fn(this.values[k], k));
    }
    return clone(this, { values: result }, true);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(unit) {
    return this[_Duration.normalizeUnit(unit)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(values) {
    if (!this.isValid)
      return this;
    const mixed = { ...this.values, ...normalizeObject(values, _Duration.normalizeUnit) };
    return clone(this, { values: mixed });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem });
    const opts = { loc, matrix, conversionAccuracy };
    return clone(this, opts);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(unit) {
    return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * Assuming the overall value of the Duration is positive, this means:
   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
   *   the overall value would be negative, see third example)
   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
   *
   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid)
      return this;
    const vals = this.toObject();
    normalizeValues(this.matrix, vals);
    return clone(this, { values: vals }, true);
  }
  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid)
      return this;
    const vals = removeZeroes(this.normalize().shiftToAll().toObject());
    return clone(this, { values: vals }, true);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...units) {
    if (!this.isValid)
      return this;
    if (units.length === 0) {
      return this;
    }
    units = units.map((u) => _Duration.normalizeUnit(u));
    const built = {}, accumulated = {}, vals = this.toObject();
    let lastUnit;
    for (const k of orderedUnits) {
      if (units.indexOf(k) >= 0) {
        lastUnit = k;
        let own = 0;
        for (const ak in accumulated) {
          own += this.matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        }
        if (isNumber(vals[k])) {
          own += vals[k];
        }
        const i = Math.trunc(own);
        built[k] = i;
        accumulated[k] = (own * 1e3 - i * 1e3) / 1e3;
      } else if (isNumber(vals[k])) {
        accumulated[k] = vals[k];
      }
    }
    for (const key in accumulated) {
      if (accumulated[key] !== 0) {
        built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
      }
    }
    normalizeValues(this.matrix, built);
    return clone(this, { values: built }, true);
  }
  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    if (!this.isValid)
      return this;
    return this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    );
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid)
      return this;
    const negated = {};
    for (const k of Object.keys(this.values)) {
      negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
    }
    return clone(this, { values: negated }, true);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    if (!this.loc.equals(other.loc)) {
      return false;
    }
    function eq(v1, v2) {
      if (v1 === void 0 || v1 === 0)
        return v2 === void 0 || v2 === 0;
      return v1 === v2;
    }
    for (const u of orderedUnits) {
      if (!eq(this.values[u], other.values[u])) {
        return false;
      }
    }
    return true;
  }
};

// node_modules/luxon/src/interval.js
var INVALID2 = "Invalid Interval";
function validateStartEnd(start, end) {
  if (!start || !start.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!end || !end.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (end < start) {
    return Interval.invalid(
      "end before start",
      `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
    );
  } else {
    return null;
  }
}
var Interval = class _Interval {
  /**
   * @private
   */
  constructor(config) {
    this.s = config.start;
    this.e = config.end;
    this.invalid = config.invalid || null;
    this.isLuxonInterval = true;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(invalid);
    } else {
      return new _Interval({ invalid });
    }
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(start, end) {
    const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
    const validateError = validateStartEnd(builtStart, builtEnd);
    if (validateError == null) {
      return new _Interval({
        start: builtStart,
        end: builtEnd
      });
    } else {
      return validateError;
    }
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(start, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
    return _Interval.fromDateTimes(dt, dt.plus(dur));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(end, duration) {
    const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
    return _Interval.fromDateTimes(dt.minus(dur), dt);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(text2, opts) {
    const [s2, e] = (text2 || "").split("/", 2);
    if (s2 && e) {
      let start, startIsValid;
      try {
        start = DateTime.fromISO(s2, opts);
        startIsValid = start.isValid;
      } catch (e2) {
        startIsValid = false;
      }
      let end, endIsValid;
      try {
        end = DateTime.fromISO(e, opts);
        endIsValid = end.isValid;
      } catch (e2) {
        endIsValid = false;
      }
      if (startIsValid && endIsValid) {
        return _Interval.fromDateTimes(start, end);
      }
      if (startIsValid) {
        const dur = Duration.fromISO(e, opts);
        if (dur.isValid) {
          return _Interval.after(start, dur);
        }
      } else if (endIsValid) {
        const dur = Duration.fromISO(s2, opts);
        if (dur.isValid) {
          return _Interval.before(end, dur);
        }
      }
    }
    return _Interval.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(o) {
    return o && o.isLuxonInterval || false;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(unit = "milliseconds") {
    return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime
   * @return {number}
   */
  count(unit = "milliseconds", opts) {
    if (!this.isValid)
      return NaN;
    const start = this.start.startOf(unit, opts);
    let end;
    if (opts == null ? void 0 : opts.useLocaleWeeks) {
      end = this.end.reconfigure({ locale: start.locale });
    } else {
      end = this.end;
    }
    end = end.startOf(unit, opts);
    return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(unit) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(dateTime) {
    if (!this.isValid)
      return false;
    return this.s > dateTime;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(dateTime) {
    if (!this.isValid)
      return false;
    return this.e <= dateTime;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(dateTime) {
    if (!this.isValid)
      return false;
    return this.s <= dateTime && this.e > dateTime;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start, end } = {}) {
    if (!this.isValid)
      return this;
    return _Interval.fromDateTimes(start || this.s, end || this.e);
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...dateTimes) {
    if (!this.isValid)
      return [];
    const sorted = dateTimes.map(friendlyDateTime).filter((d) => this.contains(d)).sort((a, b) => a.toMillis() - b.toMillis()), results = [];
    let { s: s2 } = this, i = 0;
    while (s2 < this.e) {
      const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
      results.push(_Interval.fromDateTimes(s2, next));
      s2 = next;
      i += 1;
    }
    return results;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(duration) {
    const dur = Duration.fromDurationLike(duration);
    if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
      return [];
    }
    let { s: s2 } = this, idx = 1, next;
    const results = [];
    while (s2 < this.e) {
      const added = this.start.plus(dur.mapUnits((x) => x * idx));
      next = +added > +this.e ? this.e : added;
      results.push(_Interval.fromDateTimes(s2, next));
      s2 = next;
      idx += 1;
    }
    return results;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(numberOfParts) {
    if (!this.isValid)
      return [];
    return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(other) {
    return this.e > other.s && this.s < other.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(other) {
    if (!this.isValid)
      return false;
    return +this.e === +other.s;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(other) {
    if (!this.isValid)
      return false;
    return +other.e === +this.s;
  }
  /**
   * Return whether this Interval engulfs the start and end of the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(other) {
    if (!this.isValid)
      return false;
    return this.s <= other.s && this.e >= other.e;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    return this.s.equals(other.s) && this.e.equals(other.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(other) {
    if (!this.isValid)
      return this;
    const s2 = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;
    if (s2 >= e) {
      return null;
    } else {
      return _Interval.fromDateTimes(s2, e);
    }
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(other) {
    if (!this.isValid)
      return this;
    const s2 = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;
    return _Interval.fromDateTimes(s2, e);
  }
  /**
   * Merge an array of Intervals into a equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(intervals) {
    const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(
      ([sofar, current], item) => {
        if (!current) {
          return [sofar, item];
        } else if (current.overlaps(item) || current.abutsStart(item)) {
          return [sofar, current.union(item)];
        } else {
          return [sofar.concat([current]), item];
        }
      },
      [[], null]
    );
    if (final) {
      found.push(final);
    }
    return found;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(intervals) {
    let start = null, currentCount = 0;
    const results = [], ends = intervals.map((i) => [
      { time: i.s, type: "s" },
      { time: i.e, type: "e" }
    ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a, b) => a.time - b.time);
    for (const i of arr) {
      currentCount += i.type === "s" ? 1 : -1;
      if (currentCount === 1) {
        start = i.time;
      } else {
        if (start && +start !== +i.time) {
          results.push(_Interval.fromDateTimes(start, i.time));
        }
        start = null;
      }
    }
    return _Interval.merge(results);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...intervals) {
    return _Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    if (!this.isValid)
      return INVALID2;
    return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
  }
  /**
   * Returns a string representation of this Interval appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`;
    } else {
      return `Interval { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022  11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7  8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 78 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00  8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00  8:00 p
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID2;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(opts) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(opts) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  '  '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(dateFormat, { separator = " \u2013 " } = {}) {
    if (!this.isValid)
      return INVALID2;
    return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(unit, opts) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, unit, opts);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(mapFn) {
    return _Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
  }
};

// node_modules/luxon/src/info.js
var Info = class {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(zone = Settings.defaultZone) {
    const proto = DateTime.now().setZone(zone).set({ month: 12 });
    return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(zone) {
    return IANAZone.isValidZone(zone);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(input) {
    return normalizeZone(input, Settings.defaultZone);
  }
  /**
   * Get the weekday on which the week starts according to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number} the start of the week, 1 for Monday through 7 for Sunday
   */
  static getStartOfWeek({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getStartOfWeek();
  }
  /**
   * Get the minimum number of days necessary in a week before it is considered part of the next year according
   * to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number}
   */
  static getMinimumDaysInFirstWeek({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getMinDaysInFirstWeek();
  }
  /**
   * Get the weekdays, which are considered the weekend according to the given locale
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday
   */
  static getWeekendWeekdays({ locale = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale)).getWeekendDays().slice();
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'
   * @return {Array}
   */
  static months(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''
   * @return {Array}
   */
  static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
    return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]
   * @return {Array}
   */
  static meridiems({ locale = null } = {}) {
    return Locale.create(locale).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]
   * @return {Array}
   */
  static eras(length = "short", { locale = null } = {}) {
    return Locale.create(locale, null, "gregory").eras(length);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale
   * @example Info.features() //=> { relative: false, localeWeek: true }
   * @return {Object}
   */
  static features() {
    return { relative: hasRelative(), localeWeek: hasLocaleWeekInfo() };
  }
};

// node_modules/luxon/src/impl/diff.js
function dayDiff(earlier, later) {
  const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
  return Math.floor(Duration.fromMillis(ms).as("days"));
}
function highOrderDiffs(cursor, later, units) {
  const differs = [
    ["years", (a, b) => b.year - a.year],
    ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4],
    ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12],
    [
      "weeks",
      (a, b) => {
        const days = dayDiff(a, b);
        return (days - days % 7) / 7;
      }
    ],
    ["days", dayDiff]
  ];
  const results = {};
  const earlier = cursor;
  let lowestOrder, highWater;
  for (const [unit, differ] of differs) {
    if (units.indexOf(unit) >= 0) {
      lowestOrder = unit;
      results[unit] = differ(cursor, later);
      highWater = earlier.plus(results);
      if (highWater > later) {
        results[unit]--;
        cursor = earlier.plus(results);
        if (cursor > later) {
          highWater = cursor;
          results[unit]--;
          cursor = earlier.plus(results);
        }
      } else {
        cursor = highWater;
      }
    }
  }
  return [cursor, results, highWater, lowestOrder];
}
function diff_default(earlier, later, units, opts) {
  let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
  const remainingMillis = later - cursor;
  const lowerOrderUnits = units.filter(
    (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
  );
  if (lowerOrderUnits.length === 0) {
    if (highWater < later) {
      highWater = cursor.plus({ [lowestOrder]: 1 });
    }
    if (highWater !== cursor) {
      results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
    }
  }
  const duration = Duration.fromObject(results, opts);
  if (lowerOrderUnits.length > 0) {
    return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
  } else {
    return duration;
  }
}

// node_modules/luxon/src/impl/digits.js
var numberingSystems = {
  arab: "[\u0660-\u0669]",
  arabext: "[\u06F0-\u06F9]",
  bali: "[\u1B50-\u1B59]",
  beng: "[\u09E6-\u09EF]",
  deva: "[\u0966-\u096F]",
  fullwide: "[\uFF10-\uFF19]",
  gujr: "[\u0AE6-\u0AEF]",
  hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
  khmr: "[\u17E0-\u17E9]",
  knda: "[\u0CE6-\u0CEF]",
  laoo: "[\u0ED0-\u0ED9]",
  limb: "[\u1946-\u194F]",
  mlym: "[\u0D66-\u0D6F]",
  mong: "[\u1810-\u1819]",
  mymr: "[\u1040-\u1049]",
  orya: "[\u0B66-\u0B6F]",
  tamldec: "[\u0BE6-\u0BEF]",
  telu: "[\u0C66-\u0C6F]",
  thai: "[\u0E50-\u0E59]",
  tibt: "[\u0F20-\u0F29]",
  latn: "\\d"
};
var numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
};
var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(str) {
  let value = parseInt(str, 10);
  if (isNaN(value)) {
    value = "";
    for (let i = 0; i < str.length; i++) {
      const code = str.charCodeAt(i);
      if (str[i].search(numberingSystems.hanidec) !== -1) {
        value += hanidecChars.indexOf(str[i]);
      } else {
        for (const key in numberingSystemsUTF16) {
          const [min, max] = numberingSystemsUTF16[key];
          if (code >= min && code <= max) {
            value += code - min;
          }
        }
      }
    }
    return parseInt(value, 10);
  } else {
    return value;
  }
}
function digitRegex({ numberingSystem }, append2 = "") {
  return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append2}`);
}

// node_modules/luxon/src/impl/tokenParser.js
var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(regex, post = (i) => i) {
  return { regex, deser: ([s2]) => post(parseDigits(s2)) };
}
var NBSP = String.fromCharCode(160);
var spaceOrNBSP = `[ ${NBSP}]`;
var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
function fixListRegex(s2) {
  return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}
function stripInsensitivities(s2) {
  return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
}
function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join("|")),
      deser: ([s2]) => strings.findIndex((i) => stripInsensitivities(s2) === stripInsensitivities(i)) + startIndex
    };
  }
}
function offset(regex, groups) {
  return { regex, deser: ([, h, m]) => signedOffset(h, m), groups };
}
function simple(regex) {
  return { regex, deser: ([s2]) => s2 };
}
function escapeToken(value) {
  return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function unitForToken(token, loc) {
  const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t) => ({ regex: RegExp(escapeToken(t.val)), deser: ([s2]) => s2, literal: true }), unitate = (t) => {
    if (token.literal) {
      return literal(t);
    }
    switch (t.val) {
      case "G":
        return oneOf(loc.eras("short"), 0);
      case "GG":
        return oneOf(loc.eras("long"), 0);
      case "y":
        return intUnit(oneToSix);
      case "yy":
        return intUnit(twoToFour, untruncateYear);
      case "yyyy":
        return intUnit(four);
      case "yyyyy":
        return intUnit(fourToSix);
      case "yyyyyy":
        return intUnit(six);
      case "M":
        return intUnit(oneOrTwo);
      case "MM":
        return intUnit(two);
      case "MMM":
        return oneOf(loc.months("short", true), 1);
      case "MMMM":
        return oneOf(loc.months("long", true), 1);
      case "L":
        return intUnit(oneOrTwo);
      case "LL":
        return intUnit(two);
      case "LLL":
        return oneOf(loc.months("short", false), 1);
      case "LLLL":
        return oneOf(loc.months("long", false), 1);
      case "d":
        return intUnit(oneOrTwo);
      case "dd":
        return intUnit(two);
      case "o":
        return intUnit(oneToThree);
      case "ooo":
        return intUnit(three);
      case "HH":
        return intUnit(two);
      case "H":
        return intUnit(oneOrTwo);
      case "hh":
        return intUnit(two);
      case "h":
        return intUnit(oneOrTwo);
      case "mm":
        return intUnit(two);
      case "m":
        return intUnit(oneOrTwo);
      case "q":
        return intUnit(oneOrTwo);
      case "qq":
        return intUnit(two);
      case "s":
        return intUnit(oneOrTwo);
      case "ss":
        return intUnit(two);
      case "S":
        return intUnit(oneToThree);
      case "SSS":
        return intUnit(three);
      case "u":
        return simple(oneToNine);
      case "uu":
        return simple(oneOrTwo);
      case "uuu":
        return intUnit(one);
      case "a":
        return oneOf(loc.meridiems(), 0);
      case "kkkk":
        return intUnit(four);
      case "kk":
        return intUnit(twoToFour, untruncateYear);
      case "W":
        return intUnit(oneOrTwo);
      case "WW":
        return intUnit(two);
      case "E":
      case "c":
        return intUnit(one);
      case "EEE":
        return oneOf(loc.weekdays("short", false), 1);
      case "EEEE":
        return oneOf(loc.weekdays("long", false), 1);
      case "ccc":
        return oneOf(loc.weekdays("short", true), 1);
      case "cccc":
        return oneOf(loc.weekdays("long", true), 1);
      case "Z":
      case "ZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
      case "ZZZ":
        return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
      case "z":
        return simple(/[a-z_+-/]{1,256}?/i);
      case " ":
        return simple(/[^\S\n\r]/);
      default:
        return literal(t);
    }
  };
  const unit = unitate(token) || {
    invalidReason: MISSING_FTP
  };
  unit.token = token;
  return unit;
}
var partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function tokenForPart(part, formatOpts, resolvedOpts) {
  const { type, value } = part;
  if (type === "literal") {
    const isSpace = /^\s+$/.test(value);
    return {
      literal: !isSpace,
      val: isSpace ? " " : value
    };
  }
  const style = formatOpts[type];
  let actualType = type;
  if (type === "hour") {
    if (formatOpts.hour12 != null) {
      actualType = formatOpts.hour12 ? "hour12" : "hour24";
    } else if (formatOpts.hourCycle != null) {
      if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
        actualType = "hour12";
      } else {
        actualType = "hour24";
      }
    } else {
      actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
    }
  }
  let val = partTypeStyleToTokenVal[actualType];
  if (typeof val === "object") {
    val = val[style];
  }
  if (val) {
    return {
      literal: false,
      val
    };
  }
  return void 0;
}
function buildRegex(units) {
  const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
  return [`^${re}$`, units];
}
function match(input, regex, handlers) {
  const matches = input.match(regex);
  if (matches) {
    const all = {};
    let matchIndex = 1;
    for (const i in handlers) {
      if (hasOwnProperty(handlers, i)) {
        const h = handlers[i], groups = h.groups ? h.groups + 1 : 1;
        if (!h.literal && h.token) {
          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all];
  } else {
    return [matches, {}];
  }
}
function dateTimeFromMatches(matches) {
  const toField = (token) => {
    switch (token) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let zone = null;
  let specificOffset;
  if (!isUndefined(matches.z)) {
    zone = IANAZone.create(matches.z);
  }
  if (!isUndefined(matches.Z)) {
    if (!zone) {
      zone = new FixedOffsetZone(matches.Z);
    }
    specificOffset = matches.Z;
  }
  if (!isUndefined(matches.q)) {
    matches.M = (matches.q - 1) * 3 + 1;
  }
  if (!isUndefined(matches.h)) {
    if (matches.h < 12 && matches.a === 1) {
      matches.h += 12;
    } else if (matches.h === 12 && matches.a === 0) {
      matches.h = 0;
    }
  }
  if (matches.G === 0 && matches.y) {
    matches.y = -matches.y;
  }
  if (!isUndefined(matches.u)) {
    matches.S = parseMillis(matches.u);
  }
  const vals = Object.keys(matches).reduce((r, k) => {
    const f = toField(k);
    if (f) {
      r[f] = matches[k];
    }
    return r;
  }, {});
  return [vals, zone, specificOffset];
}
var dummyDateTimeCache = null;
function getDummyDateTime() {
  if (!dummyDateTimeCache) {
    dummyDateTimeCache = DateTime.fromMillis(1555555555555);
  }
  return dummyDateTimeCache;
}
function maybeExpandMacroToken(token, locale) {
  if (token.literal) {
    return token;
  }
  const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
  const tokens = formatOptsToTokens(formatOpts, locale);
  if (tokens == null || tokens.includes(void 0)) {
    return token;
  }
  return tokens;
}
function expandMacroTokens(tokens, locale) {
  return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken(t, locale)));
}
function explainFromTokens(locale, input, format) {
  const tokens = expandMacroTokens(Formatter.parseFormat(format), locale), units = tokens.map((t) => unitForToken(t, locale)), disqualifyingUnit = units.find((t) => t.invalidReason);
  if (disqualifyingUnit) {
    return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
  } else {
    const [regexString, handlers] = buildRegex(units), regex = RegExp(regexString, "i"), [rawMatches, matches] = match(input, regex, handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, void 0];
    if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
      throw new ConflictingSpecificationError(
        "Can't include meridiem when specifying 24-hour format"
      );
    }
    return { input, tokens, regex, rawMatches, matches, result, zone, specificOffset };
  }
}
function parseFromTokens(locale, input, format) {
  const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);
  return [result, zone, specificOffset, invalidReason];
}
function formatOptsToTokens(formatOpts, locale) {
  if (!formatOpts) {
    return null;
  }
  const formatter = Formatter.create(locale, formatOpts);
  const df = formatter.dtFormatter(getDummyDateTime());
  const parts = df.formatToParts();
  const resolvedOpts = df.resolvedOptions();
  return parts.map((p) => tokenForPart(p, formatOpts, resolvedOpts));
}

// node_modules/luxon/src/datetime.js
var INVALID3 = "Invalid DateTime";
var MAX_DATE = 864e13;
function unsupportedZone(zone) {
  return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
}
function possiblyCachedWeekData(dt) {
  if (dt.weekData === null) {
    dt.weekData = gregorianToWeek(dt.c);
  }
  return dt.weekData;
}
function possiblyCachedLocalWeekData(dt) {
  if (dt.localWeekData === null) {
    dt.localWeekData = gregorianToWeek(
      dt.c,
      dt.loc.getMinDaysInFirstWeek(),
      dt.loc.getStartOfWeek()
    );
  }
  return dt.localWeekData;
}
function clone2(inst, alts) {
  const current = {
    ts: inst.ts,
    zone: inst.zone,
    c: inst.c,
    o: inst.o,
    loc: inst.loc,
    invalid: inst.invalid
  };
  return new DateTime({ ...current, ...alts, old: current });
}
function fixOffset(localTS, o, tz) {
  let utcGuess = localTS - o * 60 * 1e3;
  const o2 = tz.offset(utcGuess);
  if (o === o2) {
    return [utcGuess, o];
  }
  utcGuess -= (o2 - o) * 60 * 1e3;
  const o3 = tz.offset(utcGuess);
  if (o2 === o3) {
    return [utcGuess, o2];
  }
  return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
}
function tsToObj(ts, offset2) {
  ts += offset2 * 60 * 1e3;
  const d = new Date(ts);
  return {
    year: d.getUTCFullYear(),
    month: d.getUTCMonth() + 1,
    day: d.getUTCDate(),
    hour: d.getUTCHours(),
    minute: d.getUTCMinutes(),
    second: d.getUTCSeconds(),
    millisecond: d.getUTCMilliseconds()
  };
}
function objToTS(obj, offset2, zone) {
  return fixOffset(objToLocalTS(obj), offset2, zone);
}
function adjustTime(inst, dur) {
  const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = {
    ...inst.c,
    year,
    month,
    day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
  }, millisToAdd = Duration.fromObject({
    years: dur.years - Math.trunc(dur.years),
    quarters: dur.quarters - Math.trunc(dur.quarters),
    months: dur.months - Math.trunc(dur.months),
    weeks: dur.weeks - Math.trunc(dur.weeks),
    days: dur.days - Math.trunc(dur.days),
    hours: dur.hours,
    minutes: dur.minutes,
    seconds: dur.seconds,
    milliseconds: dur.milliseconds
  }).as("milliseconds"), localTS = objToLocalTS(c);
  let [ts, o] = fixOffset(localTS, oPre, inst.zone);
  if (millisToAdd !== 0) {
    ts += millisToAdd;
    o = inst.zone.offset(ts);
  }
  return { ts, o };
}
function parseDataToDateTime(parsed, parsedZone, opts, format, text2, specificOffset) {
  const { setZone, zone } = opts;
  if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
    const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
      ...opts,
      zone: interpretationZone,
      specificOffset
    });
    return setZone ? inst : inst.setZone(zone);
  } else {
    return DateTime.invalid(
      new Invalid("unparsable", `the input "${text2}" can't be parsed as ${format}`)
    );
  }
}
function toTechFormat(dt, format, allowZ = true) {
  return dt.isValid ? Formatter.create(Locale.create("en-US"), {
    allowZ,
    forceSimple: true
  }).formatDateTimeFromString(dt, format) : null;
}
function toISODate(o, extended) {
  const longFormat = o.c.year > 9999 || o.c.year < 0;
  let c = "";
  if (longFormat && o.c.year >= 0)
    c += "+";
  c += padStart(o.c.year, longFormat ? 6 : 4);
  if (extended) {
    c += "-";
    c += padStart(o.c.month);
    c += "-";
    c += padStart(o.c.day);
  } else {
    c += padStart(o.c.month);
    c += padStart(o.c.day);
  }
  return c;
}
function toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
  let c = padStart(o.c.hour);
  if (extended) {
    c += ":";
    c += padStart(o.c.minute);
    if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
      c += ":";
    }
  } else {
    c += padStart(o.c.minute);
  }
  if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
    c += padStart(o.c.second);
    if (o.c.millisecond !== 0 || !suppressMilliseconds) {
      c += ".";
      c += padStart(o.c.millisecond, 3);
    }
  }
  if (includeOffset) {
    if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
      c += "Z";
    } else if (o.o < 0) {
      c += "-";
      c += padStart(Math.trunc(-o.o / 60));
      c += ":";
      c += padStart(Math.trunc(-o.o % 60));
    } else {
      c += "+";
      c += padStart(Math.trunc(o.o / 60));
      c += ":";
      c += padStart(Math.trunc(o.o % 60));
    }
  }
  if (extendedZone) {
    c += "[" + o.zone.ianaName + "]";
  }
  return c;
}
var defaultUnitValues = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultWeekUnitValues = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var defaultOrdinalUnitValues = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
};
var orderedUnits2 = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
var orderedWeekUnits = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
];
var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function normalizeUnit(unit) {
  const normalized = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[unit.toLowerCase()];
  if (!normalized)
    throw new InvalidUnitError(unit);
  return normalized;
}
function normalizeUnitWithLocalWeeks(unit) {
  switch (unit.toLowerCase()) {
    case "localweekday":
    case "localweekdays":
      return "localWeekday";
    case "localweeknumber":
    case "localweeknumbers":
      return "localWeekNumber";
    case "localweekyear":
    case "localweekyears":
      return "localWeekYear";
    default:
      return normalizeUnit(unit);
  }
}
function quickDT(obj, opts) {
  const zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
  let ts, o;
  if (!isUndefined(obj.year)) {
    for (const u of orderedUnits2) {
      if (isUndefined(obj[u])) {
        obj[u] = defaultUnitValues[u];
      }
    }
    const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
    if (invalid) {
      return DateTime.invalid(invalid);
    }
    const offsetProvis = zone.offset(tsNow);
    [ts, o] = objToTS(obj, offsetProvis, zone);
  } else {
    ts = tsNow;
  }
  return new DateTime({ ts, zone, loc, o });
}
function diffRelative(start, end, opts) {
  const round = isUndefined(opts.round) ? true : opts.round, format = (c, unit) => {
    c = roundTo(c, round || opts.calendary ? 0 : 2, true);
    const formatter = end.loc.clone(opts).relFormatter(opts);
    return formatter.format(c, unit);
  }, differ = (unit) => {
    if (opts.calendary) {
      if (!end.hasSame(start, unit)) {
        return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
      } else
        return 0;
    } else {
      return end.diff(start, unit).get(unit);
    }
  };
  if (opts.unit) {
    return format(differ(opts.unit), opts.unit);
  }
  for (const unit of opts.units) {
    const count = differ(unit);
    if (Math.abs(count) >= 1) {
      return format(count, unit);
    }
  }
  return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
}
function lastOpts(argList) {
  let opts = {}, args;
  if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
    opts = argList[argList.length - 1];
    args = Array.from(argList).slice(0, argList.length - 1);
  } else {
    args = Array.from(argList);
  }
  return [opts, args];
}
var DateTime = class _DateTime {
  /**
   * @access private
   */
  constructor(config) {
    const zone = config.zone || Settings.defaultZone;
    let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
    this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
    let c = null, o = null;
    if (!invalid) {
      const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
      if (unchanged) {
        [c, o] = [config.old.c, config.old.o];
      } else {
        const ot = zone.offset(this.ts);
        c = tsToObj(this.ts, ot);
        invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
        c = invalid ? null : c;
        o = invalid ? null : ot;
      }
    }
    this._zone = zone;
    this.loc = config.loc || Locale.create();
    this.invalid = invalid;
    this.weekData = null;
    this.localWeekData = null;
    this.c = c;
    this.o = o;
    this.isLuxonDateTime = true;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new _DateTime({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
    opts.zone = FixedOffsetZone.utcInstance;
    return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(date, options = {}) {
    const ts = isDate(date) ? date.valueOf() : NaN;
    if (Number.isNaN(ts)) {
      return _DateTime.invalid("invalid input");
    }
    const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return _DateTime.invalid(unsupportedZone(zoneToUse));
    }
    return new _DateTime({
      ts,
      zone: zoneToUse,
      loc: Locale.fromObject(options)
    });
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(milliseconds, options = {}) {
    if (!isNumber(milliseconds)) {
      throw new InvalidArgumentError(
        `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
      );
    } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
      return _DateTime.invalid("Timestamp out of range");
    } else {
      return new _DateTime({
        ts: milliseconds,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(seconds, options = {}) {
    if (!isNumber(seconds)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new _DateTime({
        ts: seconds * 1e3,
        zone: normalizeZone(options.zone, Settings.defaultZone),
        loc: Locale.fromObject(options)
      });
    }
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.localWeekYear - a week year, according to the locale
   * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale
   * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system\'s locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: "en-US" }).toISODate() //=> '2021-12-26'
   * @return {DateTime}
   */
  static fromObject(obj, opts = {}) {
    obj = obj || {};
    const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zoneToUse.isValid) {
      return _DateTime.invalid(unsupportedZone(zoneToUse));
    }
    const loc = Locale.fromObject(opts);
    const normalized = normalizeObject(obj, normalizeUnitWithLocalWeeks);
    const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, loc);
    const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
    let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
    if (useWeekData) {
      units = orderedWeekUnits;
      defaultValues = defaultWeekUnitValues;
      objNow = gregorianToWeek(objNow, minDaysInFirstWeek, startOfWeek);
    } else if (containsOrdinal) {
      units = orderedOrdinalUnits;
      defaultValues = defaultOrdinalUnitValues;
      objNow = gregorianToOrdinal(objNow);
    } else {
      units = orderedUnits2;
      defaultValues = defaultUnitValues;
    }
    let foundFirst = false;
    for (const u of units) {
      const v = normalized[u];
      if (!isUndefined(v)) {
        foundFirst = true;
      } else if (foundFirst) {
        normalized[u] = defaultValues[u];
      } else {
        normalized[u] = objNow[u];
      }
    }
    const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
    if (invalid) {
      return _DateTime.invalid(invalid);
    }
    const gregorian = useWeekData ? weekToGregorian(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new _DateTime({
      ts: tsFinal,
      zone: zoneToUse,
      o: offsetFinal,
      loc
    });
    if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
      return _DateTime.invalid(
        "mismatched weekday",
        `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
      );
    }
    return inst;
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(text2, opts = {}) {
    const [vals, parsedZone] = parseISODate(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text2);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(text2, opts = {}) {
    const [vals, parsedZone] = parseRFC2822Date(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text2);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(text2, opts = {}) {
    const [vals, parsedZone] = parseHTTPDate(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(text2, fmt, opts = {}) {
    if (isUndefined(text2) || isUndefined(fmt)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }
    const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text2, fmt);
    if (invalid) {
      return _DateTime.invalid(invalid);
    } else {
      return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text2, specificOffset);
    }
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(text2, fmt, opts = {}) {
    return _DateTime.fromFormat(text2, fmt, opts);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(text2, opts = {}) {
    const [vals, parsedZone] = parseSQL(text2);
    return parseDataToDateTime(vals, parsedZone, opts, "SQL", text2);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(reason, explanation = null) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(invalid);
    } else {
      return new _DateTime({ invalid });
    }
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(o) {
    return o && o.isLuxonDateTime || false;
  }
  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(formatOpts, localeOpts = {}) {
    const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
    return !tokenList ? null : tokenList.map((t) => t ? t.val : null).join("");
  }
  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(fmt, localeOpts = {}) {
    const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
    return expanded.map((t) => t.val).join("");
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(unit) {
    return this[unit];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }
  /**
   * Returns true if this date is on a weekend according to the locale, false otherwise
   * @returns {boolean}
   */
  get isWeekend() {
    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
  }
  /**
   * Get the day of the week according to the locale.
   * 1 is the first day of the week and 7 is the last day of the week.
   * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,
   * @returns {number}
   */
  get localWeekday() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;
  }
  /**
   * Get the week number of the week year according to the locale. Different locales assign week numbers differently,
   * because the week can start on different days of the week (see localWeekday) and because a different number of days
   * is required for a week to count as the first week of a year.
   * @returns {number}
   */
  get localWeekNumber() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)
   * differently, see localWeekNumber.
   * @returns {number}
   */
  get localWeekYear() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "short",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, {
        format: "long",
        locale: this.locale
      });
    } else {
      return null;
    }
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
    }
  }
  /**
   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
   * in this DateTime's zone. During DST changes local time can be ambiguous, for example
   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
   * @returns {DateTime[]}
   */
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed) {
      return [this];
    }
    const dayMs = 864e5;
    const minuteMs = 6e4;
    const localTS = objToLocalTS(this.c);
    const oEarlier = this.zone.offset(localTS - dayMs);
    const oLater = this.zone.offset(localTS + dayMs);
    const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
    const o2 = this.zone.offset(localTS - oLater * minuteMs);
    if (o1 === o2) {
      return [this];
    }
    const ts1 = localTS - o1 * minuteMs;
    const ts2 = localTS - o2 * minuteMs;
    const c1 = tsToObj(ts1, o1);
    const c2 = tsToObj(ts2, o2);
    if (c1.hour === c2.hour && c1.minute === c2.minute && c1.second === c2.second && c1.millisecond === c2.millisecond) {
      return [clone2(this, { ts: ts1 }), clone2(this, { ts: ts2 })];
    }
    return [this];
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return isLeapYear(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's local week year
   * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52
   * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53
   * @type {number}
   */
  get weeksInLocalWeekYear() {
    return this.isValid ? weeksInWeekYear(
      this.localWeekYear,
      this.loc.getMinDaysInFirstWeek(),
      this.loc.getStartOfWeek()
    ) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(opts = {}) {
    const { locale, numberingSystem, calendar } = Formatter.create(
      this.loc.clone(opts),
      opts
    ).resolvedOptions(this);
    return { locale, numberingSystem, outputCalendar: calendar };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(offset2 = 0, opts = {}) {
    return this.setZone(FixedOffsetZone.instance(offset2), opts);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
    zone = normalizeZone(zone, Settings.defaultZone);
    if (zone.equals(this.zone)) {
      return this;
    } else if (!zone.isValid) {
      return _DateTime.invalid(unsupportedZone(zone));
    } else {
      let newTS = this.ts;
      if (keepLocalTime || keepCalendarTime) {
        const offsetGuess = zone.offset(this.ts);
        const asObj = this.toObject();
        [newTS] = objToTS(asObj, offsetGuess, zone);
      }
      return clone2(this, { ts: newTS, zone });
    }
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
    const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
    return clone2(this, { loc });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(locale) {
    return this.reconfigure({ locale });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   *
   * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.
   * They cannot be mixed with ISO-week units like `weekday`.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(values) {
    if (!this.isValid)
      return this;
    const normalized = normalizeObject(values, normalizeUnitWithLocalWeeks);
    const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, this.loc);
    const settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
    if ((containsGregor || containsOrdinal) && definiteWeekDef) {
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    }
    if (containsGregorMD && containsOrdinal) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    let mixed;
    if (settingWeekStuff) {
      mixed = weekToGregorian(
        { ...gregorianToWeek(this.c, minDaysInFirstWeek, startOfWeek), ...normalized },
        minDaysInFirstWeek,
        startOfWeek
      );
    } else if (!isUndefined(normalized.ordinal)) {
      mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
    } else {
      mixed = { ...this.toObject(), ...normalized };
      if (isUndefined(normalized.day)) {
        mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
      }
    }
    const [ts, o] = objToTS(mixed, this.o, this.zone);
    return clone2(this, { ts, o });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration);
    return clone2(this, adjustTime(this, dur));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(duration) {
    if (!this.isValid)
      return this;
    const dur = Duration.fromDurationLike(duration).negate();
    return clone2(this, adjustTime(this, dur));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(unit, { useLocaleWeeks = false } = {}) {
    if (!this.isValid)
      return this;
    const o = {}, normalizedUnit = Duration.normalizeUnit(unit);
    switch (normalizedUnit) {
      case "years":
        o.month = 1;
      case "quarters":
      case "months":
        o.day = 1;
      case "weeks":
      case "days":
        o.hour = 0;
      case "hours":
        o.minute = 0;
      case "minutes":
        o.second = 0;
      case "seconds":
        o.millisecond = 0;
        break;
      case "milliseconds":
        break;
    }
    if (normalizedUnit === "weeks") {
      if (useLocaleWeeks) {
        const startOfWeek = this.loc.getStartOfWeek();
        const { weekday } = this;
        if (weekday < startOfWeek) {
          o.weekNumber = this.weekNumber - 1;
        }
        o.weekday = startOfWeek;
      } else {
        o.weekday = 1;
      }
    }
    if (normalizedUnit === "quarters") {
      const q = Math.ceil(this.month / 3);
      o.month = (q - 1) * 3 + 1;
    }
    return this.set(o);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(unit, opts) {
    return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit, opts).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(fmt, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID3;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 aot 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID3;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(opts = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string}
   */
  toISO({
    format = "extended",
    suppressSeconds = false,
    suppressMilliseconds = false,
    includeOffset = true,
    extendedZone = false
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    const ext = format === "extended";
    let c = toISODate(this, ext);
    c += "T";
    c += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    return c;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string}
   */
  toISODate({ format = "extended" } = {}) {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, format === "extended");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds = false,
    suppressSeconds = false,
    includeOffset = true,
    includePrefix = false,
    extendedZone = false,
    format = "extended"
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    let c = includePrefix ? "T" : "";
    return c + toISOTime(
      this,
      format === "extended",
      suppressSeconds,
      suppressMilliseconds,
      includeOffset,
      extendedZone
    );
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string}
   */
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
    let fmt = "HH:mm:ss.SSS";
    if (includeZone || includeOffset) {
      if (includeOffsetSpace) {
        fmt += " ";
      }
      if (includeZone) {
        fmt += "z";
      } else if (includeOffset) {
        fmt += "ZZ";
      }
    }
    return toTechFormat(this, fmt, true);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(opts = {}) {
    if (!this.isValid) {
      return null;
    }
    return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : INVALID3;
  }
  /**
   * Returns a string representation of this DateTime appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`;
    } else {
      return `DateTime { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(opts = {}) {
    if (!this.isValid)
      return {};
    const base = { ...this.c };
    if (opts.includeConfig) {
      base.outputCalendar = this.outputCalendar;
      base.numberingSystem = this.loc.numberingSystem;
      base.locale = this.loc.locale;
    }
    return base;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(otherDateTime, unit = "milliseconds", opts = {}) {
    if (!this.isValid || !otherDateTime.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }
    const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
    const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff_default(earlier, later, units, durOpts);
    return otherIsLater ? diffed.negate() : diffed;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(unit = "milliseconds", opts = {}) {
    return this.diff(_DateTime.now(), unit, opts);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval}
   */
  until(otherDateTime) {
    return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(otherDateTime, unit, opts) {
    if (!this.isValid)
      return false;
    const inputMs = otherDateTime.valueOf();
    const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
    return adjustedToZone.startOf(unit, opts) <= inputMs && inputMs <= adjustedToZone.endOf(unit, opts);
  }
  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(other) {
    return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 da"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(options = {}) {
    if (!this.isValid)
      return null;
    const base = options.base || _DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
    let units = ["years", "months", "days", "hours", "minutes", "seconds"];
    let unit = options.unit;
    if (Array.isArray(options.unit)) {
      units = options.unit;
      unit = void 0;
    }
    return diffRelative(base, this.plus(padding), {
      ...options,
      numeric: "always",
      units,
      unit
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""maana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(options = {}) {
    if (!this.isValid)
      return null;
    return diffRelative(options.base || _DateTime.fromObject({}, { zone: this.zone }), this, {
      ...options,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true
    });
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...dateTimes) {
    if (!dateTimes.every(_DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...dateTimes) {
    if (!dateTimes.every(_DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(text2, fmt, options = {}) {
    const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
      locale,
      numberingSystem,
      defaultToEN: true
    });
    return explainFromTokens(localeToUse, text2, fmt);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(text2, fmt, options = {}) {
    return _DateTime.fromFormatExplain(text2, fmt, options);
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return DATE_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return DATE_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return DATE_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return DATE_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return DATETIME_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
};
function friendlyDateTime(dateTimeish) {
  if (DateTime.isDateTime(dateTimeish)) {
    return dateTimeish;
  } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
    return DateTime.fromJSDate(dateTimeish);
  } else if (dateTimeish && typeof dateTimeish === "object") {
    return DateTime.fromObject(dateTimeish);
  } else {
    throw new InvalidArgumentError(
      `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
    );
  }
}

// src/graph/builders/explicit/date_note.ts
var import_path3 = __toESM(require("path"));
var _add_explicit_edges_date_note = (graph, plugin, all_files) => {
  var _a, _b;
  const errors = [];
  const date_note_settings = plugin.settings.explicit_edge_sources.date_note;
  if (!date_note_settings.enabled)
    return { errors };
  const field_hierarchy = get_field_hierarchy(
    plugin.settings.hierarchies,
    date_note_settings.default_field
  );
  if (!field_hierarchy) {
    errors.push({
      code: "invalid_setting_value",
      message: `date_note.default_field is not a valid BC field: '${date_note_settings.default_field}'`,
      path: "settings.explicit_edge_sources.date_note.default_field"
    });
    return { errors };
  }
  const date_note_files = [];
  (_a = all_files.obsidian) == null ? void 0 : _a.forEach(({ file }) => {
    var _a2, _b2;
    date_note_files.push({
      ext: file.extension,
      path: file.path,
      basename: file.basename,
      // Not sure why would this be undefined?
      //   I tested and a file in the root of the vault still has a parent
      //   _it's_ parent is null, but that only happens if "file" is actually a folder
      folder: (_b2 = (_a2 = file.parent) == null ? void 0 : _a2.path) != null ? _b2 : ""
    });
  });
  (_b = all_files.dataview) == null ? void 0 : _b.forEach((date_note_page) => {
    const file = date_note_page.file;
    date_note_files.push({
      ext: file.ext,
      path: file.path,
      basename: file.name,
      folder: file.folder
    });
  });
  date_note_files.forEach((file) => {
    const date = DateTime.fromFormat(
      file.basename,
      date_note_settings.date_format
    );
    if (!date.isValid)
      return;
    const next_basename = date.plus({ days: 1 }).toFormat(date_note_settings.date_format);
    const next_path = import_path3.default.join(file.folder === "/" ? "" : file.folder, next_basename) + `.${file.ext}`;
    const next_file = plugin.app.vault.getAbstractFileByPath(next_path);
    if (!next_file) {
      graph.safe_add_node(next_path, { resolved: false });
    }
    graph.safe_add_directed_edge(file.path, next_path, {
      explicit: true,
      source: "date_note",
      dir: field_hierarchy.dir,
      field: date_note_settings.default_field,
      hierarchy_i: field_hierarchy.hierarchy_i
    });
  });
  return { errors };
};

// src/graph/builders/explicit/folder_note.ts
var get_folder_note_info = (plugin, metadata, path4) => {
  if (!metadata) {
    return fail(void 0);
  }
  const field = metadata[META_FIELD["folder-note-field"]];
  if (!field) {
    return fail(void 0);
  } else if (typeof field !== "string") {
    return graph_build_fail({
      path: path4,
      code: "invalid_field_value",
      message: "folder-note-field is not a string"
    });
  }
  const field_hierarchy = get_field_hierarchy(
    plugin.settings.hierarchies,
    field
  );
  if (!field_hierarchy) {
    return graph_build_fail({
      path: path4,
      code: "invalid_field_value",
      message: `folder-note-field is not a valid BC field: '${field}'`
    });
  }
  const recurse = Boolean(metadata[META_FIELD["folder-note-recurse"]]);
  return succ({
    field,
    recurse,
    dir: field_hierarchy.dir,
    hierarchy_i: field_hierarchy.hierarchy_i
  });
};
var iterate_folder_files = async (plugin, folder, cb, recurse) => {
  const folder_files = await plugin.app.vault.adapter.list(folder);
  folder_files.files.forEach((path4) => cb(path4));
  if (recurse) {
    await Promise.all(
      folder_files.folders.map(
        (folder2) => (
          // When the subfolder is recursed, what does it mean when the callback runs?
          // Where will it point up to? The initial folder's files point up to the folder_note
          // But the subfolders don't specify a folder_note
          // NOTE: For now, the subfiles will point up to the initial folder_note
          iterate_folder_files(plugin, folder2, cb, true)
        )
      )
    );
  }
};
var _add_explicit_edges_folder_note = async (graph, plugin, all_files) => {
  var _a, _b;
  const errors = [];
  const folder_notes = [];
  (_a = all_files.obsidian) == null ? void 0 : _a.forEach(
    ({ file: folder_note_file, cache: folder_note_cache }) => {
      var _a2, _b2;
      if (!folder_note_cache)
        return;
      const folder_note_info = get_folder_note_info(
        plugin,
        folder_note_cache == null ? void 0 : folder_note_cache.frontmatter,
        folder_note_file.path
      );
      if (!folder_note_info.ok) {
        if (folder_note_info.error)
          errors.push(folder_note_info.error);
        return;
      }
      folder_notes.push({
        data: folder_note_info.data,
        file: {
          path: folder_note_file.path,
          folder: (_b2 = (_a2 = folder_note_file.parent) == null ? void 0 : _a2.path) != null ? _b2 : ""
        }
      });
    }
  );
  (_b = all_files.dataview) == null ? void 0 : _b.forEach((folder_note_page) => {
    const folder_note_info = get_folder_note_info(
      plugin,
      folder_note_page,
      folder_note_page.file.path
    );
    if (!folder_note_info.ok) {
      if (folder_note_info.error)
        errors.push(folder_note_info.error);
      return;
    }
    folder_notes.push({
      data: folder_note_info.data,
      file: {
        path: folder_note_page.file.path,
        folder: folder_note_page.file.folder
      }
    });
  });
  await Promise.all(
    folder_notes.map(
      ({ data, file }) => iterate_folder_files(
        plugin,
        file.folder,
        (path4) => {
          if (path4 === file.path)
            return;
          graph.safe_add_directed_edge(file.path, path4, {
            dir: data.dir,
            explicit: true,
            field: data.field,
            source: "folder_note",
            hierarchy_i: data.hierarchy_i
          });
        },
        data.recurse
      )
    )
  );
  return { errors };
};

// src/graph/builders/explicit/regex_note.ts
var get_regex_note_info = (plugin, metadata, path4) => {
  var _a;
  if (!metadata) {
    return fail(void 0);
  }
  const regex_str = metadata[META_FIELD["regex-note-regex"]];
  if (!regex_str) {
    return fail(void 0);
  } else if (typeof regex_str !== "string") {
    return graph_build_fail({
      path: path4,
      code: "invalid_field_value",
      message: "regex-note-regex is not a string"
    });
  }
  const flags = metadata[META_FIELD["regex-note-flags"]];
  if (flags && typeof flags !== "string") {
    return graph_build_fail({
      path: path4,
      code: "invalid_field_value",
      message: "regex-note-flags is not a string"
    });
  }
  let regex;
  try {
    regex = new RegExp(regex_str, flags || "");
    console.log("regex_note regex: ", { path: path4, regex });
  } catch (e) {
    return graph_build_fail({
      path: path4,
      code: "invalid_field_value",
      message: `regex-note-regex is not a valid regex: ${regex_str}`
    });
  }
  const field = (_a = metadata[META_FIELD["regex-note-field"]]) != null ? _a : plugin.settings.explicit_edge_sources.regex_note.default_field;
  if (!field) {
    return fail(void 0);
  } else if (typeof field !== "string") {
    return graph_build_fail({
      path: path4,
      code: "invalid_field_value",
      message: "regex-note-field is not a string"
    });
  }
  const field_hierarchy = get_field_hierarchy(
    plugin.settings.hierarchies,
    field
  );
  if (!field_hierarchy) {
    return graph_build_fail({
      path: path4,
      code: "invalid_field_value",
      message: `regex-note-field is not a valid BC field: '${field}'`
    });
  }
  return succ({
    field,
    regex,
    dir: field_hierarchy.dir,
    hierarchy_i: field_hierarchy.hierarchy_i
  });
};
var _add_explicit_edges_regex_note = (graph, plugin, all_files) => {
  var _a, _b;
  const errors = [];
  const regex_note_files = [];
  (_a = all_files.obsidian) == null ? void 0 : _a.forEach(({ file, cache }) => {
    const info = get_regex_note_info(plugin, cache == null ? void 0 : cache.frontmatter, file.path);
    if (!info.ok) {
      if (info.error)
        errors.push(info.error);
      return;
    }
    regex_note_files.push({ info: info.data, path: file.path });
  });
  (_b = all_files.dataview) == null ? void 0 : _b.forEach((page) => {
    const { file } = page;
    const info = get_regex_note_info(plugin, page, file.path);
    if (!info.ok) {
      if (info.error)
        errors.push(info.error);
      return;
    }
    regex_note_files.push({ info: info.data, path: file.path });
  });
  if (!regex_note_files)
    return { errors };
  const nodes = graph.mapNodes((id) => id);
  regex_note_files.forEach((regex_note) => {
    nodes.filter((node) => regex_note.info.regex.test(node)).forEach((target_path) => {
      graph.safe_add_directed_edge(regex_note.path, target_path, {
        explicit: true,
        source: "regex_note",
        dir: regex_note.info.dir,
        field: regex_note.info.field,
        hierarchy_i: regex_note.info.hierarchy_i
      });
    });
  });
  return { errors };
};

// src/graph/builders/explicit/index.ts
var add_explicit_edges = {
  typed_link: _add_explicit_edges_typed_link,
  tag_note: _add_explicit_edges_tag_note,
  list_note: _add_explicit_edges_list_note,
  dendron_note: _add_explicit_edges_dendron_note,
  dataview_note: _add_explicit_edges_dataview_note,
  date_note: _add_explicit_edges_date_note,
  folder_note: _add_explicit_edges_folder_note,
  regex_note: _add_explicit_edges_regex_note
};

// src/graph/builders/explicit/files.ts
var get_all_files = (app) => {
  var _a;
  if (dataview_plugin.is_enabled(app)) {
    return {
      obsidian: null,
      dataview: (_a = dataview_plugin.get_api()) == null ? void 0 : _a.pages().values
    };
  } else {
    return {
      obsidian: app.vault.getMarkdownFiles().map((file) => ({
        file,
        cache: app.metadataCache.getFileCache(file)
      })),
      dataview: null
    };
  }
};

// src/graph/builders/implied/opposite_direction.ts
var _add_implied_edges_opposite_direction = (graph, plugin, { round }) => {
  plugin.settings.hierarchies.forEach((hierarchy, hierarchy_i) => {
    if (hierarchy.implied_relationships.opposite_direction.rounds < round) {
      return {};
    }
    graph.get_out_edges().filter(
      (e) => (
        // NOTE: Don't need to check for a self-loop, because the implied edge would have the same edge.id as the original edge
        e.attr.hierarchy_i === hierarchy_i && // Consider real edges & implied edges created in a previous round
        (e.attr.explicit || e.attr.round < round)
      )
    ).forEach((e) => {
      var _a;
      const opposite_direction = get_opposite_direction(e.attr.dir);
      graph.safe_add_directed_edge(e.target_id, e.source_id, {
        round,
        hierarchy_i,
        explicit: false,
        dir: opposite_direction,
        implied_kind: "opposite_direction",
        field: (_a = hierarchy.dirs[opposite_direction].at(0)) != null ? _a : null
      });
    });
  });
  return {};
};

// src/graph/builders/implied/parents_sibling_is_parent.ts
var _add_implied_edges_parents_sibling_is_parent = (graph, plugin, { round }) => {
  plugin.settings.hierarchies.forEach((hierarchy, hierarchy_i) => {
    if (hierarchy.implied_relationships.parents_sibling_is_parent.rounds < round) {
      return {};
    }
    graph.forEachNode((source_id) => {
      graph.get_attrs_chain_path(
        source_id,
        [
          { hierarchy_i, dir: "up" },
          { hierarchy_i, dir: "same" }
        ],
        (e) => (
          // Consider real edges & implied edges created in a previous round
          (e.attr.explicit || e.attr.round < round) && // Don't include the current source_id in the path
          e.target_id !== source_id
        )
      ).forEach((path4) => {
        var _a;
        graph.safe_add_directed_edge(
          source_id,
          path4.last().target_id,
          {
            round,
            dir: "up",
            hierarchy_i,
            explicit: false,
            implied_kind: "parents_sibling_is_parent",
            field: (_a = hierarchy.dirs["up"].at(0)) != null ? _a : null
          }
        );
      });
    });
  });
  return {};
};

// src/graph/builders/implied/same_parent_is_sibling.ts
var _add_implied_edges_same_parent_is_sibling = (graph, plugin, { round }) => {
  plugin.settings.hierarchies.forEach((hierarchy, hierarchy_i) => {
    if (hierarchy.implied_relationships.same_parent_is_sibling.rounds < round) {
      return {};
    }
    graph.forEachNode((source_id) => {
      graph.get_attrs_chain_path(
        source_id,
        [
          { hierarchy_i, dir: "up" },
          { hierarchy_i, dir: "down" }
        ],
        (e) => (
          // Don't include the current source_id in the path
          e.target_id !== source_id && // Consider real edges & implied edges created in a previous round
          (e.attr.explicit || e.attr.round < round)
        )
      ).forEach((path4) => {
        var _a;
        graph.safe_add_directed_edge(
          source_id,
          path4.last().target_id,
          {
            round,
            dir: "same",
            hierarchy_i,
            explicit: false,
            implied_kind: "same_parent_is_sibling",
            field: (_a = hierarchy.dirs["same"].at(0)) != null ? _a : null
          }
        );
      });
    });
  });
  return {};
};

// src/graph/builders/implied/same_sibling_is_sibling.ts
var _add_implied_edges_same_sibling_is_sibling = (graph, plugin, { round }) => {
  plugin.settings.hierarchies.forEach((hierarchy, hierarchy_i) => {
    if (hierarchy.implied_relationships.same_sibling_is_sibling.rounds < round) {
      return {};
    }
    graph.forEachNode((source_id) => {
      graph.get_attrs_chain_path(
        source_id,
        [
          { hierarchy_i, dir: "same" },
          { hierarchy_i, dir: "same" }
        ],
        (e) => (
          // Don't include the current source_id in the path
          e.target_id !== source_id && // Consider real edges & implied edges created in a previous round
          (e.attr.explicit || e.attr.round < round)
        )
      ).forEach((path4) => {
        var _a;
        graph.safe_add_directed_edge(
          source_id,
          path4.last().target_id,
          {
            round,
            dir: "same",
            hierarchy_i,
            explicit: false,
            implied_kind: "same_sibling_is_sibling",
            field: (_a = hierarchy.dirs["same"].at(0)) != null ? _a : null
          }
        );
      });
    });
  });
  return {};
};

// src/graph/builders/implied/self_is_sibling.ts
var _add_implied_edges_self_is_sibling = (graph, plugin, { round }) => {
  plugin.settings.hierarchies.forEach((hierarchy, hierarchy_i) => {
    if (hierarchy.implied_relationships.self_is_sibling.rounds < round) {
      return {};
    }
    graph.forEachNode((node) => {
      var _a;
      graph.safe_add_directed_edge(node, node, {
        round,
        hierarchy_i,
        dir: "same",
        explicit: false,
        implied_kind: "self_is_sibling",
        field: (_a = hierarchy.dirs.same.at(0)) != null ? _a : null
      });
    });
  });
  return {};
};

// src/graph/builders/implied/cousin_is_sibling.ts
var _add_implied_edges_cousin_is_sibling = (graph, plugin, { round }) => {
  plugin.settings.hierarchies.forEach((hierarchy, hierarchy_i) => {
    if (hierarchy.implied_relationships.cousin_is_sibling.rounds < round) {
      return {};
    }
    graph.forEachNode((source_id) => {
      graph.get_attrs_chain_path(
        source_id,
        [
          { hierarchy_i, dir: "up" },
          { hierarchy_i, dir: "same" },
          { hierarchy_i, dir: "down" }
        ],
        (e) => (
          // Consider real edges & implied edges created in a previous round
          (e.attr.explicit || e.attr.round < round) && // Don't include the current source_id in the path
          e.target_id !== source_id
        )
      ).forEach((path4) => {
        var _a;
        graph.safe_add_directed_edge(
          source_id,
          path4.last().target_id,
          {
            round,
            dir: "same",
            hierarchy_i,
            explicit: false,
            implied_kind: "cousin_is_sibling",
            field: (_a = hierarchy.dirs["same"].at(0)) != null ? _a : null
          }
        );
      });
    });
  });
  return {};
};

// src/graph/builders/implied/siblings_parent_is_parent.ts
var _add_implied_edges_siblings_parent_is_parent = (graph, plugin, { round }) => {
  plugin.settings.hierarchies.forEach((hierarchy, hierarchy_i) => {
    if (hierarchy.implied_relationships.siblings_parent_is_parent.rounds < round) {
      return {};
    }
    graph.forEachNode((source_id) => {
      graph.get_attrs_chain_path(
        source_id,
        [
          { hierarchy_i, dir: "same" },
          { hierarchy_i, dir: "up" }
        ],
        (e) => (
          // Don't include the current source_id in the path
          e.target_id !== source_id && // Consider real edges & implied edges created in a previous round
          (e.attr.explicit || e.attr.round < round)
        )
      ).forEach((path4) => {
        var _a;
        graph.safe_add_directed_edge(
          source_id,
          path4.last().target_id,
          {
            round,
            dir: "up",
            hierarchy_i,
            explicit: false,
            implied_kind: "siblings_parent_is_parent",
            field: (_a = hierarchy.dirs["up"].at(0)) != null ? _a : null
          }
        );
      });
    });
  });
  return {};
};

// src/graph/builders/implied/index.ts
var add_implied_edges = {
  self_is_sibling: _add_implied_edges_self_is_sibling,
  opposite_direction: _add_implied_edges_opposite_direction,
  same_parent_is_sibling: _add_implied_edges_same_parent_is_sibling,
  parents_sibling_is_parent: _add_implied_edges_parents_sibling_is_parent,
  same_sibling_is_sibling: _add_implied_edges_same_sibling_is_sibling,
  cousin_is_sibling: _add_implied_edges_cousin_is_sibling,
  siblings_parent_is_parent: _add_implied_edges_siblings_parent_is_parent
};

// src/utils/url.ts
var url_search_params = (obj, options) => {
  const { delimiter } = Object.assign({ delimiter: " " }, options);
  let params = "";
  for (const key in obj) {
    params += `${key}=${obj[key]}${delimiter}`;
  }
  params = params.slice(0, -1);
  return params;
};

// src/graph/builders/implied/custom/transitive.ts
var _add_implied_edges_custom_transitive = (graph, plugin, transitive, { round }) => {
  if (transitive.rounds < round) {
    return {};
  }
  const field_hierarchy = get_field_hierarchy(
    plugin.settings.hierarchies,
    transitive.close_field
  );
  if (!field_hierarchy) {
    console.warn(
      `Couldn't find hierarchy for transitive.close_field: ${transitive.close_field}`
    );
    return {};
  }
  graph.forEachNode((source_id) => {
    graph.get_attrs_chain_path(
      source_id,
      transitive.chain,
      (e) => (
        // Don't include the current source_id in the path
        e.target_id !== source_id && // Consider real edges & implied edges created in a previous round
        (e.attr.explicit || e.attr.round < round)
      )
    ).forEach((path4) => {
      graph.safe_add_directed_edge(
        source_id,
        path4.last().target_id,
        {
          round,
          explicit: false,
          dir: field_hierarchy.dir,
          field: transitive.close_field,
          hierarchy_i: field_hierarchy.hierarchy_i,
          implied_kind: `custom_transitive:${stringify_transitive_relation(
            transitive
          )}`
        }
      );
    });
  });
  return {};
};
var stringify_transitive_relation = (transitive) => `[${transitive.chain.map((attr2) => url_search_params(attr2)).join(", ")}] -> ${transitive.close_field}`;

// src/graph/builders/index.ts
var add_initial_nodes = (graph, all_files) => {
  if (all_files.obsidian) {
    all_files.obsidian.forEach(({ file, cache }) => {
      var _a;
      const node_attr = {
        resolved: true
      };
      const aliases = (_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.aliases;
      if (Array.isArray(aliases) && aliases.length > 0) {
        node_attr.aliases = aliases;
      }
      graph.addNode(file.path, node_attr);
    });
  } else {
    all_files.dataview.forEach((page) => {
      const node_attr = {
        resolved: true
      };
      const aliases = page.file.aliases.values;
      if (Array.isArray(aliases) && aliases.length > 0) {
        node_attr.aliases = aliases;
      }
      graph.addNode(page.file.path, node_attr);
    });
  }
};
var rebuild_graph = async (plugin) => {
  const graph = new BCGraph();
  const all_files = get_all_files(plugin.app);
  add_initial_nodes(graph, all_files);
  console.groupCollapsed("add_explicit_edges");
  const explicit_edge_results = await Promise.all(
    EXPLICIT_EDGE_SOURCES.map(async (source) => {
      const result = await add_explicit_edges[source](
        graph,
        plugin,
        all_files
      );
      return { source, ...result };
    })
  );
  console.groupEnd();
  console.log("explicit_edge_results:", explicit_edge_results);
  console.groupCollapsed("add_implied_edges");
  for (let round = 1; round <= IMPLIED_RELATIONSHIP_MAX_ROUNDS; round++) {
    console.groupCollapsed(`round ${round}`);
    Object.entries(add_implied_edges).forEach(([kind, fn]) => {
      console.group(kind);
      fn(graph, plugin, { round });
      console.groupEnd();
    });
    plugin.settings.custom_implied_relations.transitive.forEach(
      (transitive) => {
        console.group(
          `custom_transitive:${stringify_transitive_relation(
            transitive
          )}`
        );
        _add_implied_edges_custom_transitive(
          graph,
          plugin,
          transitive,
          { round }
        );
        console.groupEnd();
      }
    );
    console.groupEnd();
  }
  console.groupEnd();
  return { graph, explicit_edge_results };
};

// src/settings/SettingsTab.ts
var import_obsidian17 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store2, ...callbacks) {
  if (store2 == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store2.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store2) {
  let value;
  subscribe(store2, (_) => value = _)();
  return value;
}
function component_subscribe(component, store2, callback) {
  component.$$.on_destroy.push(subscribe(store2, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function exclude_internal_props(props) {
  const result = {};
  for (const k in props)
    if (k[0] !== "$")
      result[k] = props[k];
  return result;
}
function compute_rest_props(props, keys) {
  const rest = {};
  keys = new Set(keys);
  for (const k in props)
    if (!keys.has(k) && k[0] !== "$")
      rest[k] = props[k];
  return rest;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class _ResizeObserverSingleton {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a;
    return (_a = this._observer) != null ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) == null ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function set_svg_attributes(node, attributes) {
  for (const key in attributes) {
    attr(node, key, attributes[key]);
  }
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function select_option(select, value, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(
        /** @type {string} */
        type,
        detail,
        { cancelable }
      );
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function destroy_block(block, lookup) {
  block.d(1);
  lookup.delete(block.key);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block14, next, get_context) {
  let o = old_blocks.length;
  let n2 = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n2;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block14(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n2--;
  }
  while (o && n2) {
    const new_block = new_blocks[n2 - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n2--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n2)
    insert2(new_blocks[n2 - 1]);
  run_all(updates);
  return new_blocks;
}

// node_modules/svelte/src/runtime/internal/spread.js
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n2 = updates[i];
    if (n2) {
      for (const key in o) {
        if (!(key in n2))
          to_null_out[key] = 1;
      }
      for (const key in n2) {
        if (!accounted_for[key]) {
          update2[key] = n2[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n2;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance37, create_fragment37, not_equal, props, append_styles2 = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance37 ? instance37(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment37 ? create_fragment37($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot2 = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot2(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// node_modules/tslib/tslib.es6.mjs
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// node_modules/lucide-svelte/dist/defaultAttributes.js
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": 2,
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
var defaultAttributes_default = defaultAttributes;

// node_modules/lucide-svelte/dist/Icon.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i][0];
  child_ctx[11] = list[i][1];
  return child_ctx;
}
function create_dynamic_element(ctx) {
  let svelte_element;
  let svelte_element_levels = [
    /*attrs*/
    ctx[11]
  ];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  return {
    c() {
      svelte_element = svg_element(
        /*tag*/
        ctx[10]
      );
      set_svg_attributes(svelte_element, svelte_element_data);
    },
    m(target, anchor) {
      insert(target, svelte_element, anchor);
    },
    p(ctx2, dirty) {
      set_svg_attributes(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [dirty & /*iconNode*/
      32 && /*attrs*/
      ctx2[11]]));
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element);
      }
    }
  };
}
function create_each_block(ctx) {
  let previous_tag = (
    /*tag*/
    ctx[10]
  );
  let svelte_element_anchor;
  let svelte_element = (
    /*tag*/
    ctx[10] && create_dynamic_element(ctx)
  );
  return {
    c() {
      if (svelte_element)
        svelte_element.c();
      svelte_element_anchor = empty();
    },
    m(target, anchor) {
      if (svelte_element)
        svelte_element.m(target, anchor);
      insert(target, svelte_element_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*tag*/
        ctx2[10]
      ) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[10];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(
          previous_tag,
          /*tag*/
          ctx2[10]
        )) {
          svelte_element.d(1);
          svelte_element = create_dynamic_element(ctx2);
          previous_tag = /*tag*/
          ctx2[10];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx2, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*tag*/
        ctx2[10];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(svelte_element_anchor);
      }
      if (svelte_element)
        svelte_element.d(detaching);
    }
  };
}
function create_fragment(ctx) {
  var _a;
  let svg;
  let each_1_anchor;
  let svg_stroke_width_value;
  let svg_class_value;
  let current;
  let each_value = ensure_array_like(
    /*iconNode*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let svg_levels = [
    defaultAttributes_default,
    /*$$restProps*/
    ctx[6],
    { width: (
      /*size*/
      ctx[2]
    ) },
    { height: (
      /*size*/
      ctx[2]
    ) },
    { stroke: (
      /*color*/
      ctx[1]
    ) },
    {
      "stroke-width": svg_stroke_width_value = /*absoluteStrokeWidth*/
      ctx[4] ? Number(
        /*strokeWidth*/
        ctx[3]
      ) * 24 / Number(
        /*size*/
        ctx[2]
      ) : (
        /*strokeWidth*/
        ctx[3]
      )
    },
    {
      class: svg_class_value = `lucide-icon lucide lucide-${/*name*/
      ctx[0]} ${/*$$props*/
      (_a = ctx[7].class) != null ? _a : ""}`
    }
  ];
  let svg_data = {};
  for (let i = 0; i < svg_levels.length; i += 1) {
    svg_data = assign(svg_data, svg_levels[i]);
  }
  return {
    c() {
      svg = svg_element("svg");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
      if (default_slot)
        default_slot.c();
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(svg, null);
        }
      }
      append(svg, each_1_anchor);
      if (default_slot) {
        default_slot.m(svg, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2;
      if (dirty & /*iconNode*/
      32) {
        each_value = ensure_array_like(
          /*iconNode*/
          ctx2[5]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(svg, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        defaultAttributes_default,
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6],
        (!current || dirty & /*size*/
        4) && { width: (
          /*size*/
          ctx2[2]
        ) },
        (!current || dirty & /*size*/
        4) && { height: (
          /*size*/
          ctx2[2]
        ) },
        (!current || dirty & /*color*/
        2) && { stroke: (
          /*color*/
          ctx2[1]
        ) },
        (!current || dirty & /*absoluteStrokeWidth, strokeWidth, size*/
        28 && svg_stroke_width_value !== (svg_stroke_width_value = /*absoluteStrokeWidth*/
        ctx2[4] ? Number(
          /*strokeWidth*/
          ctx2[3]
        ) * 24 / Number(
          /*size*/
          ctx2[2]
        ) : (
          /*strokeWidth*/
          ctx2[3]
        ))) && { "stroke-width": svg_stroke_width_value },
        (!current || dirty & /*name, $$props*/
        129 && svg_class_value !== (svg_class_value = `lucide-icon lucide lucide-${/*name*/
        ctx2[0]} ${/*$$props*/
        (_a2 = ctx2[7].class) != null ? _a2 : ""}`)) && { class: svg_class_value }
      ]));
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
      destroy_each(each_blocks, detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["name", "color", "size", "strokeWidth", "absoluteStrokeWidth", "iconNode"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name } = $$props;
  let { color = "currentColor" } = $$props;
  let { size = 24 } = $$props;
  let { strokeWidth = 2 } = $$props;
  let { absoluteStrokeWidth = false } = $$props;
  let { iconNode } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("name" in $$new_props)
      $$invalidate(0, name = $$new_props.name);
    if ("color" in $$new_props)
      $$invalidate(1, color = $$new_props.color);
    if ("size" in $$new_props)
      $$invalidate(2, size = $$new_props.size);
    if ("strokeWidth" in $$new_props)
      $$invalidate(3, strokeWidth = $$new_props.strokeWidth);
    if ("absoluteStrokeWidth" in $$new_props)
      $$invalidate(4, absoluteStrokeWidth = $$new_props.absoluteStrokeWidth);
    if ("iconNode" in $$new_props)
      $$invalidate(5, iconNode = $$new_props.iconNode);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [
    name,
    color,
    size,
    strokeWidth,
    absoluteStrokeWidth,
    iconNode,
    $$restProps,
    $$props,
    $$scope,
    slots
  ];
}
var Icon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {
      name: 0,
      color: 1,
      size: 2,
      strokeWidth: 3,
      absoluteStrokeWidth: 4,
      iconNode: 5
    });
  }
};
var Icon_default = Icon;

// node_modules/lucide-svelte/dist/icons/arrow-down-wide-narrow.svelte
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment2(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "arrow-down-wide-narrow" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "m3 16 4 4 4-4" }],
    ["path", { "d": "M7 20V4" }],
    ["path", { "d": "M11 4h10" }],
    ["path", { "d": "M11 8h7" }],
    ["path", { "d": "M11 12h4" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Arrow_down_wide_narrow = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, {});
  }
};
var arrow_down_wide_narrow_default = Arrow_down_wide_narrow;

// node_modules/lucide-svelte/dist/icons/arrow-down.svelte
function create_default_slot2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment3(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "arrow-down" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot2] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "M12 5v14" }], ["path", { "d": "m19 12-7 7-7-7" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Arrow_down = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, {});
  }
};
var arrow_down_default = Arrow_down;

// node_modules/lucide-svelte/dist/icons/arrow-up-narrow-wide.svelte
function create_default_slot3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment4(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "arrow-up-narrow-wide" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot3] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "m3 8 4-4 4 4" }],
    ["path", { "d": "M7 4v16" }],
    ["path", { "d": "M11 12h4" }],
    ["path", { "d": "M11 16h7" }],
    ["path", { "d": "M11 20h10" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Arrow_up_narrow_wide = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, {});
  }
};
var arrow_up_narrow_wide_default = Arrow_up_narrow_wide;

// node_modules/lucide-svelte/dist/icons/arrow-up.svelte
function create_default_slot4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment5(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "arrow-up" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot4] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "m5 12 7-7 7 7" }], ["path", { "d": "M12 19V5" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Arrow_up = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, {});
  }
};
var arrow_up_default = Arrow_up;

// node_modules/lucide-svelte/dist/icons/chevron-down.svelte
function create_default_slot5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment6(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "chevron-down" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot5] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "m6 9 6 6 6-6" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Chevron_down = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, {});
  }
};
var chevron_down_default = Chevron_down;

// node_modules/lucide-svelte/dist/icons/chevron-right.svelte
function create_default_slot6(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment7(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "chevron-right" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot6] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "m9 18 6-6-6-6" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Chevron_right = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, {});
  }
};
var chevron_right_default = Chevron_right;

// node_modules/lucide-svelte/dist/icons/compass.svelte
function create_default_slot7(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment8(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "compass" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot7] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["circle", { "cx": "12", "cy": "12", "r": "10" }],
    [
      "polygon",
      {
        "points": "16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Compass = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment8, safe_not_equal, {});
  }
};
var compass_default = Compass;

// node_modules/lucide-svelte/dist/icons/file-json.svelte
function create_default_slot8(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment9(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "file-json" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot8] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"
      }
    ],
    ["path", { "d": "M14 2v4a2 2 0 0 0 2 2h4" }],
    [
      "path",
      {
        "d": "M10 12a1 1 0 0 0-1 1v1a1 1 0 0 1-1 1 1 1 0 0 1 1 1v1a1 1 0 0 0 1 1"
      }
    ],
    [
      "path",
      {
        "d": "M14 18a1 1 0 0 0 1-1v-1a1 1 0 0 1 1-1 1 1 0 0 1-1-1v-1a1 1 0 0 0-1-1"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var File_json = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance9, create_fragment9, safe_not_equal, {});
  }
};
var file_json_default = File_json;

// node_modules/lucide-svelte/dist/icons/plus.svelte
function create_default_slot9(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment10(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "plus" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot9] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance10($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [["path", { "d": "M5 12h14" }], ["path", { "d": "M12 5v14" }]];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Plus = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance10, create_fragment10, safe_not_equal, {});
  }
};
var plus_default = Plus;

// node_modules/lucide-svelte/dist/icons/rotate-ccw.svelte
function create_default_slot10(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment11(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "rotate-ccw" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot10] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance11($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"
      }
    ],
    ["path", { "d": "M3 3v5h5" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Rotate_ccw = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance11, create_fragment11, safe_not_equal, {});
  }
};
var rotate_ccw_default = Rotate_ccw;

// node_modules/lucide-svelte/dist/icons/save.svelte
function create_default_slot11(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment12(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "save" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot11] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"
      }
    ],
    ["polyline", { "points": "17 21 17 13 7 13 7 21" }],
    ["polyline", { "points": "7 3 7 8 15 8" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Save = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance12, create_fragment12, safe_not_equal, {});
  }
};
var save_default = Save;

// node_modules/lucide-svelte/dist/icons/settings.svelte
function create_default_slot12(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment13(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "settings" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot12] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance13($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    [
      "path",
      {
        "d": "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"
      }
    ],
    ["circle", { "cx": "12", "cy": "12", "r": "3" }]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Settings2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance13, create_fragment13, safe_not_equal, {});
  }
};
var settings_default = Settings2;

// node_modules/lucide-svelte/dist/icons/trash-2.svelte
function create_default_slot13(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment14(ctx) {
  let icon;
  let current;
  const icon_spread_levels = [
    { name: "trash-2" },
    /*$$props*/
    ctx[1],
    { iconNode: (
      /*iconNode*/
      ctx[0]
    ) }
  ];
  let icon_props = {
    $$slots: { default: [create_default_slot13] },
    $$scope: { ctx }
  };
  for (let i = 0; i < icon_spread_levels.length; i += 1) {
    icon_props = assign(icon_props, icon_spread_levels[i]);
  }
  icon = new Icon_default({ props: icon_props });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const icon_changes = dirty & /*$$props, iconNode*/
      3 ? get_spread_update(icon_spread_levels, [
        icon_spread_levels[0],
        dirty & /*$$props*/
        2 && get_spread_object(
          /*$$props*/
          ctx2[1]
        ),
        dirty & /*iconNode*/
        1 && { iconNode: (
          /*iconNode*/
          ctx2[0]
        ) }
      ]) : {};
      if (dirty & /*$$scope*/
      8) {
        icon_changes.$$scope = { dirty, ctx: ctx2 };
      }
      icon.$set(icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function instance14($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const iconNode = [
    ["path", { "d": "M3 6h18" }],
    [
      "path",
      {
        "d": "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"
      }
    ],
    [
      "path",
      {
        "d": "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"
      }
    ],
    [
      "line",
      {
        "x1": "10",
        "x2": "10",
        "y1": "11",
        "y2": "17"
      }
    ],
    [
      "line",
      {
        "x1": "14",
        "x2": "14",
        "y1": "11",
        "y2": "17"
      }
    ]
  ];
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [iconNode, $$props, slots, $$scope];
}
var Trash_2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance14, create_fragment14, safe_not_equal, {});
  }
};
var trash_2_default = Trash_2;

// src/const/index.ts
var ICON_SIZE = 20;

// src/components/ChevronOpener.svelte
function create_else_block(ctx) {
  let chevronright;
  let current;
  chevronright = new chevron_right_default({ props: { size: ICON_SIZE } });
  return {
    c() {
      create_component(chevronright.$$.fragment);
    },
    m(target, anchor) {
      mount_component(chevronright, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(chevronright.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(chevronright.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(chevronright, detaching);
    }
  };
}
function create_if_block(ctx) {
  let chevrondown;
  let current;
  chevrondown = new chevron_down_default({ props: { size: ICON_SIZE } });
  return {
    c() {
      create_component(chevrondown.$$.fragment);
    },
    m(target, anchor) {
      mount_component(chevrondown, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(chevrondown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(chevrondown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(chevrondown, detaching);
    }
  };
}
function create_fragment15(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*open*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance15($$self, $$props, $$invalidate) {
  let { open } = $$props;
  $$self.$$set = ($$props2) => {
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
  };
  return [open];
}
var ChevronOpener = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance15, create_fragment15, safe_not_equal, { open: 0 });
  }
};
var ChevronOpener_default = ChevronOpener;

// src/components/selector/HierarchyFieldSelector.svelte
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[0] = list[i];
  return child_ctx;
}
function create_if_block2(ctx) {
  let option;
  let t_value = (
    /*field*/
    ctx[0] + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*field*/
      ctx[0];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*hierarchies*/
      2 && t_value !== (t_value = /*field*/
      ctx2[0] + ""))
        set_data(t, t_value);
      if (dirty & /*hierarchies*/
      2 && option_value_value !== (option_value_value = /*field*/
      ctx2[0])) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_each_block_1(ctx) {
  let if_block_anchor;
  let if_block = (
    /*field*/
    ctx[0] && create_if_block2(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*field*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_each_block2(ctx) {
  let each_1_anchor;
  let each_value_1 = ensure_array_like(Object.values(
    /*hierarchy*/
    ctx[5].dirs
  ).flat());
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*Object, hierarchies*/
      2) {
        each_value_1 = ensure_array_like(Object.values(
          /*hierarchy*/
          ctx2[5].dirs
        ).flat());
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment16(ctx) {
  let select;
  let option;
  let t;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*hierarchies*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  return {
    c() {
      select = element("select");
      option = element("option");
      t = text("Select Field");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      option.__value = void 0;
      set_input_value(option, option.__value);
      attr(select, "class", "dropdown");
      if (
        /*field*/
        ctx[0] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[3].call(select)
        ));
    },
    m(target, anchor) {
      insert(target, select, anchor);
      append(select, option);
      append(option, t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*field*/
        ctx[0],
        true
      );
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[3]
          ),
          listen(
            select,
            "change",
            /*change_handler*/
            ctx[4]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*Object, hierarchies*/
      2) {
        each_value = ensure_array_like(
          /*hierarchies*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*field, Object, hierarchies, undefined*/
      3) {
        select_option(
          select,
          /*field*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(select);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance16($$self, $$props, $$invalidate) {
  let { hierarchies } = $$props;
  let { field = void 0 } = $$props;
  const dispatch = createEventDispatcher();
  function select_change_handler() {
    field = select_value(this);
    $$invalidate(0, field);
    $$invalidate(1, hierarchies);
  }
  const change_handler = () => {
    dispatch("select", field);
    $$invalidate(0, field = void 0);
  };
  $$self.$$set = ($$props2) => {
    if ("hierarchies" in $$props2)
      $$invalidate(1, hierarchies = $$props2.hierarchies);
    if ("field" in $$props2)
      $$invalidate(0, field = $$props2.field);
  };
  return [field, hierarchies, dispatch, select_change_handler, change_handler];
}
var HierarchyFieldSelector = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance16, create_fragment16, safe_not_equal, { hierarchies: 1, field: 0 });
  }
};
var HierarchyFieldSelector_default = HierarchyFieldSelector;

// src/components/settings/TransitiveImpliedRelations.svelte
function add_css(target) {
  append_styles(target, "svelte-17indbq", ".border.svelte-17indbq{border:var(--modal-border-width) solid\n			var(--background-modifier-border)}");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  child_ctx[12] = list;
  child_ctx[13] = i;
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i];
  child_ctx[16] = i;
  return child_ctx;
}
function create_else_block2(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "No fields in the chain. Use the selector to\n									add some";
      attr(span, "class", "text-muted");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block3(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_value_1 = ensure_array_like(
    /*transitive*/
    ctx[11].chain
  );
  const get_key = (ctx2) => {
    var _a;
    return (
      /*c_i*/
      ctx2[16] + /*item*/
      ((_a = ctx2[14].field) != null ? _a : "")
    );
  };
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_12(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_12(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "flex flex-wrap gap-3");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*transitives*/
      2) {
        each_value_1 = ensure_array_like(
          /*transitive*/
          ctx2[11].chain
        );
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, div, destroy_block, create_each_block_12, null, get_each_context_12);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
}
function create_each_block_12(key_1, ctx) {
  let div;
  let code;
  let t0_value = (
    /*item*/
    ctx[14].field + ""
  );
  let t0;
  let t1;
  let button;
  let t3;
  let mounted;
  let dispose;
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[7](
        /*transitive*/
        ctx[11],
        /*c_i*/
        ctx[16],
        /*each_value*/
        ctx[12],
        /*t_i*/
        ctx[13]
      )
    );
  }
  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      code = element("code");
      t0 = text(t0_value);
      t1 = space();
      button = element("button");
      button.textContent = "X";
      t3 = space();
      attr(button, "class", "clickable-icon");
      attr(div, "class", "flex items-center gap-1");
      this.first = div;
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, code);
      append(code, t0);
      append(div, t1);
      append(div, button);
      append(div, t3);
      if (!mounted) {
        dispose = listen(button, "click", click_handler_2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*transitives*/
      2 && t0_value !== (t0_value = /*item*/
      ctx[14].field + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_key_block(ctx) {
  let div3;
  let div0;
  let span0;
  let t1;
  let hierarchyfieldselector0;
  let t2;
  let t3;
  let div1;
  let span1;
  let t5;
  let hierarchyfieldselector1;
  let t6;
  let div2;
  let span2;
  let t8;
  let input;
  let input_min_value;
  let input_max_value;
  let input_value_value;
  let current;
  let mounted;
  let dispose;
  function select_handler(...args) {
    return (
      /*select_handler*/
      ctx[6](
        /*transitive*/
        ctx[11],
        /*each_value*/
        ctx[12],
        /*t_i*/
        ctx[13],
        ...args
      )
    );
  }
  hierarchyfieldselector0 = new HierarchyFieldSelector_default({
    props: {
      hierarchies: (
        /*plugin*/
        ctx[0].settings.hierarchies
      )
    }
  });
  hierarchyfieldselector0.$on("select", select_handler);
  function select_block_type(ctx2, dirty) {
    if (
      /*transitive*/
      ctx2[11].chain.length
    )
      return create_if_block3;
    return create_else_block2;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  function select_handler_1(...args) {
    return (
      /*select_handler_1*/
      ctx[8](
        /*transitive*/
        ctx[11],
        /*each_value*/
        ctx[12],
        /*t_i*/
        ctx[13],
        ...args
      )
    );
  }
  hierarchyfieldselector1 = new HierarchyFieldSelector_default({
    props: {
      hierarchies: (
        /*plugin*/
        ctx[0].settings.hierarchies
      ),
      field: (
        /*transitive*/
        ctx[11].close_field
      )
    }
  });
  hierarchyfieldselector1.$on("select", select_handler_1);
  function blur_handler(...args) {
    return (
      /*blur_handler*/
      ctx[9](
        /*transitive*/
        ctx[11],
        /*each_value*/
        ctx[12],
        /*t_i*/
        ctx[13],
        ...args
      )
    );
  }
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      span0 = element("span");
      span0.textContent = "Chain:";
      t1 = space();
      create_component(hierarchyfieldselector0.$$.fragment);
      t2 = space();
      if_block.c();
      t3 = space();
      div1 = element("div");
      span1 = element("span");
      span1.textContent = "Closing Field:";
      t5 = space();
      create_component(hierarchyfieldselector1.$$.fragment);
      t6 = space();
      div2 = element("div");
      span2 = element("span");
      span2.textContent = "Rounds:";
      t8 = space();
      input = element("input");
      attr(span0, "class", "font-semibold");
      attr(div0, "class", "flex flex-wrap items-center gap-3");
      attr(span1, "class", "font-semibold");
      attr(span2, "class", "font-semibold");
      attr(input, "type", "number");
      attr(input, "min", input_min_value = 0);
      attr(input, "max", input_max_value = 100);
      input.value = input_value_value = /*transitive*/
      ctx[11].rounds;
      attr(div3, "class", "my-2 flex flex-col gap-2 px-4 py-2");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div0, span0);
      append(div0, t1);
      mount_component(hierarchyfieldselector0, div0, null);
      append(div0, t2);
      if_block.m(div0, null);
      append(div3, t3);
      append(div3, div1);
      append(div1, span1);
      append(div1, t5);
      mount_component(hierarchyfieldselector1, div1, null);
      append(div3, t6);
      append(div3, div2);
      append(div2, span2);
      append(div2, t8);
      append(div2, input);
      current = true;
      if (!mounted) {
        dispose = listen(input, "blur", blur_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const hierarchyfieldselector0_changes = {};
      if (dirty & /*plugin*/
      1)
        hierarchyfieldselector0_changes.hierarchies = /*plugin*/
        ctx[0].settings.hierarchies;
      hierarchyfieldselector0.$set(hierarchyfieldselector0_changes);
      if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(div0, null);
        }
      }
      const hierarchyfieldselector1_changes = {};
      if (dirty & /*plugin*/
      1)
        hierarchyfieldselector1_changes.hierarchies = /*plugin*/
        ctx[0].settings.hierarchies;
      if (dirty & /*transitives*/
      2)
        hierarchyfieldselector1_changes.field = /*transitive*/
        ctx[11].close_field;
      hierarchyfieldselector1.$set(hierarchyfieldselector1_changes);
      if (!current || dirty & /*transitives*/
      2 && input_value_value !== (input_value_value = /*transitive*/
      ctx[11].rounds) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(hierarchyfieldselector0.$$.fragment, local);
      transition_in(hierarchyfieldselector1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(hierarchyfieldselector0.$$.fragment, local);
      transition_out(hierarchyfieldselector1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(hierarchyfieldselector0);
      if_block.d();
      destroy_component(hierarchyfieldselector1);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block3(ctx) {
  let details;
  let summary;
  let div;
  let chevronopener;
  let t0;
  let code;
  let t1_value = stringify_transitive_relation(
    /*transitive*/
    ctx[11]
  ) + "";
  let t1;
  let t2;
  let t3_value = (
    /*transitive*/
    ctx[11].rounds + ""
  );
  let t3;
  let t4;
  let t5;
  let button;
  let t7;
  let previous_key = (
    /*transitive*/
    ctx[11]
  );
  let t8;
  let current;
  let mounted;
  let dispose;
  chevronopener = new ChevronOpener_default({
    props: { open: (
      /*opens*/
      ctx[2][
        /*t_i*/
        ctx[13]
      ]
    ) }
  });
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[5](
        /*t_i*/
        ctx[13]
      )
    );
  }
  let key_block = create_key_block(ctx);
  function details_toggle_handler() {
    ctx[10].call(
      details,
      /*t_i*/
      ctx[13]
    );
  }
  return {
    c() {
      details = element("details");
      summary = element("summary");
      div = element("div");
      create_component(chevronopener.$$.fragment);
      t0 = space();
      code = element("code");
      t1 = text(t1_value);
      t2 = text("\n							(");
      t3 = text(t3_value);
      t4 = text(" rounds)");
      t5 = space();
      button = element("button");
      button.textContent = "X";
      t7 = space();
      key_block.c();
      t8 = space();
      attr(div, "class", "flex items-center gap-2");
      attr(button, "aria-label", "Delete Transitive Implied Relation");
      attr(summary, "class", "flex items-center justify-between gap-2");
      attr(details, "class", "rounded border p-2 svelte-17indbq");
    },
    m(target, anchor) {
      insert(target, details, anchor);
      append(details, summary);
      append(summary, div);
      mount_component(chevronopener, div, null);
      append(div, t0);
      append(div, code);
      append(code, t1);
      append(code, t2);
      append(code, t3);
      append(code, t4);
      append(summary, t5);
      append(summary, button);
      append(details, t7);
      key_block.m(details, null);
      append(details, t8);
      details.open = /*opens*/
      ctx[2][
        /*t_i*/
        ctx[13]
      ];
      current = true;
      if (!mounted) {
        dispose = [
          listen(button, "click", click_handler_1),
          listen(details, "toggle", details_toggle_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const chevronopener_changes = {};
      if (dirty & /*opens*/
      4)
        chevronopener_changes.open = /*opens*/
        ctx[2][
          /*t_i*/
          ctx[13]
        ];
      chevronopener.$set(chevronopener_changes);
      if ((!current || dirty & /*transitives*/
      2) && t1_value !== (t1_value = stringify_transitive_relation(
        /*transitive*/
        ctx[11]
      ) + ""))
        set_data(t1, t1_value);
      if ((!current || dirty & /*transitives*/
      2) && t3_value !== (t3_value = /*transitive*/
      ctx[11].rounds + ""))
        set_data(t3, t3_value);
      if (dirty & /*transitives*/
      2 && safe_not_equal(previous_key, previous_key = /*transitive*/
      ctx[11])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(details, t8);
      } else {
        key_block.p(ctx, dirty);
      }
      if (dirty & /*opens*/
      4) {
        details.open = /*opens*/
        ctx[2][
          /*t_i*/
          ctx[13]
        ];
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(chevronopener.$$.fragment, local);
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(chevronopener.$$.fragment, local);
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(details);
      }
      destroy_component(chevronopener);
      key_block.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment17(ctx) {
  let div2;
  let p;
  let t5;
  let div0;
  let button0;
  let plusicon;
  let t6;
  let button1;
  let saveicon;
  let t7;
  let t8;
  let div1;
  let current;
  let mounted;
  let dispose;
  plusicon = new plus_default({ props: { size: ICON_SIZE } });
  saveicon = new save_default({ props: { size: ICON_SIZE } });
  let each_value = ensure_array_like(
    /*transitives*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div2 = element("div");
      p = element("p");
      p.innerHTML = `Transitive implied relations represent <em>chains</em> of your
		Breadcrumbs fields that collapse into a single field. For example, if
		you have the fields: &quot;spouse&quot;, &quot;sibling&quot;, and &quot;sibling-in-law&quot;, you can
		add the transitive chain
		<code>[spouse, sibling] -&gt; sibling-in-law</code>. In other words, your
		spouse&#39;s sibling is your sibling-in-law.`;
      t5 = space();
      div0 = element("div");
      button0 = element("button");
      create_component(plusicon.$$.fragment);
      t6 = space();
      button1 = element("button");
      create_component(saveicon.$$.fragment);
      t7 = text("\n			Save");
      t8 = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(button0, "aria-label", "Add New Transitive Implied Relation");
      attr(button1, "class", "flex items-center gap-1");
      attr(div0, "class", "my-2 flex items-center gap-2");
      attr(div1, "class", "flex flex-col gap-3");
      attr(div2, "class", "BC-custom-transitive-implied-relations");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, p);
      append(div2, t5);
      append(div2, div0);
      append(div0, button0);
      mount_component(plusicon, button0, null);
      append(div0, t6);
      append(div0, button1);
      mount_component(saveicon, button1, null);
      append(button1, t7);
      append(div2, t8);
      append(div2, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[4]
          ),
          listen(
            button1,
            "click",
            /*save*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*opens, transitives, isNaN, plugin, console*/
      7) {
        each_value = ensure_array_like(
          /*transitives*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div1, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(plusicon.$$.fragment, local);
      transition_in(saveicon.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(plusicon.$$.fragment, local);
      transition_out(saveicon.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(plusicon);
      destroy_component(saveicon);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance17($$self, $$props, $$invalidate) {
  let { plugin } = $$props;
  let transitives = [...plugin.settings.custom_implied_relations.transitive];
  const opens = transitives.map(() => false);
  const save = () => __awaiter(void 0, void 0, void 0, function* () {
    $$invalidate(0, plugin.settings.custom_implied_relations.transitive = transitives, plugin);
    yield plugin.saveSettings();
    yield plugin.refresh();
  });
  const click_handler = async () => $$invalidate(1, transitives = [
    ...transitives,
    {
      chain: [],
      rounds: 1,
      close_field: plugin.settings.hierarchies[0].dirs.up[0]
    }
  ]);
  const click_handler_1 = (t_i) => $$invalidate(1, transitives = transitives.filter((_, j) => j !== t_i));
  const select_handler = (transitive, each_value, t_i, e) => {
    if (e.detail)
      $$invalidate(1, each_value[t_i].chain = [...transitive.chain, { field: e.detail }], transitives);
  };
  const click_handler_2 = (transitive, c_i, each_value, t_i) => {
    $$invalidate(1, each_value[t_i].chain = transitive.chain.filter((_, j) => j !== c_i), transitives);
  };
  const select_handler_1 = (transitive, each_value, t_i, e) => {
    console.log(e.detail);
    if (e.detail)
      $$invalidate(1, each_value[t_i].close_field = e.detail, transitives);
  };
  const blur_handler = (transitive, each_value, t_i, e) => {
    const num = +e.currentTarget.value;
    if (!isNaN(num))
      $$invalidate(1, each_value[t_i].rounds = num, transitives);
  };
  function details_toggle_handler(t_i) {
    opens[t_i] = this.open;
    $$invalidate(2, opens);
  }
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
  };
  return [
    plugin,
    transitives,
    opens,
    save,
    click_handler,
    click_handler_1,
    select_handler,
    click_handler_2,
    select_handler_1,
    blur_handler,
    details_toggle_handler
  ];
}
var TransitiveImpliedRelations = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance17, create_fragment17, safe_not_equal, { plugin: 0 }, add_css);
  }
};
var TransitiveImpliedRelations_default = TransitiveImpliedRelations;

// src/settings/ShowNodeOptions.ts
var import_obsidian5 = require("obsidian");
var _add_settings_show_node_options = (plugin, containerEl, cb, options) => {
  let show_node_options = cb.get();
  const setting = new import_obsidian5.Setting(containerEl).setName("Note display options").setDesc("How to display note links");
  setting.addToggle((toggle) => {
    toggle.toggleEl.before("Folder");
    toggle.setTooltip("Folder path").setValue(show_node_options.folder).onChange(async (value) => {
      show_node_options.folder = value;
      cb.set(show_node_options);
      if ((options == null ? void 0 : options.save_and_refresh) !== false) {
        await Promise.all([plugin.saveSettings()]);
        plugin.refresh({ rebuild_graph: false });
      }
    });
  });
  setting.addToggle((toggle) => {
    toggle.toggleEl.before("Extension");
    toggle.setTooltip("File extension").setValue(show_node_options.ext).onChange(async (value) => {
      show_node_options.ext = value;
      cb.set(show_node_options);
      if ((options == null ? void 0 : options.save_and_refresh) !== false) {
        await Promise.all([plugin.saveSettings()]);
        plugin.refresh({ rebuild_graph: false });
      }
    });
  });
  setting.addToggle((toggle) => {
    toggle.toggleEl.before("Alias");
    toggle.setTooltip("Alias (first alias, if available)").setValue(show_node_options.alias).onChange(async (value) => {
      show_node_options.alias = value;
      cb.set(show_node_options);
      if ((options == null ? void 0 : options.save_and_refresh) !== false) {
        await Promise.all([plugin.saveSettings()]);
        plugin.refresh({ rebuild_graph: false });
      }
    });
  });
  return setting;
};

// src/settings/CodeblockSettings.ts
var _add_settings_codeblocks = (plugin, containerEl) => {
  _add_settings_show_node_options(plugin, containerEl, {
    get: () => plugin.settings.codeblocks.show_node_options,
    set: (value) => plugin.settings.codeblocks.show_node_options = value
  });
};

// src/settings/DateNoteSettings.ts
var import_obsidian7 = require("obsidian");

// src/utils/settings.ts
var import_obsidian6 = require("obsidian");
var new_setting = (container_el, config) => {
  const setting = new import_obsidian6.Setting(container_el);
  if (config.name)
    setting.setName(config.name);
  if (config.desc)
    setting.setDesc(config.desc);
  if (config.toggle) {
    setting.addToggle((toggle) => {
      toggle.setValue(config.toggle.value).onChange(config.toggle.cb);
    });
  } else if (config.input) {
    setting.addText((text2) => {
      var _a;
      if ((_a = config.input) == null ? void 0 : _a.placeholder) {
        text2.setPlaceholder(config.input.placeholder);
      }
      text2.setValue(config.input.value);
      text2.inputEl.onblur = () => {
        config.input.cb(text2.getValue());
      };
    });
  } else if (config.select) {
    setting.addDropdown((dropdown) => {
      const options = Array.isArray(config.select.options) ? config.select.options.reduce(
        (acc, option) => {
          acc[option] = option;
          return acc;
        },
        {}
      ) : config.select.options;
      dropdown.addOptions(options).setValue(config.select.value).onChange(config.select.cb);
    });
  } else if (config.checklist) {
    const checklist_el = setting.controlEl.createEl("div", {
      attr: { class: "flex gap-3" }
    });
    let state = { ...config.checklist.options };
    Object.keys(config.checklist.options).forEach((key) => {
      const attr2 = { type: "checkbox" };
      if (config.checklist.options[key])
        attr2.checked = true;
      checklist_el.createEl("label", {
        text: key,
        cls: "flex items-center gap-1.5"
      }).createEl("input", { attr: attr2 }, (el) => {
        el.onchange = (e) => {
          if (!(e.target instanceof HTMLInputElement))
            return;
          state[key] = e.target.checked;
          config.checklist.cb(state);
        };
      });
    });
  }
  return setting;
};

// src/settings/DateNoteSettings.ts
var _add_settings_date_note = (plugin, containerEl) => {
  new_setting(containerEl, {
    name: "Enabled",
    desc: "Look for date notes to use as edge sources",
    toggle: {
      value: plugin.settings.explicit_edge_sources.date_note.enabled,
      cb: async (value) => {
        plugin.settings.explicit_edge_sources.date_note.enabled = value;
        await Promise.all([plugin.refresh(), plugin.saveSettings()]);
      }
    }
  });
  new_setting(containerEl, {
    name: "Default Field",
    desc: "Field to use to join date notes together",
    select: {
      value: plugin.settings.explicit_edge_sources.date_note.default_field,
      options: get_all_hierarchy_fields(plugin.settings.hierarchies),
      cb: async (value) => {
        plugin.settings.explicit_edge_sources.date_note.default_field = value;
        await Promise.all([plugin.refresh(), plugin.saveSettings()]);
      }
    }
  });
  const date_format_fragment = new DocumentFragment();
  date_format_fragment.createEl(
    "span",
    {},
    (el) => el.innerHTML = `<a href="https://moment.github.io/luxon/#/formatting?id=table-of-tokens">Luxon date format</a> to use`
  );
  new_setting(containerEl, {
    name: "Date Format",
    desc: date_format_fragment,
    input: {
      value: plugin.settings.explicit_edge_sources.date_note.date_format,
      cb: async (value) => {
        if (!value)
          new import_obsidian7.Notice("Date format cannot be empty");
        else {
          plugin.settings.explicit_edge_sources.date_note.date_format = value;
          await Promise.all([
            plugin.refresh(),
            plugin.saveSettings()
          ]);
        }
      }
    }
  });
};

// src/settings/DendronNoteSettings.ts
var import_obsidian8 = require("obsidian");
var _add_settings_dendron_note = (plugin, containerEl) => {
  new_setting(containerEl, {
    name: "Enabled",
    desc: "Look for dendron notes to use as edge sources",
    toggle: {
      value: plugin.settings.explicit_edge_sources.dendron_note.enabled,
      cb: async (value) => {
        plugin.settings.explicit_edge_sources.dendron_note.enabled = value;
        await Promise.all([plugin.refresh(), plugin.saveSettings()]);
      }
    }
  });
  new_setting(containerEl, {
    name: "Delimiter",
    desc: "Delimiter to use to split the note name",
    input: {
      value: plugin.settings.explicit_edge_sources.dendron_note.delimiter,
      cb: async (value) => {
        if (!value)
          new import_obsidian8.Notice("Delimiter cannot be empty");
        else {
          plugin.settings.explicit_edge_sources.dendron_note.delimiter = value;
          await Promise.all([
            plugin.refresh(),
            plugin.saveSettings()
          ]);
        }
      }
    }
  });
  new_setting(containerEl, {
    name: "Default Field",
    desc: "Field to use if the BC-dendron-note-field is not specified",
    select: {
      value: plugin.settings.explicit_edge_sources.dendron_note.default_field,
      options: get_all_hierarchy_fields(plugin.settings.hierarchies),
      cb: async (value) => {
        plugin.settings.explicit_edge_sources.dendron_note.default_field = value;
        await Promise.all([plugin.refresh(), plugin.saveSettings()]);
      }
    }
  });
  new_setting(containerEl, {
    name: "Display Trimmed",
    desc: "Display Dendron note names as the right-most split of the delimiter. e.g. `a.b.c` -> `c`",
    toggle: {
      value: plugin.settings.explicit_edge_sources.dendron_note.display_trimmed,
      cb: async (value) => {
        plugin.settings.explicit_edge_sources.dendron_note.display_trimmed = value;
        await Promise.all([plugin.refresh(), plugin.saveSettings()]);
      }
    }
  });
};

// src/settings/FreezeImpliedEdgesSettings.ts
var _add_settings_freeze_implied_edges = (plugin, contentEl) => {
  const { settings } = plugin;
  new_setting(contentEl, {
    name: "Destination",
    desc: "Where to write the frozen edges to",
    select: {
      options: ["frontmatter", "dataview-inline"],
      value: settings.commands.freeze_implied_edges.default_options.destination,
      cb: async (value) => {
        settings.commands.freeze_implied_edges.default_options.destination = value;
        await plugin.saveSettings();
      }
    }
  });
};

// src/settings/GridSettings.ts
var import_obsidian9 = require("obsidian");
var _add_settings_trail_view = (plugin, containerEl) => {
  new_setting(containerEl, {
    name: "Enable trail view",
    desc: "Show the trail view at the top of the page",
    toggle: {
      value: plugin.settings.views.page.trail.enabled,
      cb: async (value) => {
        plugin.settings.views.page.trail.enabled = value;
        await Promise.all([plugin.saveSettings()]);
        plugin.refresh({ rebuild_graph: false });
      }
    }
  });
  new_setting(containerEl, {
    name: "Format",
    desc: "Format of the trail view",
    select: {
      value: plugin.settings.views.page.trail.format,
      options: ["grid", "path"],
      cb: async (value) => {
        plugin.settings.views.page.trail.format = value;
        await Promise.all([plugin.saveSettings()]);
        plugin.refresh({ rebuild_graph: false });
      }
    }
  });
  new_setting(containerEl, {
    name: "Path Selection",
    desc: "How to select the path(s) to display in the trail view",
    select: {
      value: plugin.settings.views.page.trail.selection,
      options: ["all", "shortest", "longest"],
      cb: async (value) => {
        plugin.settings.views.page.trail.selection = value;
        await Promise.all([plugin.saveSettings()]);
        plugin.refresh({ rebuild_graph: false });
      }
    }
  });
  new_setting(containerEl, {
    name: "Default depth",
    desc: "Default depth of the trail view",
    input: {
      value: plugin.settings.views.page.trail.default_depth.toString(),
      cb: async (value) => {
        const int2 = parseInt(value);
        if (isNaN(int2)) {
          return new import_obsidian9.Notice("Depth must be a number");
        } else if (int2 < 0) {
          return new import_obsidian9.Notice("Depth must be a non-negative number");
        }
        plugin.settings.views.page.trail.default_depth = int2;
        await Promise.all([plugin.saveSettings()]);
        plugin.refresh({ rebuild_graph: false });
      }
    }
  });
  new_setting(containerEl, {
    name: "No path message",
    desc: "Message to display when there is no path to display. Leave blank to hide the trail view when there is no path.",
    input: {
      value: plugin.settings.views.page.trail.no_path_message,
      cb: async (value) => {
        plugin.settings.views.page.trail.no_path_message = value;
        await Promise.all([plugin.saveSettings()]);
        plugin.refresh({ rebuild_graph: false });
      }
    }
  });
  _add_settings_show_node_options(plugin, containerEl, {
    get: () => plugin.settings.views.page.trail.show_node_options,
    set: (value) => plugin.settings.views.page.trail.show_node_options = value
  });
};

// src/modals/ImpliedRelationshipsSettingsModal.ts
var import_obsidian10 = require("obsidian");

// src/utils/mermaid.ts
var from_edges = (edges, config) => {
  const { direction, kind } = Object.assign(
    { direction: "LR", kind: "flowchart" },
    config
  );
  return `${kind} ${direction}
` + edges.map(
    ({ source_id, target_id, attr: attr2 }) => `	${source_id} ${attr2.explicit ? "-->" : "-.->"}|${attr2.field}| ${target_id}`
  ).join("\n");
};
var Mermaid = {
  from_edges
};

// src/modals/ImpliedRelationshipsSettingsModal.ts
var ROUNDS = Array.from(
  // +1 to include 0 rounds
  { length: IMPLIED_RELATIONSHIP_MAX_ROUNDS + 1 },
  (_, i) => String(i)
);
var ImpliedRelationshipsSettingsModal = class extends import_obsidian10.Modal {
  constructor(app, plugin, hierarchy_i) {
    super(app);
    this.plugin = plugin;
    this.hierarchy_i = hierarchy_i;
  }
  onOpen() {
    const { contentEl, hierarchy_i, plugin } = this;
    const { settings } = plugin;
    const { implied_relationships } = settings.hierarchies[hierarchy_i];
    contentEl.createEl("h2", {
      text: "Implied Relationships Settings for Hierarchy " + (hierarchy_i + 1)
    });
    contentEl.createEl("p", {
      text: `Here you can change which implied relationships get added to the Breadcrumbs graph.
For each relationship, choose the number of _rounds_ to run. Zero (0) rounds disables the relation. One (1) round runs it once, only considering real relations added before. Two (2) rounds runs it twice, considering real relations and implied relations added in the first round. And so on.`
    });
    const render_mermaid_diagram = (diagram_string) => {
      const code = "```mermaid\n" + diagram_string + "\n```";
      import_obsidian10.MarkdownRenderer.render(this.app, code, contentEl, "", plugin);
    };
    const save = async () => {
      await Promise.all([plugin.saveSettings(), plugin.refresh()]);
    };
    new_setting(contentEl, {
      name: "Current Note is Sibling",
      desc: "The current note is it's own implied sibling.",
      select: {
        options: ROUNDS,
        value: String(implied_relationships.self_is_sibling.rounds),
        cb: async (val) => {
          implied_relationships.self_is_sibling.rounds = Number(val);
          await save();
        }
      }
    });
    render_mermaid_diagram(
      Mermaid.from_edges([
        {
          source_id: "Me",
          target_id: "Me",
          attr: { explicit: false, field: "same" }
        }
      ])
    );
    new_setting(contentEl, {
      name: "Opposite Direction",
      desc: "An explicit relationship in one direction implies the opposite direction.",
      select: {
        options: ROUNDS,
        value: String(implied_relationships.opposite_direction.rounds),
        cb: async (val) => {
          implied_relationships.opposite_direction.rounds = Number(val);
          await save();
        }
      }
    });
    render_mermaid_diagram(
      Mermaid.from_edges(
        [
          {
            source_id: "A",
            target_id: "B",
            attr: { explicit: true, field: "up" }
          },
          {
            source_id: "B",
            target_id: "A",
            attr: { explicit: false, field: "down" }
          }
        ],
        { direction: "LR" }
      )
    );
    new_setting(contentEl, {
      name: "Parent's Child -> Sibling",
      desc: "Your parent's children are your siblings",
      select: {
        options: ROUNDS,
        value: String(
          implied_relationships.same_parent_is_sibling.rounds
        ),
        cb: async (val) => {
          implied_relationships.same_parent_is_sibling.rounds = Number(val);
          await save();
        }
      }
    });
    render_mermaid_diagram(
      Mermaid.from_edges([
        {
          source_id: "Me",
          target_id: "Dad",
          attr: { explicit: true, field: "up" }
        },
        {
          source_id: "Dad",
          target_id: "Sister",
          attr: { explicit: true, field: "down" }
        },
        {
          source_id: "Me",
          target_id: "Sister",
          attr: { explicit: false, field: "same" }
        }
      ])
    );
    new_setting(contentEl, {
      name: "Same Siblings -> Siblings",
      desc: "Treat your siblings' siblings as your siblings",
      select: {
        options: ROUNDS,
        value: String(
          implied_relationships.same_sibling_is_sibling.rounds
        ),
        cb: async (val) => {
          implied_relationships.same_sibling_is_sibling.rounds = Number(val);
          await save();
        }
      }
    });
    render_mermaid_diagram(
      Mermaid.from_edges([
        {
          source_id: "Me",
          target_id: "Sister",
          attr: { explicit: true, field: "same" }
        },
        {
          source_id: "Sister",
          target_id: "Brother",
          attr: { explicit: true, field: "same" }
        },
        {
          source_id: "Me",
          target_id: "Brother",
          attr: { explicit: false, field: "same" }
        }
      ])
    );
    new_setting(contentEl, {
      name: "Siblings' Parent -> Parent",
      desc: "Your siblings' parents are your parents",
      select: {
        options: ROUNDS,
        value: String(
          implied_relationships.siblings_parent_is_parent.rounds
        ),
        cb: async (val) => {
          implied_relationships.siblings_parent_is_parent.rounds = Number(val);
          await save();
        }
      }
    });
    render_mermaid_diagram(
      Mermaid.from_edges([
        {
          source_id: "Me",
          target_id: "Sister",
          attr: { explicit: true, field: "same" }
        },
        {
          source_id: "Sister",
          target_id: "Dad",
          attr: { explicit: true, field: "up" }
        },
        {
          source_id: "Me",
          target_id: "Dad",
          attr: { explicit: false, field: "up" }
        }
      ])
    );
    new_setting(contentEl, {
      name: "Aunt/Uncle",
      desc: "Your parent's siblings are your parents (aunts/uncles)",
      select: {
        options: ROUNDS,
        value: String(
          implied_relationships.parents_sibling_is_parent.rounds
        ),
        cb: async (val) => {
          implied_relationships.parents_sibling_is_parent.rounds = Number(val);
          await save();
        }
      }
    });
    render_mermaid_diagram(
      Mermaid.from_edges([
        {
          source_id: "Me",
          target_id: "Dad",
          attr: { explicit: true, field: "up" }
        },
        {
          source_id: "Dad",
          target_id: "Uncle",
          attr: { explicit: true, field: "same" }
        },
        {
          source_id: "Me",
          target_id: "Uncle",
          attr: { explicit: false, field: "up" }
        }
      ])
    );
    new_setting(contentEl, {
      name: "Cousins",
      desc: "Parents' siblings' children are siblings (cousins)",
      select: {
        options: ROUNDS,
        value: String(implied_relationships.cousin_is_sibling.rounds),
        cb: async (val) => {
          implied_relationships.cousin_is_sibling.rounds = Number(val);
          await save();
        }
      }
    });
    render_mermaid_diagram(
      Mermaid.from_edges([
        {
          source_id: "Me",
          target_id: "Dad",
          attr: { explicit: true, field: "up" }
        },
        {
          source_id: "Dad",
          target_id: "Uncle",
          attr: { explicit: true, field: "same" }
        },
        {
          source_id: "Uncle",
          target_id: "Cousin",
          attr: { explicit: true, field: "down" }
        },
        {
          source_id: "Me",
          target_id: "Cousin",
          attr: { explicit: false, field: "same" }
        }
      ])
    );
    new import_obsidian10.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Save & Close").setCta().onClick(() => {
        this.close();
      })
    );
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/components/settings/HierarchySettings.svelte
function add_css2(target) {
  append_styles(target, "svelte-1xszf3s", "label.BC-Arrow-Label.svelte-1xszf3s.svelte-1xszf3s{display:inline-block;width:20px !important}details.BC-Hier-Details.svelte-1xszf3s.svelte-1xszf3s{border:1px solid var(--background-modifier-border)}.BC-Hier-Details.svelte-1xszf3s summary.svelte-1xszf3s::marker{font-size:10px}");
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  child_ctx[15] = i;
  return child_ctx;
}
function get_each_context_13(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  return child_ctx;
}
function create_each_block_13(ctx) {
  let div;
  let label;
  let label_for_value;
  let t1;
  let input;
  let input_name_value;
  let input_value_value;
  let t2;
  let mounted;
  let dispose;
  function blur_handler(...args) {
    return (
      /*blur_handler*/
      ctx[12](
        /*i*/
        ctx[15],
        /*dir*/
        ctx[16],
        ...args
      )
    );
  }
  return {
    c() {
      var _a, _b;
      div = element("div");
      label = element("label");
      label.textContent = `${ARROW_DIRECTIONS[
        /*dir*/
        ctx[16]
      ]}`;
      t1 = space();
      input = element("input");
      t2 = space();
      attr(label, "class", "BC-Arrow-Label svelte-1xszf3s");
      attr(label, "for", label_for_value = /*dir*/
      ctx[16]);
      attr(input, "type", "text");
      attr(input, "size", "20");
      attr(input, "name", input_name_value = /*dir*/
      ctx[16]);
      input.value = input_value_value = /*hier*/
      (_b = (_a = ctx[13].dirs[
        /*dir*/
        ctx[16]
      ]) == null ? void 0 : _a.join(", ")) != null ? _b : "";
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(div, t1);
      append(div, input);
      append(div, t2);
      if (!mounted) {
        dispose = listen(input, "blur", blur_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a, _b;
      ctx = new_ctx;
      if (dirty & /*hierarchies*/
      2 && input_value_value !== (input_value_value = /*hier*/
      (_b = (_a = ctx[13].dirs[
        /*dir*/
        ctx[16]
      ]) == null ? void 0 : _a.join(", ")) != null ? _b : "") && input.value !== input_value_value) {
        input.value = input_value_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_each_block4(key_1, ctx) {
  let details;
  let summary;
  let div0;
  let chevronopener;
  let t0;
  let span0;
  let t1_value = DIRECTIONS.map(func).map(func_1).join(" ") + "";
  let t1;
  let t2;
  let span1;
  let button0;
  let settingsicon;
  let t3;
  let button1;
  let trash2icon;
  let t4;
  let button2;
  let arrowdown;
  let t5;
  let button3;
  let arrowup;
  let t6;
  let div1;
  let t7;
  let details_open_value;
  let current;
  let mounted;
  let dispose;
  chevronopener = new ChevronOpener_default({
    props: { open: (
      /*opens*/
      ctx[2][
        /*i*/
        ctx[15]
      ]
    ) }
  });
  function func(...args) {
    return (
      /*func*/
      ctx[6](
        /*hier*/
        ctx[13],
        ...args
      )
    );
  }
  settingsicon = new settings_default({ props: { size: ICON_SIZE } });
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[7](
        /*i*/
        ctx[15]
      )
    );
  }
  trash2icon = new trash_2_default({ props: { size: ICON_SIZE } });
  function click_handler_3() {
    return (
      /*click_handler_3*/
      ctx[8](
        /*i*/
        ctx[15]
      )
    );
  }
  arrowdown = new arrow_down_default({ props: { size: ICON_SIZE } });
  function click_handler_4() {
    return (
      /*click_handler_4*/
      ctx[9](
        /*i*/
        ctx[15]
      )
    );
  }
  arrowup = new arrow_up_default({ props: { size: ICON_SIZE } });
  function click_handler_5() {
    return (
      /*click_handler_5*/
      ctx[10](
        /*i*/
        ctx[15]
      )
    );
  }
  function click_handler_6() {
    return (
      /*click_handler_6*/
      ctx[11](
        /*i*/
        ctx[15]
      )
    );
  }
  let each_value_1 = ensure_array_like(DIRECTIONS);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_13(get_each_context_13(ctx, each_value_1, i));
  }
  return {
    key: key_1,
    first: null,
    c() {
      details = element("details");
      summary = element("summary");
      div0 = element("div");
      create_component(chevronopener.$$.fragment);
      t0 = space();
      span0 = element("span");
      t1 = text(t1_value);
      t2 = space();
      span1 = element("span");
      button0 = element("button");
      create_component(settingsicon.$$.fragment);
      t3 = space();
      button1 = element("button");
      create_component(trash2icon.$$.fragment);
      t4 = space();
      button2 = element("button");
      create_component(arrowdown.$$.fragment);
      t5 = space();
      button3 = element("button");
      create_component(arrowup.$$.fragment);
      t6 = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t7 = space();
      attr(div0, "class", "flex items-center gap-2");
      attr(button0, "aria-label", "Hierarchy Settings");
      attr(button1, "aria-label", "Remove Hierarchy");
      attr(button2, "aria-label", "Swap with Hierarchy Below");
      attr(button3, "aria-label", "Swap with Hierarchy Above");
      attr(span1, "class", "pb-1");
      attr(summary, "class", "flex items-center justify-between svelte-1xszf3s");
      attr(details, "class", "BC-Hier-Details rounded p-2 svelte-1xszf3s");
      details.open = details_open_value = /*opens*/
      ctx[2][
        /*i*/
        ctx[15]
      ];
      this.first = details;
    },
    m(target, anchor) {
      insert(target, details, anchor);
      append(details, summary);
      append(summary, div0);
      mount_component(chevronopener, div0, null);
      append(div0, t0);
      append(div0, span0);
      append(span0, t1);
      append(summary, t2);
      append(summary, span1);
      append(span1, button0);
      mount_component(settingsicon, button0, null);
      append(span1, t3);
      append(span1, button1);
      mount_component(trash2icon, button1, null);
      append(span1, t4);
      append(span1, button2);
      mount_component(arrowdown, button2, null);
      append(span1, t5);
      append(span1, button3);
      mount_component(arrowup, button3, null);
      append(details, t6);
      append(details, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      append(details, t7);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", click_handler_2),
          listen(button1, "click", click_handler_3),
          listen(button2, "click", click_handler_4),
          listen(button3, "click", click_handler_5),
          listen(summary, "click", click_handler_6)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const chevronopener_changes = {};
      if (dirty & /*opens, hierarchies*/
      6)
        chevronopener_changes.open = /*opens*/
        ctx[2][
          /*i*/
          ctx[15]
        ];
      chevronopener.$set(chevronopener_changes);
      if ((!current || dirty & /*hierarchies*/
      2) && t1_value !== (t1_value = DIRECTIONS.map(func).map(func_1).join(" ") + ""))
        set_data(t1, t1_value);
      if (dirty & /*hierarchies, update, plugin*/
      11) {
        each_value_1 = ensure_array_like(DIRECTIONS);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_13(ctx, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_13(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (!current || dirty & /*opens, hierarchies*/
      6 && details_open_value !== (details_open_value = /*opens*/
      ctx[2][
        /*i*/
        ctx[15]
      ])) {
        details.open = details_open_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(chevronopener.$$.fragment, local);
      transition_in(settingsicon.$$.fragment, local);
      transition_in(trash2icon.$$.fragment, local);
      transition_in(arrowdown.$$.fragment, local);
      transition_in(arrowup.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(chevronopener.$$.fragment, local);
      transition_out(settingsicon.$$.fragment, local);
      transition_out(trash2icon.$$.fragment, local);
      transition_out(arrowdown.$$.fragment, local);
      transition_out(arrowup.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(details);
      }
      destroy_component(chevronopener);
      destroy_component(settingsicon);
      destroy_component(trash2icon);
      destroy_component(arrowdown);
      destroy_component(arrowup);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment18(ctx) {
  let div1;
  let div0;
  let button0;
  let plusicon;
  let t0;
  let button1;
  let trash2icon;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let mounted;
  let dispose;
  plusicon = new plus_default({ props: { size: ICON_SIZE } });
  trash2icon = new trash_2_default({ props: { size: ICON_SIZE } });
  let each_value = ensure_array_like(
    /*hierarchies*/
    ctx[1]
  );
  const get_key = (ctx2) => Object.values(
    /*hier*/
    ctx2[13].dirs
  ).flat();
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context4(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block4(key, child_ctx));
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      button0 = element("button");
      create_component(plusicon.$$.fragment);
      t0 = space();
      button1 = element("button");
      create_component(trash2icon.$$.fragment);
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(button0, "aria-label", "Add New Hierarchy");
      attr(button1, "aria-label", "Reset All Hierarchies");
      attr(div0, "class", "mb-2 flex gap-1");
      attr(div1, "class", "");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, button0);
      mount_component(plusicon, button0, null);
      append(div0, t0);
      append(div0, button1);
      mount_component(trash2icon, button1, null);
      append(div1, t1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[4]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*opens, hierarchies, update, plugin*/
      15) {
        each_value = ensure_array_like(
          /*hierarchies*/
          ctx2[1]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block4, null, get_each_context4);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(plusicon.$$.fragment, local);
      transition_in(trash2icon.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(plusicon.$$.fragment, local);
      transition_out(trash2icon.$$.fragment, local);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(plusicon);
      destroy_component(trash2icon);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
var func_1 = (fields) => `(${fields})`;
function instance18($$self, $$props, $$invalidate) {
  let { plugin } = $$props;
  let hierarchies = [...plugin.settings.hierarchies];
  const opens = hierarchies.map(() => false);
  function update2() {
    return __awaiter(this, void 0, void 0, function* () {
      $$invalidate(0, plugin.settings.hierarchies = hierarchies, plugin);
      yield plugin.saveSettings();
    });
  }
  const click_handler = async () => $$invalidate(1, hierarchies = [...hierarchies, blank_hierarchy()]);
  const click_handler_1 = async () => {
    if (window.confirm("Are you sure you want to reset all hierarchies?")) {
      $$invalidate(1, hierarchies = []);
      await update2();
      await plugin.refresh();
    }
  };
  const func = (hier, dir) => hier.dirs[dir].join(", ");
  const click_handler_2 = async (i) => {
    new ImpliedRelationshipsSettingsModal(plugin.app, plugin, i).open();
  };
  const click_handler_3 = async (i) => {
    hierarchies.splice(i, 1);
    await update2();
    await plugin.refresh();
  };
  const click_handler_4 = async (i) => {
    $$invalidate(1, hierarchies = swap_items(i, i + 1, hierarchies));
    await update2();
  };
  const click_handler_5 = async (i) => {
    $$invalidate(1, hierarchies = swap_items(i, i - 1, hierarchies));
    await update2();
  };
  const click_handler_6 = (i) => $$invalidate(2, opens[i] = !opens[i], opens);
  const blur_handler = async (i, dir, e) => {
    $$invalidate(1, hierarchies[i].dirs[dir] = split_and_trim(e.currentTarget.value), hierarchies);
    await update2();
    await plugin.refresh();
  };
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
  };
  return [
    plugin,
    hierarchies,
    opens,
    update2,
    click_handler,
    click_handler_1,
    func,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    click_handler_6,
    blur_handler
  ];
}
var HierarchySettings = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance18, create_fragment18, safe_not_equal, { plugin: 0 }, add_css2);
  }
};
var HierarchySettings_default = HierarchySettings;

// src/settings/HierarchySettings.ts
var _add_settings_hierarchies = (plugin, containerEl) => {
  new HierarchySettings_default({
    target: containerEl,
    props: { plugin }
  });
};

// src/settings/ListIndexSettings.ts
var import_obsidian12 = require("obsidian");

// src/menus/EdgeSortIdMenu.ts
var import_obsidian11 = require("obsidian");
var ORDERS = [1, -1];
var EdgeSortIdMenu = ({
  cb,
  value,
  exclude_fields
}) => {
  const menu = new import_obsidian11.Menu();
  ORDERS.forEach((order) => {
    menu.addItem(
      (item) => item.setTitle(`Order: ${order === 1 ? "asc" : "desc"}`).setChecked(value.order === order).onClick(() => {
        value.order = order;
        cb(value);
      })
    );
  });
  menu.addSeparator();
  SIMPLE_EDGE_SORT_FIELDS.filter((f) => !(exclude_fields == null ? void 0 : exclude_fields.includes(f))).forEach(
    (field) => {
      menu.addItem(
        (item) => item.setTitle("Field: " + field).setChecked(value.field === field).onClick(() => {
          value.field = field;
          cb(value);
        })
      );
    }
  );
  menu.addSeparator();
  if (!(exclude_fields == null ? void 0 : exclude_fields.includes("neighbour-dir:"))) {
    DIRECTIONS.forEach((dir) => {
      const field = `neighbour-dir:${dir}`;
      menu.addItem(
        (item) => item.setTitle("Field: " + field).setChecked(value.field === field).onClick(() => {
          value.field = field;
          cb(value);
        })
      );
    });
  }
  return menu;
};

// src/components/selector/EdgeSortIdSelector.svelte
function create_else_block3(ctx) {
  let arrowdownwidenarrow;
  let current;
  arrowdownwidenarrow = new arrow_down_wide_narrow_default({ props: { size: ICON_SIZE } });
  return {
    c() {
      create_component(arrowdownwidenarrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(arrowdownwidenarrow, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(arrowdownwidenarrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(arrowdownwidenarrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(arrowdownwidenarrow, detaching);
    }
  };
}
function create_if_block4(ctx) {
  let arrowupnarrowwide;
  let current;
  arrowupnarrowwide = new arrow_up_narrow_wide_default({ props: { size: ICON_SIZE } });
  return {
    c() {
      create_component(arrowupnarrowwide.$$.fragment);
    },
    m(target, anchor) {
      mount_component(arrowupnarrowwide, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(arrowupnarrowwide.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(arrowupnarrowwide.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(arrowupnarrowwide, detaching);
    }
  };
}
function create_fragment19(ctx) {
  let button;
  let current_block_type_index;
  let if_block;
  let button_class_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block4, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*edge_sort_id*/
      ctx2[0].order === 1
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      button = element("button");
      if_block.c();
      attr(button, "class", button_class_value = "flex gap-1 " + /*cls*/
      ctx[2]);
      attr(button, "aria-label", "Change sort field/order");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_blocks[current_block_type_index].m(button, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index !== previous_block_index) {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
        }
        transition_in(if_block, 1);
        if_block.m(button, null);
      }
      if (!current || dirty & /*cls*/
      4 && button_class_value !== (button_class_value = "flex gap-1 " + /*cls*/
      ctx2[2])) {
        attr(button, "class", button_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
}
function instance19($$self, $$props, $$invalidate) {
  let { edge_sort_id } = $$props;
  let { exclude_fields = [] } = $$props;
  let { cls = "" } = $$props;
  const click_handler = (e) => {
    EdgeSortIdMenu({
      exclude_fields,
      value: edge_sort_id,
      cb: (value) => $$invalidate(0, edge_sort_id = value)
    }).showAtMouseEvent(e);
  };
  $$self.$$set = ($$props2) => {
    if ("edge_sort_id" in $$props2)
      $$invalidate(0, edge_sort_id = $$props2.edge_sort_id);
    if ("exclude_fields" in $$props2)
      $$invalidate(1, exclude_fields = $$props2.exclude_fields);
    if ("cls" in $$props2)
      $$invalidate(2, cls = $$props2.cls);
  };
  return [edge_sort_id, exclude_fields, cls, click_handler];
}
var EdgeSortIdSelector = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance19, create_fragment19, safe_not_equal, {
      edge_sort_id: 0,
      exclude_fields: 1,
      cls: 2
    });
  }
};
var EdgeSortIdSelector_default = EdgeSortIdSelector;

// src/components/settings/SettingItem.svelte
function create_fragment20(ctx) {
  let div4;
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2;
  let t3;
  let div3;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text(
        /*name*/
        ctx[0]
      );
      t1 = space();
      div1 = element("div");
      t2 = text(
        /*description*/
        ctx[1]
      );
      t3 = space();
      div3 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "setting-item-name");
      attr(div1, "class", "setting-item-description");
      attr(div2, "class", "setting-item-info");
      attr(div3, "class", "setting-item-control");
      attr(div4, "class", "setting-item");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div1, t2);
      append(div4, t3);
      append(div4, div3);
      if (default_slot) {
        default_slot.m(div3, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*name*/
      1)
        set_data(
          t0,
          /*name*/
          ctx2[0]
        );
      if (!current || dirty & /*description*/
      2)
        set_data(
          t2,
          /*description*/
          ctx2[1]
        );
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance20($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name } = $$props;
  let { description } = $$props;
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("description" in $$props2)
      $$invalidate(1, description = $$props2.description);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [name, description, $$scope, slots];
}
var SettingItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance20, create_fragment20, safe_not_equal, { name: 0, description: 1 });
  }
};
var SettingItem_default = SettingItem;

// src/components/settings/EdgeSortIdSettingItem.svelte
function create_default_slot14(ctx) {
  let edgesortidselector;
  let updating_edge_sort_id;
  let current;
  function edgesortidselector_edge_sort_id_binding(value) {
    ctx[1](value);
  }
  let edgesortidselector_props = {};
  if (
    /*edge_sort_id*/
    ctx[0] !== void 0
  ) {
    edgesortidselector_props.edge_sort_id = /*edge_sort_id*/
    ctx[0];
  }
  edgesortidselector = new EdgeSortIdSelector_default({ props: edgesortidselector_props });
  binding_callbacks.push(() => bind(edgesortidselector, "edge_sort_id", edgesortidselector_edge_sort_id_binding));
  return {
    c() {
      create_component(edgesortidselector.$$.fragment);
    },
    m(target, anchor) {
      mount_component(edgesortidselector, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const edgesortidselector_changes = {};
      if (!updating_edge_sort_id && dirty & /*edge_sort_id*/
      1) {
        updating_edge_sort_id = true;
        edgesortidselector_changes.edge_sort_id = /*edge_sort_id*/
        ctx2[0];
        add_flush_callback(() => updating_edge_sort_id = false);
      }
      edgesortidselector.$set(edgesortidselector_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(edgesortidselector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(edgesortidselector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(edgesortidselector, detaching);
    }
  };
}
function create_fragment21(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: "Edge Sort",
      description: "Select the sorting method for the edges in the graph.",
      $$slots: { default: [create_default_slot14] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const settingitem_changes = {};
      if (dirty & /*$$scope, edge_sort_id*/
      9) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function instance21($$self, $$props, $$invalidate) {
  let { edge_sort_id } = $$props;
  const dispatch = createEventDispatcher();
  function edgesortidselector_edge_sort_id_binding(value) {
    edge_sort_id = value;
    $$invalidate(0, edge_sort_id);
  }
  $$self.$$set = ($$props2) => {
    if ("edge_sort_id" in $$props2)
      $$invalidate(0, edge_sort_id = $$props2.edge_sort_id);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*edge_sort_id*/
    1) {
      $:
        if (edge_sort_id) {
          dispatch("select", edge_sort_id);
        }
    }
  };
  return [edge_sort_id, edgesortidselector_edge_sort_id_binding];
}
var EdgeSortIdSettingItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance21, create_fragment21, safe_not_equal, { edge_sort_id: 0 });
  }
};
var EdgeSortIdSettingItem_default = EdgeSortIdSettingItem;

// src/const/links.ts
var LINK_KINDS = ["none", "wiki", "markdown"];

// src/settings/ListIndexSettings.ts
var _add_settings_list_index = (plugin, contentEl) => {
  const { settings } = plugin;
  new import_obsidian12.Setting(contentEl).setName("Hierarchy").setDesc("Optionally constrain the traversal to a specific hierarchy").addDropdown((dropdown) => {
    dropdown.addOption("-1", "All");
    settings.hierarchies.forEach((hierarchy, i) => {
      dropdown.addOption(String(i), stringify_hierarchy(hierarchy));
    });
    dropdown.setValue(
      String(
        settings.commands.list_index.default_options.hierarchy_i
      )
    );
    dropdown.onChange(async (value) => {
      settings.commands.list_index.default_options.hierarchy_i = Number(value);
      await plugin.saveSettings();
    });
  });
  new_setting(contentEl, {
    name: "Direction",
    desc: "Direction to traverse",
    select: {
      options: DIRECTIONS,
      value: settings.commands.list_index.default_options.dir,
      cb: async (value) => {
        settings.commands.list_index.default_options.dir = value;
        await plugin.saveSettings();
      }
    }
  });
  new_setting(contentEl, {
    name: "Link Kind",
    desc: "Format to use for links",
    select: {
      options: LINK_KINDS,
      value: settings.commands.list_index.default_options.link_kind,
      cb: async (value) => {
        settings.commands.list_index.default_options.link_kind = value;
        await plugin.saveSettings();
      }
    }
  });
  new_setting(contentEl, {
    name: "Indent",
    desc: "Indentation to use for each level",
    input: {
      value: settings.commands.list_index.default_options.indent,
      cb: async (value) => {
        settings.commands.list_index.default_options.indent = value;
        await plugin.saveSettings();
      }
    }
  });
  new EdgeSortIdSettingItem_default({
    target: contentEl,
    props: {
      edge_sort_id: settings.commands.list_index.default_options.edge_sort_id
    }
  }).$on("select", async (e) => {
    settings.commands.list_index.default_options.edge_sort_id = e.detail;
    await plugin.saveSettings();
  });
  _add_settings_show_node_options(plugin, contentEl, {
    get: () => settings.commands.list_index.default_options.show_node_options,
    set: (value) => settings.commands.list_index.default_options.show_node_options = value
  });
};

// src/settings/MatrixSettings.ts
var _add_settings_matrix = (plugin, containerEl) => {
  _add_settings_show_node_options(plugin, containerEl, {
    get: () => plugin.settings.views.side.matrix.show_node_options,
    set: (value) => plugin.settings.views.side.matrix.show_node_options = value
  });
};

// src/views/page.ts
var import_obsidian15 = require("obsidian");

// src/stores/active_file.ts
var import_obsidian13 = require("obsidian");

// node_modules/svelte/src/runtime/store/index.js
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set, update2) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}

// src/stores/active_file.ts
var store = writable(null);
var active_file_store = {
  ...store,
  refresh: (app) => store.set(app.workspace.getActiveFile())
};

// src/components/ObsidianLink.svelte
var import_obsidian14 = require("obsidian");
function create_fragment22(ctx) {
  let a;
  let t;
  let a_class_value;
  let a_aria_label_value;
  let mounted;
  let dispose;
  return {
    c() {
      var _a;
      a = element("a");
      t = text(
        /*display*/
        ctx[1]
      );
      attr(a, "class", a_class_value = "internal-link " + /*cls*/
      ctx[4]);
      attr(
        a,
        "href",
        /*no_ext*/
        ctx[6]
      );
      attr(
        a,
        "data-href",
        /*no_ext*/
        ctx[6]
      );
      attr(a, "aria-label", a_aria_label_value = // Previously checked if path === display
      // But I think we should only show the label if the folder/basename is different,
      // not just the extension
      /*no_ext*/
      ctx[6] === /*display*/
      ctx[1] ? "" : (
        /*path*/
        ctx[0]
      ));
      toggle_class(a, "is-unresolved", !/*resolved*/
      ctx[2]);
      toggle_class(
        a,
        "BC-active-note",
        /*$active_file_store*/
        ((_a = ctx[5]) == null ? void 0 : _a.path) === /*path*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, t);
      if (!mounted) {
        dispose = listen(
          a,
          "click",
          /*click_handler*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      var _a;
      if (dirty & /*display*/
      2)
        set_data(
          t,
          /*display*/
          ctx2[1]
        );
      if (dirty & /*cls*/
      16 && a_class_value !== (a_class_value = "internal-link " + /*cls*/
      ctx2[4])) {
        attr(a, "class", a_class_value);
      }
      if (dirty & /*display, path*/
      3 && a_aria_label_value !== (a_aria_label_value = // Previously checked if path === display
      // But I think we should only show the label if the folder/basename is different,
      // not just the extension
      /*no_ext*/
      ctx2[6] === /*display*/
      ctx2[1] ? "" : (
        /*path*/
        ctx2[0]
      ))) {
        attr(a, "aria-label", a_aria_label_value);
      }
      if (dirty & /*cls, resolved*/
      20) {
        toggle_class(a, "is-unresolved", !/*resolved*/
        ctx2[2]);
      }
      if (dirty & /*cls, $active_file_store, path*/
      49) {
        toggle_class(
          a,
          "BC-active-note",
          /*$active_file_store*/
          ((_a = ctx2[5]) == null ? void 0 : _a.path) === /*path*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(a);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance22($$self, $$props, $$invalidate) {
  let $active_file_store;
  component_subscribe($$self, active_file_store, ($$value) => $$invalidate(5, $active_file_store = $$value));
  let { path: path4 } = $$props;
  let { display } = $$props;
  let { resolved } = $$props;
  let { plugin } = $$props;
  let { cls = "" } = $$props;
  const no_ext = Paths.drop_ext(path4);
  const click_handler = (e) => {
    var _a;
    plugin.app.workspace.openLinkText(path4, (_a = $active_file_store == null ? void 0 : $active_file_store.path) != null ? _a : "", import_obsidian14.Keymap.isModEvent(e), {
      group: plugin.app.workspace.getLeaf(false)
    });
  };
  $$self.$$set = ($$props2) => {
    if ("path" in $$props2)
      $$invalidate(0, path4 = $$props2.path);
    if ("display" in $$props2)
      $$invalidate(1, display = $$props2.display);
    if ("resolved" in $$props2)
      $$invalidate(2, resolved = $$props2.resolved);
    if ("plugin" in $$props2)
      $$invalidate(3, plugin = $$props2.plugin);
    if ("cls" in $$props2)
      $$invalidate(4, cls = $$props2.cls);
  };
  return [
    path4,
    display,
    resolved,
    plugin,
    cls,
    $active_file_store,
    no_ext,
    click_handler
  ];
}
var ObsidianLink = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance22, create_fragment22, safe_not_equal, {
      path: 0,
      display: 1,
      resolved: 2,
      plugin: 3,
      cls: 4
    });
  }
};
var ObsidianLink_default = ObsidianLink;

// src/components/EdgeLink.svelte
function create_fragment23(ctx) {
  let obsidianlink;
  let current;
  obsidianlink = new ObsidianLink_default({
    props: {
      plugin: (
        /*plugin*/
        ctx[1]
      ),
      display: (
        /*display*/
        ctx[3]
      ),
      path: (
        /*edge*/
        ctx[0].target_id
      ),
      resolved: (
        /*edge*/
        ctx[0].target_attr.resolved
      ),
      cls: (
        /*cls*/
        ctx[2] + " BC-edge " + /*edge*/
        (ctx[0].attr.explicit ? "BC-edge-explicit" : `BC-edge-implied BC-edge-implied-${/*edge*/
        ctx[0].attr.implied_kind}`) + " "
      )
    }
  });
  return {
    c() {
      create_component(obsidianlink.$$.fragment);
    },
    m(target, anchor) {
      mount_component(obsidianlink, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const obsidianlink_changes = {};
      if (dirty & /*plugin*/
      2)
        obsidianlink_changes.plugin = /*plugin*/
        ctx2[1];
      if (dirty & /*edge*/
      1)
        obsidianlink_changes.path = /*edge*/
        ctx2[0].target_id;
      if (dirty & /*edge*/
      1)
        obsidianlink_changes.resolved = /*edge*/
        ctx2[0].target_attr.resolved;
      if (dirty & /*cls, edge*/
      5)
        obsidianlink_changes.cls = /*cls*/
        ctx2[2] + " BC-edge " + /*edge*/
        (ctx2[0].attr.explicit ? "BC-edge-explicit" : `BC-edge-implied BC-edge-implied-${/*edge*/
        ctx2[0].attr.implied_kind}`) + " ";
      obsidianlink.$set(obsidianlink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(obsidianlink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(obsidianlink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(obsidianlink, detaching);
    }
  };
}
function instance23($$self, $$props, $$invalidate) {
  let { edge } = $$props;
  let { plugin } = $$props;
  let { show_node_options } = $$props;
  let { cls = "" } = $$props;
  const { dendron_note } = plugin.settings.explicit_edge_sources;
  const display = stringify_node(edge.target_id, edge.target_attr, {
    show_node_options,
    trim_basename_delimiter: dendron_note.enabled && dendron_note.display_trimmed ? dendron_note.delimiter : void 0
  });
  $$self.$$set = ($$props2) => {
    if ("edge" in $$props2)
      $$invalidate(0, edge = $$props2.edge);
    if ("plugin" in $$props2)
      $$invalidate(1, plugin = $$props2.plugin);
    if ("show_node_options" in $$props2)
      $$invalidate(4, show_node_options = $$props2.show_node_options);
    if ("cls" in $$props2)
      $$invalidate(2, cls = $$props2.cls);
  };
  return [edge, plugin, cls, display, show_node_options];
}
var EdgeLink = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance23, create_fragment23, safe_not_equal, {
      edge: 0,
      plugin: 1,
      show_node_options: 4,
      cls: 2
    });
  }
};
var EdgeLink_default = EdgeLink;

// src/components/page_views/PrevNextView.svelte
function add_css3(target) {
  append_styles(target, "svelte-qpvj6y", ".BC-prev-next-view.svelte-qpvj6y>div.svelte-qpvj6y{border:1px solid var(--background-modifier-border)}.BC-next-prev-item.svelte-qpvj6y.svelte-qpvj6y{border-bottom:1px solid var(--background-modifier-border)}");
}
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function get_each_context_14(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_if_block5(ctx) {
  var _a, _b, _c, _d;
  let div0;
  let t;
  let div1;
  let current;
  let each_value_1 = ensure_array_like(
    /*grouped_out_edges*/
    (_b = (_a = ctx[1]) == null ? void 0 : _a.prev) != null ? _b : []
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_14(get_each_context_14(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks_1[i], 1, 1, () => {
    each_blocks_1[i] = null;
  });
  let each_value = ensure_array_like(
    /*grouped_out_edges*/
    (_d = (_c = ctx[1]) == null ? void 0 : _c.next) != null ? _d : []
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  const out_1 = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div0 = element("div");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "flex w-full flex-col svelte-qpvj6y");
      attr(div1, "class", "flex w-full flex-col svelte-qpvj6y");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div0, null);
        }
      }
      insert(target, t, anchor);
      insert(target, div1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c2, _d2;
      if (dirty & /*grouped_out_edges, plugin*/
      3) {
        each_value_1 = ensure_array_like(
          /*grouped_out_edges*/
          (_b2 = (_a2 = ctx2[1]) == null ? void 0 : _a2.prev) != null ? _b2 : []
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_14(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
            transition_in(each_blocks_1[i], 1);
          } else {
            each_blocks_1[i] = create_each_block_14(child_ctx);
            each_blocks_1[i].c();
            transition_in(each_blocks_1[i], 1);
            each_blocks_1[i].m(div0, null);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (dirty & /*grouped_out_edges, plugin*/
      3) {
        each_value = ensure_array_like(
          /*grouped_out_edges*/
          (_d2 = (_c2 = ctx2[1]) == null ? void 0 : _c2.next) != null ? _d2 : []
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div1, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out_1(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t);
        detach(div1);
      }
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_14(ctx) {
  let div;
  let span;
  let t1;
  let edgelink;
  let t2;
  let current;
  edgelink = new EdgeLink_default({
    props: {
      edge: (
        /*edge*/
        ctx[3]
      ),
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      cls: "grow",
      show_node_options: (
        /*plugin*/
        ctx[0].settings.views.page.prev_next.show_node_options
      )
    }
  });
  return {
    c() {
      div = element("div");
      span = element("span");
      span.textContent = `${/*edge*/
      ctx[3].attr.field}`;
      t1 = space();
      create_component(edgelink.$$.fragment);
      t2 = space();
      attr(span, "class", "BC-field");
      attr(div, "class", "BC-next-prev-item flex gap-3 p-1 text-left svelte-qpvj6y");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(div, t1);
      mount_component(edgelink, div, null);
      append(div, t2);
      current = true;
    },
    p(ctx2, dirty) {
      const edgelink_changes = {};
      if (dirty & /*plugin*/
      1)
        edgelink_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*plugin*/
      1)
        edgelink_changes.show_node_options = /*plugin*/
        ctx2[0].settings.views.page.prev_next.show_node_options;
      edgelink.$set(edgelink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(edgelink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(edgelink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(edgelink);
    }
  };
}
function create_each_block5(ctx) {
  let div;
  let edgelink;
  let t0;
  let span;
  let t2;
  let current;
  edgelink = new EdgeLink_default({
    props: {
      edge: (
        /*edge*/
        ctx[3]
      ),
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      cls: "grow",
      show_node_options: (
        /*plugin*/
        ctx[0].settings.views.page.prev_next.show_node_options
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(edgelink.$$.fragment);
      t0 = space();
      span = element("span");
      span.textContent = `${/*edge*/
      ctx[3].attr.field}`;
      t2 = space();
      attr(span, "class", "BC-field");
      attr(div, "class", "BC-next-prev-item flex gap-3 p-1 text-right svelte-qpvj6y");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(edgelink, div, null);
      append(div, t0);
      append(div, span);
      append(div, t2);
      current = true;
    },
    p(ctx2, dirty) {
      const edgelink_changes = {};
      if (dirty & /*plugin*/
      1)
        edgelink_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*plugin*/
      1)
        edgelink_changes.show_node_options = /*plugin*/
        ctx2[0].settings.views.page.prev_next.show_node_options;
      edgelink.$set(edgelink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(edgelink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(edgelink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(edgelink);
    }
  };
}
function create_fragment24(ctx) {
  var _a, _b, _c, _d;
  let div;
  let current;
  let if_block = (
    /*grouped_out_edges*/
    (((_b = (_a = ctx[1]) == null ? void 0 : _a.prev) == null ? void 0 : _b.length) || /*grouped_out_edges*/
    ((_d = (_c = ctx[1]) == null ? void 0 : _c.next) == null ? void 0 : _d.length)) && create_if_block5(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "BC-prev-next-view flex svelte-qpvj6y");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2, _b2, _c2, _d2;
      if (
        /*grouped_out_edges*/
        ((_b2 = (_a2 = ctx2[1]) == null ? void 0 : _a2.prev) == null ? void 0 : _b2.length) || /*grouped_out_edges*/
        ((_d2 = (_c2 = ctx2[1]) == null ? void 0 : _c2.next) == null ? void 0 : _d2.length)
      )
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance24($$self, $$props, $$invalidate) {
  let $active_file_store;
  component_subscribe($$self, active_file_store, ($$value) => $$invalidate(2, $active_file_store = $$value));
  let { plugin } = $$props;
  const grouped_out_edges = $active_file_store && // Even tho we ensure the graph is built before the views are registered,
  // Existing views still try render before the graph is built.
  plugin.graph.hasNode($active_file_store.path) ? group_by(plugin.graph.get_out_edges($active_file_store.path).filter((e) => has_edge_attrs(e, { $or_dirs: ["prev", "next"] })), (e) => e.attr.dir) : null;
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
  };
  return [plugin, grouped_out_edges];
}
var PrevNextView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance24, create_fragment24, safe_not_equal, { plugin: 0 }, add_css3);
  }
};
var PrevNextView_default = PrevNextView;

// src/components/page_views/TrailViewGrid.svelte
function add_css4(target) {
  append_styles(target, "svelte-ok6mul", ".BC-trail-view-item.svelte-ok6mul{border:1px solid var(--background-modifier-border)}");
}
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  child_ctx[7] = i;
  return child_ctx;
}
function get_each_context_15(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i].first;
  child_ctx[9] = list[i].last;
  const constants_0 = (
    /*square*/
    child_ctx[1][
      /*first*/
      child_ctx[8]
    ][
      /*j*/
      child_ctx[7]
    ]
  );
  child_ctx[10] = constants_0;
  return child_ctx;
}
function create_if_block6(ctx) {
  let edgelink;
  let current;
  edgelink = new EdgeLink_default({
    props: {
      edge: (
        /*edge*/
        ctx[10]
      ),
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      cls: "p-1 grow flex justify-center items-center",
      show_node_options: (
        /*plugin*/
        ctx[0].settings.views.page.trail.show_node_options
      )
    }
  });
  return {
    c() {
      create_component(edgelink.$$.fragment);
    },
    m(target, anchor) {
      mount_component(edgelink, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const edgelink_changes = {};
      if (dirty & /*plugin*/
      1)
        edgelink_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*plugin*/
      1)
        edgelink_changes.show_node_options = /*plugin*/
        ctx2[0].settings.views.page.trail.show_node_options;
      edgelink.$set(edgelink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(edgelink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(edgelink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(edgelink, detaching);
    }
  };
}
function create_each_block_15(ctx) {
  let div;
  let t;
  let current;
  let if_block = (
    /*edge*/
    ctx[10] && create_if_block6(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      attr(div, "class", "BC-trail-view-item flex svelte-ok6mul");
      set_style(
        div,
        "grid-area",
        /*first*/
        ctx[8] + 1 + " / " + /*j*/
        (ctx[7] + 1) + " / " + /*last*/
        (ctx[9] + 2) + " / " + /*j*/
        (ctx[7] + 2)
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append(div, t);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*edge*/
        ctx2[10]
      )
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function create_each_block6(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like(
    /*col*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_15(get_each_context_15(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*col_runs, square, plugin*/
      7) {
        each_value_1 = ensure_array_like(
          /*col*/
          ctx2[5]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_15(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_15(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment25(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*col_runs*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block6(get_each_context6(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      var _a, _b;
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "BC-trail-view grid");
      set_style(div, "grid-template-rows", "1fr ".repeat(
        /*square*/
        ctx[1].length
      ));
      set_style(div, "grid-template-columns", "1fr ".repeat(
        /*square*/
        (_b = (_a = ctx[1].at(0)) == null ? void 0 : _a.length) != null ? _b : 0
      ));
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*col_runs, square, plugin*/
      7) {
        each_value = ensure_array_like(
          /*col_runs*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block6(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance25($$self, $$props, $$invalidate) {
  let { plugin } = $$props;
  let { all_paths: all_paths2 } = $$props;
  const reversed = all_paths2.map((path4) => [...path4].reverse());
  const square = ensure_square_array(reversed, null, true);
  const col_runs = transpose(square).map((col) => gather_by_runs(col, (e) => e ? e.target_id : null));
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("all_paths" in $$props2)
      $$invalidate(3, all_paths2 = $$props2.all_paths);
  };
  return [plugin, square, col_runs, all_paths2];
}
var TrailViewGrid = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance25, create_fragment25, safe_not_equal, { plugin: 0, all_paths: 3 }, add_css4);
  }
};
var TrailViewGrid_default = TrailViewGrid;

// src/components/page_views/TrailViewPath.svelte
function add_css5(target) {
  append_styles(target, "svelte-1ss66uk", '.BC-trail-view.svelte-1ss66uk{border:1px solid var(--background-modifier-border)}.BC-trail-view-item-separator.svelte-1ss66uk::before{content:">"}');
}
function get_each_context7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function get_each_context_16(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  child_ctx[8] = i;
  return child_ctx;
}
function create_if_block7(ctx) {
  let span;
  let span_aria_label_value;
  return {
    c() {
      span = element("span");
      attr(span, "class", "BC-trail-view-item-separator svelte-1ss66uk");
      attr(span, "aria-label", span_aria_label_value = /*edge*/
      (ctx[6].attr.explicit ? (
        /*edge*/
        ctx[6].attr.source
      ) : (
        /*edge*/
        ctx[6].attr.implied_kind
      )) + ": " + /*edge*/
      ctx[6].attr.dir);
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_each_block_16(ctx) {
  let div;
  let t;
  let edgelink;
  let current;
  let if_block = (
    /*j*/
    ctx[8] !== 0 && create_if_block7(ctx)
  );
  edgelink = new EdgeLink_default({
    props: {
      edge: (
        /*edge*/
        ctx[6]
      ),
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      show_node_options: (
        /*plugin*/
        ctx[0].settings.views.page.trail.show_node_options
      )
    }
  });
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      create_component(edgelink.$$.fragment);
      attr(div, "class", "BC-trail-view-item");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append(div, t);
      mount_component(edgelink, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*j*/
        ctx2[8] !== 0
      )
        if_block.p(ctx2, dirty);
      const edgelink_changes = {};
      if (dirty & /*plugin*/
      1)
        edgelink_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*plugin*/
      1)
        edgelink_changes.show_node_options = /*plugin*/
        ctx2[0].settings.views.page.trail.show_node_options;
      edgelink.$set(edgelink_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(edgelink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(edgelink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block)
        if_block.d();
      destroy_component(edgelink);
    }
  };
}
function create_each_block7(ctx) {
  let div;
  let t;
  let current;
  let each_value_1 = ensure_array_like(
    /*path*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_16(get_each_context_16(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      attr(div, "class", "BC-trail-view-path flex gap-1.5");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append(div, t);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*reversed, plugin*/
      3) {
        each_value_1 = ensure_array_like(
          /*path*/
          ctx2[3]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_16(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_16(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, t);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment26(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(
    /*reversed*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block7(get_each_context7(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "BC-trail-view flex flex-col gap-1 p-1 svelte-1ss66uk");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*reversed, plugin*/
      3) {
        each_value = ensure_array_like(
          /*reversed*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context7(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block7(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance26($$self, $$props, $$invalidate) {
  let { plugin } = $$props;
  let { all_paths: all_paths2 } = $$props;
  const reversed = all_paths2.map((path4) => [...path4].reverse());
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("all_paths" in $$props2)
      $$invalidate(2, all_paths2 = $$props2.all_paths);
  };
  return [plugin, reversed, all_paths2];
}
var TrailViewPath = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance26, create_fragment26, safe_not_equal, { plugin: 0, all_paths: 2 }, add_css5);
  }
};
var TrailViewPath_default = TrailViewPath;

// src/components/page_views/TrailView.svelte
function get_each_context8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  return child_ctx;
}
function get_each_context_17(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  return child_ctx;
}
function create_if_block_3(ctx) {
  let p;
  let t_value = (
    /*plugin*/
    ctx[0].settings.views.page.trail.no_path_message + ""
  );
  let t;
  return {
    c() {
      p = element("p");
      t = text(t_value);
      attr(p, "class", "BC-trail-view-no-path");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*plugin*/
      1 && t_value !== (t_value = /*plugin*/
      ctx2[0].settings.views.page.trail.no_path_message + ""))
        set_data(t, t_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block8(ctx) {
  let div1;
  let select0;
  let t0;
  let select1;
  let t1;
  let div0;
  let button0;
  let t2;
  let button0_disabled_value;
  let t3;
  let span;
  let t4;
  let t5;
  let button1;
  let t6;
  let button1_disabled_value;
  let t7;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let each_value_1 = ensure_array_like(["grid", "path"]);
  let each_blocks_1 = [];
  for (let i = 0; i < 2; i += 1) {
    each_blocks_1[i] = create_each_block_17(get_each_context_17(ctx, each_value_1, i));
  }
  let each_value = ensure_array_like(["all", "shortest", "longest"]);
  let each_blocks = [];
  for (let i = 0; i < 3; i += 1) {
    each_blocks[i] = create_each_block8(get_each_context8(ctx, each_value, i));
  }
  const if_block_creators = [create_if_block_1, create_if_block_2];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*plugin*/
      ctx2[0].settings.views.page.trail.format === "grid"
    )
      return 0;
    if (
      /*plugin*/
      ctx2[0].settings.views.page.trail.format === "path"
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div1 = element("div");
      select0 = element("select");
      for (let i = 0; i < 2; i += 1) {
        each_blocks_1[i].c();
      }
      t0 = space();
      select1 = element("select");
      for (let i = 0; i < 3; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      div0 = element("div");
      button0 = element("button");
      t2 = text("-");
      t3 = space();
      span = element("span");
      t4 = text(
        /*depth*/
        ctx[1]
      );
      t5 = space();
      button1 = element("button");
      t6 = text("+");
      t7 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(select0, "class", "dropdown");
      if (
        /*plugin*/
        ctx[0].settings.views.page.trail.format === void 0
      )
        add_render_callback(() => (
          /*select0_change_handler*/
          ctx[5].call(select0)
        ));
      attr(select1, "class", "dropdown");
      if (
        /*plugin*/
        ctx[0].settings.views.page.trail.selection === void 0
      )
        add_render_callback(() => (
          /*select1_change_handler*/
          ctx[7].call(select1)
        ));
      attr(button0, "class", "aspect-square text-lg");
      attr(button0, "aria-label", "Decrease max depth");
      button0.disabled = button0_disabled_value = /*depth*/
      ctx[1] <= 1;
      attr(span, "class", "font-mono");
      attr(span, "aria-label", "Max depth");
      attr(button1, "class", "aspect-square text-lg");
      attr(button1, "aria-label", "Increase max depth");
      button1.disabled = button1_disabled_value = /*depth*/
      ctx[1] >= /*MAX_DEPTH*/
      ctx[2];
      attr(div0, "class", "flex items-center gap-1");
      attr(div1, "class", "mb-1.5 flex justify-between gap-3");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, select0);
      for (let i = 0; i < 2; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(select0, null);
        }
      }
      select_option(
        select0,
        /*plugin*/
        ctx[0].settings.views.page.trail.format,
        true
      );
      append(div1, t0);
      append(div1, select1);
      for (let i = 0; i < 3; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select1, null);
        }
      }
      select_option(
        select1,
        /*plugin*/
        ctx[0].settings.views.page.trail.selection,
        true
      );
      append(div1, t1);
      append(div1, div0);
      append(div0, button0);
      append(button0, t2);
      append(div0, t3);
      append(div0, span);
      append(span, t4);
      append(div0, t5);
      append(div0, button1);
      append(button1, t6);
      insert(target, t7, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            select0,
            "change",
            /*select0_change_handler*/
            ctx[5]
          ),
          listen(
            select0,
            "change",
            /*change_handler*/
            ctx[6]
          ),
          listen(
            select1,
            "change",
            /*select1_change_handler*/
            ctx[7]
          ),
          listen(
            select1,
            "change",
            /*change_handler_1*/
            ctx[8]
          ),
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[9]
          ),
          listen(
            button1,
            "click",
            /*click_handler_1*/
            ctx[10]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*plugin*/
      1) {
        select_option(
          select0,
          /*plugin*/
          ctx2[0].settings.views.page.trail.format
        );
      }
      if (dirty & /*plugin*/
      1) {
        select_option(
          select1,
          /*plugin*/
          ctx2[0].settings.views.page.trail.selection
        );
      }
      if (!current || dirty & /*depth*/
      2 && button0_disabled_value !== (button0_disabled_value = /*depth*/
      ctx2[1] <= 1)) {
        button0.disabled = button0_disabled_value;
      }
      if (!current || dirty & /*depth*/
      2)
        set_data(
          t4,
          /*depth*/
          ctx2[1]
        );
      if (!current || dirty & /*depth, MAX_DEPTH*/
      6 && button1_disabled_value !== (button1_disabled_value = /*depth*/
      ctx2[1] >= /*MAX_DEPTH*/
      ctx2[2])) {
        button1.disabled = button1_disabled_value;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t7);
        detach(if_block_anchor);
      }
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block_17(ctx) {
  let option;
  let option_value_value;
  return {
    c() {
      option = element("option");
      option.textContent = `${/*format*/
      ctx[16]} `;
      option.__value = option_value_value = /*format*/
      ctx[16];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_each_block8(ctx) {
  let option;
  let option_value_value;
  return {
    c() {
      option = element("option");
      option.textContent = `${/*s*/
      ctx[13]} `;
      option.__value = option_value_value = /*s*/
      ctx[13];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_if_block_2(ctx) {
  let trailviewpath;
  let current;
  trailviewpath = new TrailViewPath_default({
    props: {
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      all_paths: (
        /*sliced_paths*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      create_component(trailviewpath.$$.fragment);
    },
    m(target, anchor) {
      mount_component(trailviewpath, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const trailviewpath_changes = {};
      if (dirty & /*plugin*/
      1)
        trailviewpath_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*sliced_paths*/
      8)
        trailviewpath_changes.all_paths = /*sliced_paths*/
        ctx2[3];
      trailviewpath.$set(trailviewpath_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(trailviewpath.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(trailviewpath.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(trailviewpath, detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let trailviewgrid;
  let current;
  trailviewgrid = new TrailViewGrid_default({
    props: {
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      all_paths: (
        /*sliced_paths*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      create_component(trailviewgrid.$$.fragment);
    },
    m(target, anchor) {
      mount_component(trailviewgrid, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const trailviewgrid_changes = {};
      if (dirty & /*plugin*/
      1)
        trailviewgrid_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*sliced_paths*/
      8)
        trailviewgrid_changes.all_paths = /*sliced_paths*/
        ctx2[3];
      trailviewgrid.$set(trailviewgrid_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(trailviewgrid.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(trailviewgrid.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(trailviewgrid, detaching);
    }
  };
}
function create_key_block2(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block8, create_if_block_3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*sliced_paths*/
      ctx2[3].length
    )
      return 0;
    if (
      /*plugin*/
      ctx2[0].settings.views.page.trail.no_path_message
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
function create_fragment27(ctx) {
  let div;
  let previous_key = (
    /*sliced_paths*/
    ctx[3]
  );
  let current;
  let key_block = create_key_block2(ctx);
  return {
    c() {
      div = element("div");
      key_block.c();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      key_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*sliced_paths*/
      8 && safe_not_equal(previous_key, previous_key = /*sliced_paths*/
      ctx2[3])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block2(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(div, null);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      key_block.d(detaching);
    }
  };
}
function instance27($$self, $$props, $$invalidate) {
  let selected_paths;
  let MAX_DEPTH;
  let depth;
  let sliced_paths;
  let $active_file_store;
  component_subscribe($$self, active_file_store, ($$value) => $$invalidate(11, $active_file_store = $$value));
  let { plugin } = $$props;
  const all_paths2 = $active_file_store && // Even tho we ensure the graph is built before the views are registered,
  // Existing views still try render before the graph is built.
  plugin.graph.hasNode($active_file_store.path) ? plugin.settings.hierarchies.map((_hierarchy, hierarchy_i) => Traverse.all_paths("depth_first", plugin.graph, $active_file_store.path, (edge) => has_edge_attrs(edge, { dir: "up", hierarchy_i }))).flat().sort((a, b) => b.length - a.length) : [];
  function select0_change_handler() {
    plugin.settings.views.page.trail.format = select_value(this);
    $$invalidate(0, plugin);
  }
  const change_handler = async () => await plugin.saveSettings();
  function select1_change_handler() {
    plugin.settings.views.page.trail.selection = select_value(this);
    $$invalidate(0, plugin);
  }
  const change_handler_1 = async () => await plugin.saveSettings();
  const click_handler = () => $$invalidate(1, depth = Math.max(1, depth - 1));
  const click_handler_1 = () => $$invalidate(1, depth = Math.min(MAX_DEPTH, depth + 1));
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*plugin*/
    1) {
      $:
        $$invalidate(4, selected_paths = plugin.settings.views.page.trail.selection === "all" ? all_paths2 : plugin.settings.views.page.trail.selection === "shortest" ? all_paths2.slice(-1) : plugin.settings.views.page.trail.selection === "longest" ? all_paths2.slice(0, 1) : [[]]);
    }
    if ($$self.$$.dirty & /*selected_paths*/
    16) {
      $:
        $$invalidate(2, MAX_DEPTH = Math.max(0, ...selected_paths.map((p) => p.length)));
    }
    if ($$self.$$.dirty & /*MAX_DEPTH, plugin*/
    5) {
      $:
        $$invalidate(1, depth = Math.min(MAX_DEPTH, plugin.settings.views.page.trail.default_depth));
    }
    if ($$self.$$.dirty & /*selected_paths, depth*/
    18) {
      $:
        $$invalidate(3, sliced_paths = selected_paths.map((path4) => path4.slice(0, depth)));
    }
  };
  return [
    plugin,
    depth,
    MAX_DEPTH,
    sliced_paths,
    selected_paths,
    select0_change_handler,
    change_handler,
    select1_change_handler,
    change_handler_1,
    click_handler,
    click_handler_1
  ];
}
var TrailView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance27, create_fragment27, safe_not_equal, { plugin: 0 });
  }
};
var TrailView_default = TrailView;

// src/components/page_views/index.svelte
function create_if_block9(ctx) {
  let div;
  let t;
  let current;
  let if_block0 = (
    /*enabled_views*/
    ctx[1].grid && create_if_block_22(ctx)
  );
  let if_block1 = (
    /*enabled_views*/
    ctx[1].prev_next && create_if_block_12(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      attr(div, "class", "mb-4");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t);
      if (if_block1)
        if_block1.m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*enabled_views*/
        ctx2[1].grid
      )
        if_block0.p(ctx2, dirty);
      if (
        /*enabled_views*/
        ctx2[1].prev_next
      )
        if_block1.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_if_block_22(ctx) {
  let gridview;
  let current;
  gridview = new TrailView_default({ props: { plugin: (
    /*plugin*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(gridview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(gridview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const gridview_changes = {};
      if (dirty & /*plugin*/
      1)
        gridview_changes.plugin = /*plugin*/
        ctx2[0];
      gridview.$set(gridview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(gridview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(gridview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(gridview, detaching);
    }
  };
}
function create_if_block_12(ctx) {
  let prevnextview;
  let current;
  prevnextview = new PrevNextView_default({ props: { plugin: (
    /*plugin*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(prevnextview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(prevnextview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const prevnextview_changes = {};
      if (dirty & /*plugin*/
      1)
        prevnextview_changes.plugin = /*plugin*/
        ctx2[0];
      prevnextview.$set(prevnextview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(prevnextview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(prevnextview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(prevnextview, detaching);
    }
  };
}
function create_fragment28(ctx) {
  let show_if = Object.values(
    /*enabled_views*/
    ctx[1]
  ).some(Boolean);
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block9(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (show_if)
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance28($$self, $$props, $$invalidate) {
  let { plugin } = $$props;
  const enabled_views = {
    grid: plugin.settings.views.page.trail.enabled,
    prev_next: plugin.settings.views.page.prev_next.enabled
  };
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
  };
  return [plugin, enabled_views];
}
var Page_views = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance28, create_fragment28, safe_not_equal, { plugin: 0 });
  }
};
var page_views_default = Page_views;

// src/views/page.ts
var redraw_page_views = (plugin) => {
  var _a;
  console.log("draw_page_views_on_active_note");
  const markdown_view = plugin.app.workspace.getActiveViewOfType(import_obsidian15.MarkdownView);
  if (!markdown_view) {
    return console.log("No active markdown view");
  }
  const markdown_view_mode = markdown_view.getMode();
  const page_views_el = (_a = markdown_view.containerEl.querySelector(".BC-page-views")) != null ? _a : markdown_view.containerEl.createDiv({
    cls: "BC-page-views w-full mx-auto"
  });
  const max_width = plugin.settings.views.page.all.readable_line_width ? "var(--file-line-width)" : "none";
  page_views_el.setAttribute("style", `max-width: ${max_width};`);
  page_views_el.classList.toggle(
    "BC-page-views-sticky",
    plugin.settings.views.page.all.sticky
  );
  page_views_el.empty();
  if (markdown_view_mode === "preview") {
    const view_parent = markdown_view.containerEl.querySelector(
      ".markdown-reading-view > .markdown-preview-view"
    );
    if (!view_parent)
      return console.log("No view_parent");
    view_parent.insertBefore(page_views_el, view_parent.firstChild);
  } else {
    const view_parent = markdown_view.containerEl.querySelector(".cm-scroller");
    if (!view_parent)
      return console.log("No view_parent");
    view_parent.addClass("flex-col");
    view_parent.insertBefore(page_views_el, view_parent.firstChild);
  }
  new page_views_default({
    target: page_views_el,
    props: { plugin }
  });
};

// src/settings/PageViewSettings.ts
var _add_settings_page_views = (plugin, container_el) => {
  new_setting(container_el, {
    name: "Sticky",
    desc: "Keep the page views pinned to the top of the note as you scroll",
    toggle: {
      value: plugin.settings.views.page.all.sticky,
      cb: async (value) => {
        plugin.settings.views.page.all.sticky = value;
        await plugin.saveSettings();
        redraw_page_views(plugin);
      }
    }
  });
  new_setting(container_el, {
    name: "Readable line width",
    desc: "Limit to the width of the text in the editor",
    toggle: {
      value: plugin.settings.views.page.all.readable_line_width,
      cb: async (value) => {
        plugin.settings.views.page.all.readable_line_width = value;
        await plugin.saveSettings();
        redraw_page_views(plugin);
      }
    }
  });
};

// src/settings/PrevNextSettings.ts
var import_obsidian16 = require("obsidian");
var _add_settings_prev_next_view = (plugin, containerEl) => {
  new import_obsidian16.Setting(containerEl).setName("Enable Previous/Next view").setDesc("Show the Previous/Next view at the top of the page").addToggle((toggle) => {
    toggle.setValue(plugin.settings.views.page.prev_next.enabled).onChange(async (value) => {
      plugin.settings.views.page.prev_next.enabled = value;
      await Promise.all([plugin.saveSettings()]);
      plugin.refresh({
        rebuild_graph: false,
        active_file_store: false
      });
    });
  });
  _add_settings_show_node_options(plugin, containerEl, {
    get: () => plugin.settings.views.page.prev_next.show_node_options,
    set: (value) => plugin.settings.views.page.prev_next.show_node_options = value
  });
};

// src/settings/RebuildGraphSettings.ts
var _add_settings_rebuild_graph = (plugin, containerEl) => {
  new_setting(containerEl, {
    name: "Notify on refresh",
    desc: "Show a notification when the graph is rebuilt",
    toggle: {
      value: plugin.settings.commands.rebuild_graph.notify,
      cb: async (value) => {
        plugin.settings.commands.rebuild_graph.notify = value;
        await Promise.all([plugin.saveSettings(), plugin.refresh({})]);
      }
    }
  });
  new_setting(containerEl, {
    name: "Triggers",
    desc: "When to rebuild the graph",
    checklist: {
      options: {
        note_save: plugin.settings.commands.rebuild_graph.trigger.note_save,
        layout_change: plugin.settings.commands.rebuild_graph.trigger.layout_change
      },
      cb: async (value) => {
        plugin.settings.commands.rebuild_graph.trigger = value;
        await Promise.all([plugin.saveSettings(), plugin.refresh({})]);
      }
    }
  });
};

// src/settings/RegexNoteSettings.ts
var _add_settings_regex_note = (plugin, containerEl) => {
  new_setting(containerEl, {
    name: "Default Field",
    desc: "Field to use if the BC-regex-note-field is not specified",
    select: {
      value: plugin.settings.explicit_edge_sources.regex_note.default_field,
      options: get_all_hierarchy_fields(plugin.settings.hierarchies),
      cb: async (value) => {
        plugin.settings.explicit_edge_sources.regex_note.default_field = value;
        await Promise.all([plugin.refresh(), plugin.saveSettings()]);
      }
    }
  });
};

// src/settings/TagNoteSettings.ts
var _add_settings_tag_note = (plugin, containerEl) => {
  new_setting(containerEl, {
    name: "Default Field",
    desc: "Field to use if the BC-tag-note-field is not specified",
    select: {
      value: plugin.settings.explicit_edge_sources.tag_note.default_field,
      options: get_all_hierarchy_fields(plugin.settings.hierarchies),
      cb: async (value) => {
        plugin.settings.explicit_edge_sources.tag_note.default_field = value;
        await Promise.all([plugin.refresh(), plugin.saveSettings()]);
      }
    }
  });
};

// src/settings/TreeViewSettings.ts
var _add_settings_tree_view = (plugin, containerEl) => {
  new_setting(containerEl, {
    name: "Default Direction",
    desc: "The default direction to use in the tree traversal",
    select: {
      value: plugin.settings.views.side.tree.default_dir,
      options: DIRECTIONS,
      cb: async (value) => {
        plugin.settings.views.side.tree.default_dir = value;
        await Promise.all([
          plugin.saveSettings(),
          plugin.refresh({ rebuild_graph: false })
        ]);
      }
    }
  });
  _add_settings_show_node_options(plugin, containerEl, {
    get: () => plugin.settings.views.side.tree.show_node_options,
    set: (value) => plugin.settings.views.side.tree.show_node_options = value
  });
};

// src/settings/SettingsTab.ts
var make_details_el = (parent, o) => {
  let details;
  let summary;
  let children2;
  details = parent.createEl("details", {
    cls: "tree-item",
    ...o == null ? void 0 : o.d
  });
  summary = details.createEl("summary", {
    cls: "text-xl p-1 tree-item-self is-clickable",
    ...o == null ? void 0 : o.s
  });
  children2 = details.createEl("div", { cls: "tree-item-children pl-4" });
  return {
    details,
    summary,
    children: children2
  };
};
var BreadcrumbsSettingTab = class extends import_obsidian17.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl, plugin } = this;
    containerEl.empty();
    containerEl.addClass("BC-settings-tab");
    _add_settings_hierarchies(
      plugin,
      make_details_el(containerEl, { s: { text: "> Hierarchies" } }).children
    );
    containerEl.createEl("hr");
    containerEl.createEl("h3", { text: "Custom Implied Relations" });
    new TransitiveImpliedRelations_default({
      props: { plugin },
      target: make_details_el(containerEl, {
        s: { text: "> Transitive" }
      }).children
    });
    containerEl.createEl("hr");
    containerEl.createEl("h3", { text: "Edge Sources" });
    _add_settings_tag_note(
      plugin,
      make_details_el(containerEl, { s: { text: "> Tag Notes" } }).children
    );
    _add_settings_regex_note(
      plugin,
      make_details_el(containerEl, { s: { text: "> Regex Notes" } }).children
    );
    _add_settings_dendron_note(
      plugin,
      make_details_el(containerEl, { s: { text: "> Dendron Notes" } }).children
    );
    _add_settings_date_note(
      plugin,
      make_details_el(containerEl, { s: { text: "> Date Notes" } }).children
    );
    containerEl.createEl("hr");
    containerEl.createEl("h3", { text: "Views" });
    _add_settings_matrix(
      plugin,
      make_details_el(containerEl, { s: { text: "> Matrix" } }).children
    );
    const page_details = make_details_el(containerEl, {
      s: { text: "> Page" }
    }).children;
    page_details.createEl("h5", { text: "General" });
    _add_settings_page_views(plugin, page_details);
    page_details.createEl("h5", { text: "Trail" });
    _add_settings_trail_view(plugin, page_details);
    page_details.createEl("h5", { text: "Previous/Next" });
    _add_settings_prev_next_view(plugin, page_details);
    _add_settings_tree_view(
      plugin,
      make_details_el(containerEl, { s: { text: "> Tree" } }).children
    );
    containerEl.createEl("hr");
    containerEl.createEl("h3", { text: "Commands" });
    _add_settings_rebuild_graph(
      plugin,
      make_details_el(containerEl, { s: { text: "> Rebuild Graph" } }).children
    );
    _add_settings_list_index(
      plugin,
      make_details_el(containerEl, { s: { text: "> List Index" } }).children
    );
    _add_settings_freeze_implied_edges(
      plugin,
      make_details_el(containerEl, {
        s: { text: "> Freeze Implied Edges" }
      }).children
    );
    containerEl.createEl("hr");
    _add_settings_codeblocks(
      plugin,
      make_details_el(containerEl, { s: { text: "> Codeblocks" } }).children
    );
  }
};

// src/views/matrix.ts
var import_obsidian19 = require("obsidian");

// src/components/RebuildGraphButton.svelte
function create_fragment29(ctx) {
  let button;
  let rotateccw;
  let current;
  let mounted;
  let dispose;
  rotateccw = new rotate_ccw_default({ props: { size: ICON_SIZE } });
  return {
    c() {
      button = element("button");
      create_component(rotateccw.$$.fragment);
      attr(
        button,
        "class",
        /*cls*/
        ctx[1]
      );
      attr(button, "aria-label", "Rebuild Graph");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(rotateccw, button, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*cls*/
      2) {
        attr(
          button,
          "class",
          /*cls*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(rotateccw.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rotateccw.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(rotateccw);
      mounted = false;
      dispose();
    }
  };
}
function instance29($$self, $$props, $$invalidate) {
  let { plugin } = $$props;
  let { cls = "" } = $$props;
  const click_handler = () => plugin.refresh();
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("cls" in $$props2)
      $$invalidate(1, cls = $$props2.cls);
  };
  return [plugin, cls, click_handler];
}
var RebuildGraphButton = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance29, create_fragment29, safe_not_equal, { plugin: 0, cls: 1 });
  }
};
var RebuildGraphButton_default = RebuildGraphButton;

// src/menus/ShowAttributesMenu.ts
var import_obsidian18 = require("obsidian");
var ShowAttributesSelectorMenu = ({
  cb,
  value,
  exclude_attributes
}) => {
  const menu = new import_obsidian18.Menu();
  const add_item = (attr2) => {
    const included = value.includes(attr2);
    menu.addItem(
      (item) => item.setTitle(attr2).setChecked(included).onClick(() => {
        if (included) {
          cb(value.filter((v) => v !== attr2));
        } else {
          cb([...value, attr2]);
        }
      })
    );
  };
  ["hierarchy_i", "dir", "field", "explicit"].filter((attr2) => !(exclude_attributes == null ? void 0 : exclude_attributes.includes(attr2))).forEach(add_item);
  menu.addSeparator();
  ["source"].filter((attr2) => !(exclude_attributes == null ? void 0 : exclude_attributes.includes(attr2))).forEach(add_item);
  menu.addSeparator();
  ["implied_kind", "round"].filter((attr2) => !(exclude_attributes == null ? void 0 : exclude_attributes.includes(attr2))).forEach(add_item);
  return menu;
};

// src/components/selector/ShowAttributesSelectorMenu.svelte
function create_fragment30(ctx) {
  let button;
  let filejson;
  let current;
  let mounted;
  let dispose;
  filejson = new file_json_default({ props: { size: ICON_SIZE } });
  return {
    c() {
      button = element("button");
      create_component(filejson.$$.fragment);
      attr(
        button,
        "class",
        /*cls*/
        ctx[2]
      );
      attr(button, "aria-label", "Change which edge attributes show");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      mount_component(filejson, button, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[3]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*cls*/
      4) {
        attr(
          button,
          "class",
          /*cls*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(filejson.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filejson.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(filejson);
      mounted = false;
      dispose();
    }
  };
}
function instance30($$self, $$props, $$invalidate) {
  let { show_attributes } = $$props;
  let { exclude_attributes = [] } = $$props;
  let { cls = "" } = $$props;
  if (exclude_attributes === null || exclude_attributes === void 0 ? void 0 : exclude_attributes.length) {
    show_attributes = show_attributes.filter((v) => !(exclude_attributes === null || exclude_attributes === void 0 ? void 0 : exclude_attributes.includes(v)));
  }
  const click_handler = (e) => {
    ShowAttributesSelectorMenu({
      exclude_attributes,
      value: show_attributes,
      cb: (value) => $$invalidate(0, show_attributes = value)
    }).showAtMouseEvent(e);
  };
  $$self.$$set = ($$props2) => {
    if ("show_attributes" in $$props2)
      $$invalidate(0, show_attributes = $$props2.show_attributes);
    if ("exclude_attributes" in $$props2)
      $$invalidate(1, exclude_attributes = $$props2.exclude_attributes);
    if ("cls" in $$props2)
      $$invalidate(2, cls = $$props2.cls);
  };
  return [show_attributes, exclude_attributes, cls, click_handler];
}
var ShowAttributesSelectorMenu_1 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance30, create_fragment30, safe_not_equal, {
      show_attributes: 0,
      exclude_attributes: 1,
      cls: 2
    });
  }
};
var ShowAttributesSelectorMenu_default = ShowAttributesSelectorMenu_1;

// src/utils/objects.ts
function deep_merge_objects(obj1, obj2) {
  const result = { ...obj1 };
  for (const key in obj2) {
    const val1 = obj1[key];
    const val2 = obj2[key];
    if (typeof val1 === "object" && typeof val2 === "object" && !Array.isArray(val1) && !Array.isArray(val2)) {
      result[key] = deep_merge_objects(val1, val2);
    } else if (val1 === void 0) {
      result[key] = val2;
    }
  }
  return result;
}
var untyped_pick = (obj, keys) => Object.fromEntries(
  Object.entries(obj).filter(([key]) => keys.includes(key))
);

// src/components/side_views/MatrixHierarchy.svelte
function get_each_context9(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  const constants_0 = (
    /*hierarchy_out_edges*/
    child_ctx[2].filter(function func(...args) {
      return (
        /*func*/
        ctx[5](
          /*dir*/
          child_ctx[6],
          ...args
        )
      );
    })
  );
  child_ctx[7] = constants_0;
  return child_ctx;
}
function get_each_context_18(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
function create_if_block10(ctx) {
  let div1;
  let span;
  let t0_value = (
    /*hierarchy*/
    ctx[1].dirs[
      /*dir*/
      ctx[6]
    ].join(", ") + ""
  );
  let t0;
  let t1;
  let div0;
  let previous_key = (
    /*sort*/
    ctx[4]
  );
  let t2;
  let current;
  let key_block = create_key_block3(ctx);
  return {
    c() {
      div1 = element("div");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      div0 = element("div");
      key_block.c();
      t2 = space();
      attr(span, "class", "text-lg font-semibold");
      attr(div0, "class", "flex flex-col");
      attr(div1, "class", "BC-matrix-view-dir flex flex-col gap-1");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, span);
      append(span, t0);
      append(div1, t1);
      append(div1, div0);
      key_block.m(div0, null);
      append(div1, t2);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*hierarchy*/
      2) && t0_value !== (t0_value = /*hierarchy*/
      ctx2[1].dirs[
        /*dir*/
        ctx2[6]
      ].join(", ") + ""))
        set_data(t0, t0_value);
      if (dirty & /*sort*/
      16 && safe_not_equal(previous_key, previous_key = /*sort*/
      ctx2[4])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block3(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(div0, null);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      key_block.d(detaching);
    }
  };
}
function create_each_block_18(ctx) {
  let div2;
  let div1;
  let edgelink;
  let t0;
  let div0;
  let span;
  let t1;
  let t2_value = (
    /*edge*/
    ctx[10].attr.explicit ? "x" : "i"
  );
  let t2;
  let t3;
  let span_aria_label_value;
  let t4;
  let current;
  edgelink = new EdgeLink_default({
    props: {
      edge: (
        /*edge*/
        ctx[10]
      ),
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      cls: "grow tree-item-inner",
      show_node_options: (
        /*plugin*/
        ctx[0].settings.views.side.matrix.show_node_options
      )
    }
  });
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      create_component(edgelink.$$.fragment);
      t0 = space();
      div0 = element("div");
      span = element("span");
      t1 = text("(");
      t2 = text(t2_value);
      t3 = text(")");
      t4 = space();
      attr(span, "class", "tree-item-flair font-mono");
      attr(span, "aria-label", span_aria_label_value = url_search_params(untyped_pick(
        /*edge*/
        ctx[10].attr,
        /*show_attributes*/
        ctx[3]
      )));
      attr(div0, "class", "tree-item-flair-outer");
      attr(div1, "class", "tree-item-self is-clickable");
      attr(div2, "class", "tree-item");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      mount_component(edgelink, div1, null);
      append(div1, t0);
      append(div1, div0);
      append(div0, span);
      append(span, t1);
      append(span, t2);
      append(span, t3);
      append(div2, t4);
      current = true;
    },
    p(ctx2, dirty) {
      const edgelink_changes = {};
      if (dirty & /*hierarchy_out_edges, sort*/
      20)
        edgelink_changes.edge = /*edge*/
        ctx2[10];
      if (dirty & /*plugin*/
      1)
        edgelink_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*plugin*/
      1)
        edgelink_changes.show_node_options = /*plugin*/
        ctx2[0].settings.views.side.matrix.show_node_options;
      edgelink.$set(edgelink_changes);
      if ((!current || dirty & /*hierarchy_out_edges, sort*/
      20) && t2_value !== (t2_value = /*edge*/
      ctx2[10].attr.explicit ? "x" : "i"))
        set_data(t2, t2_value);
      if (!current || dirty & /*hierarchy_out_edges, sort, show_attributes*/
      28 && span_aria_label_value !== (span_aria_label_value = url_search_params(untyped_pick(
        /*edge*/
        ctx2[10].attr,
        /*show_attributes*/
        ctx2[3]
      )))) {
        attr(span, "aria-label", span_aria_label_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(edgelink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(edgelink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(edgelink);
    }
  };
}
function create_key_block3(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like(
    /*out_edges*/
    ctx[7].sort(
      /*sort*/
      ctx[4]
    )
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_18(get_each_context_18(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*hierarchy_out_edges, sort, show_attributes, plugin*/
      29) {
        each_value_1 = ensure_array_like(
          /*out_edges*/
          ctx2[7].sort(
            /*sort*/
            ctx2[4]
          )
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_18(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_18(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block9(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*out_edges*/
    ctx[7].length && create_if_block10(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*out_edges*/
        ctx2[7].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*hierarchy_out_edges*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block10(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment31(ctx) {
  let div;
  let current;
  let each_value = ensure_array_like(DIRECTIONS);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block9(get_each_context9(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "BC-matrix-view-hierarchy flex flex-col gap-4");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*sort, hierarchy_out_edges, show_attributes, plugin, hierarchy*/
      31) {
        each_value = ensure_array_like(DIRECTIONS);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context9(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block9(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance31($$self, $$props, $$invalidate) {
  let { plugin } = $$props;
  let { hierarchy } = $$props;
  let { hierarchy_out_edges } = $$props;
  let { show_attributes } = $$props;
  let { sort } = $$props;
  const func = (dir, e) => has_edge_attrs(e, { dir });
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("hierarchy" in $$props2)
      $$invalidate(1, hierarchy = $$props2.hierarchy);
    if ("hierarchy_out_edges" in $$props2)
      $$invalidate(2, hierarchy_out_edges = $$props2.hierarchy_out_edges);
    if ("show_attributes" in $$props2)
      $$invalidate(3, show_attributes = $$props2.show_attributes);
    if ("sort" in $$props2)
      $$invalidate(4, sort = $$props2.sort);
  };
  return [plugin, hierarchy, hierarchy_out_edges, show_attributes, sort, func];
}
var MatrixHierarchy = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance31, create_fragment31, safe_not_equal, {
      plugin: 0,
      hierarchy: 1,
      hierarchy_out_edges: 2,
      show_attributes: 3,
      sort: 4
    });
  }
};
var MatrixHierarchy_default = MatrixHierarchy;

// src/components/side_views/Matrix.svelte
function get_each_context10(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  child_ctx[12] = i;
  const constants_0 = (
    /*all_out_edges*/
    child_ctx[4].filter(function func(...args) {
      return (
        /*func*/
        ctx[8](
          /*hierarchy_i*/
          child_ctx[12],
          ...args
        )
      );
    })
  );
  child_ctx[10] = constants_0;
  return child_ctx;
}
function create_else_block4(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "No outgoings edges";
      attr(p, "class", "text-muted");
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block11(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*plugin*/
    ctx[0].settings.hierarchies
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block10(get_each_context10(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*plugin, all_out_edges, show_attributes, sort*/
      29) {
        each_value = ensure_array_like(
          /*plugin*/
          ctx2[0].settings.hierarchies
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context10(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block10(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_13(ctx) {
  let matrixhierarchy;
  let t;
  let if_block_anchor;
  let current;
  matrixhierarchy = new MatrixHierarchy_default({
    props: {
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      hierarchy: (
        /*hierarchy*/
        ctx[9]
      ),
      hierarchy_out_edges: (
        /*hierarchy_out_edges*/
        ctx[10]
      ),
      show_attributes: (
        /*show_attributes*/
        ctx[2]
      ),
      sort: (
        /*sort*/
        ctx[3]
      )
    }
  });
  let if_block = (
    /*plugin*/
    ctx[0].settings.hierarchies.length !== /*hierarchy_i*/
    ctx[12] + 1 && create_if_block_23(ctx)
  );
  return {
    c() {
      create_component(matrixhierarchy.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(matrixhierarchy, target, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const matrixhierarchy_changes = {};
      if (dirty & /*plugin*/
      1)
        matrixhierarchy_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*plugin*/
      1)
        matrixhierarchy_changes.hierarchy = /*hierarchy*/
        ctx2[9];
      if (dirty & /*all_out_edges*/
      16)
        matrixhierarchy_changes.hierarchy_out_edges = /*hierarchy_out_edges*/
        ctx2[10];
      if (dirty & /*show_attributes*/
      4)
        matrixhierarchy_changes.show_attributes = /*show_attributes*/
        ctx2[2];
      if (dirty & /*sort*/
      8)
        matrixhierarchy_changes.sort = /*sort*/
        ctx2[3];
      matrixhierarchy.$set(matrixhierarchy_changes);
      if (
        /*plugin*/
        ctx2[0].settings.hierarchies.length !== /*hierarchy_i*/
        ctx2[12] + 1
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block_23(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(matrixhierarchy.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(matrixhierarchy.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
        detach(if_block_anchor);
      }
      destroy_component(matrixhierarchy, detaching);
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_23(ctx) {
  let hr;
  return {
    c() {
      hr = element("hr");
      attr(hr, "class", "my-3");
    },
    m(target, anchor) {
      insert(target, hr, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(hr);
      }
    }
  };
}
function create_each_block10(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*hierarchy_out_edges*/
    ctx[10].length && create_if_block_13(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*hierarchy_out_edges*/
        ctx2[10].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*all_out_edges*/
          16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_13(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_key_block4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block11, create_else_block4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*all_out_edges*/
      ctx2[4].length
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_fragment32(ctx) {
  let div2;
  let div1;
  let div0;
  let rebuildgraphbutton;
  let t0;
  let edgesortidselector;
  let updating_edge_sort_id;
  let t1;
  let showattributesselectormenu;
  let updating_show_attributes;
  let t2;
  let previous_key = (
    /*all_out_edges*/
    ctx[4]
  );
  let current;
  rebuildgraphbutton = new RebuildGraphButton_default({
    props: {
      cls: "clickable-icon nav-action-button",
      plugin: (
        /*plugin*/
        ctx[0]
      )
    }
  });
  function edgesortidselector_edge_sort_id_binding(value) {
    ctx[6](value);
  }
  let edgesortidselector_props = {
    cls: "clickable-icon nav-action-button",
    exclude_fields: ["field", "neighbour-dir:", "neighbour-field:"]
  };
  if (
    /*edge_sort_id*/
    ctx[1] !== void 0
  ) {
    edgesortidselector_props.edge_sort_id = /*edge_sort_id*/
    ctx[1];
  }
  edgesortidselector = new EdgeSortIdSelector_default({ props: edgesortidselector_props });
  binding_callbacks.push(() => bind(edgesortidselector, "edge_sort_id", edgesortidselector_edge_sort_id_binding));
  function showattributesselectormenu_show_attributes_binding(value) {
    ctx[7](value);
  }
  let showattributesselectormenu_props = {
    cls: "clickable-icon nav-action-button",
    exclude_attributes: ["hierarchy_i", "dir", "field", "explicit"]
  };
  if (
    /*show_attributes*/
    ctx[2] !== void 0
  ) {
    showattributesselectormenu_props.show_attributes = /*show_attributes*/
    ctx[2];
  }
  showattributesselectormenu = new ShowAttributesSelectorMenu_default({ props: showattributesselectormenu_props });
  binding_callbacks.push(() => bind(showattributesselectormenu, "show_attributes", showattributesselectormenu_show_attributes_binding));
  let key_block = create_key_block4(ctx);
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      create_component(rebuildgraphbutton.$$.fragment);
      t0 = space();
      create_component(edgesortidselector.$$.fragment);
      t1 = space();
      create_component(showattributesselectormenu.$$.fragment);
      t2 = space();
      key_block.c();
      attr(div0, "class", "nav-buttons-container");
      attr(div1, "class", "nav-header");
      attr(div2, "class", "markdown-rendered BC-matrix-view -mt-2");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      mount_component(rebuildgraphbutton, div0, null);
      append(div0, t0);
      mount_component(edgesortidselector, div0, null);
      append(div0, t1);
      mount_component(showattributesselectormenu, div0, null);
      append(div2, t2);
      key_block.m(div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const rebuildgraphbutton_changes = {};
      if (dirty & /*plugin*/
      1)
        rebuildgraphbutton_changes.plugin = /*plugin*/
        ctx2[0];
      rebuildgraphbutton.$set(rebuildgraphbutton_changes);
      const edgesortidselector_changes = {};
      if (!updating_edge_sort_id && dirty & /*edge_sort_id*/
      2) {
        updating_edge_sort_id = true;
        edgesortidselector_changes.edge_sort_id = /*edge_sort_id*/
        ctx2[1];
        add_flush_callback(() => updating_edge_sort_id = false);
      }
      edgesortidselector.$set(edgesortidselector_changes);
      const showattributesselectormenu_changes = {};
      if (!updating_show_attributes && dirty & /*show_attributes*/
      4) {
        updating_show_attributes = true;
        showattributesselectormenu_changes.show_attributes = /*show_attributes*/
        ctx2[2];
        add_flush_callback(() => updating_show_attributes = false);
      }
      showattributesselectormenu.$set(showattributesselectormenu_changes);
      if (dirty & /*all_out_edges*/
      16 && safe_not_equal(previous_key, previous_key = /*all_out_edges*/
      ctx2[4])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block4(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(div2, null);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(rebuildgraphbutton.$$.fragment, local);
      transition_in(edgesortidselector.$$.fragment, local);
      transition_in(showattributesselectormenu.$$.fragment, local);
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(rebuildgraphbutton.$$.fragment, local);
      transition_out(edgesortidselector.$$.fragment, local);
      transition_out(showattributesselectormenu.$$.fragment, local);
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(rebuildgraphbutton);
      destroy_component(edgesortidselector);
      destroy_component(showattributesselectormenu);
      key_block.d(detaching);
    }
  };
}
function instance32($$self, $$props, $$invalidate) {
  let all_out_edges;
  let sort;
  let $active_file_store;
  component_subscribe($$self, active_file_store, ($$value) => $$invalidate(5, $active_file_store = $$value));
  let { plugin } = $$props;
  let edge_sort_id = { field: "basename", order: 1 };
  let show_attributes = EDGE_ATTRIBUTES.slice();
  function edgesortidselector_edge_sort_id_binding(value) {
    edge_sort_id = value;
    $$invalidate(1, edge_sort_id);
  }
  function showattributesselectormenu_show_attributes_binding(value) {
    show_attributes = value;
    $$invalidate(2, show_attributes);
  }
  const func = (hierarchy_i, e) => has_edge_attrs(e, { hierarchy_i });
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$active_file_store, plugin*/
    33) {
      $:
        $$invalidate(4, all_out_edges = $active_file_store && // Even tho we ensure the graph is built before the views are registered,
        // Existing views still try render before the graph is built.
        plugin.graph.hasNode($active_file_store.path) ? plugin.graph.get_out_edges($active_file_store.path) : []);
    }
    if ($$self.$$.dirty & /*edge_sort_id, plugin*/
    3) {
      $:
        $$invalidate(3, sort = get_edge_sorter(edge_sort_id, plugin.graph));
    }
  };
  return [
    plugin,
    edge_sort_id,
    show_attributes,
    sort,
    all_out_edges,
    $active_file_store,
    edgesortidselector_edge_sort_id_binding,
    showattributesselectormenu_show_attributes_binding,
    func
  ];
}
var Matrix = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance32, create_fragment32, safe_not_equal, { plugin: 0 });
  }
};
var Matrix_default = Matrix;

// src/views/matrix.ts
var MatrixView = class extends import_obsidian19.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.icon = "blinds";
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_IDS.matrix;
  }
  getDisplayText() {
    return "Matrix view";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    this.component = new Matrix_default({
      target: this.contentEl,
      props: { plugin: this.plugin }
    });
  }
  async onClose() {
    var _a;
    (_a = this.component) == null ? void 0 : _a.$destroy();
  }
};

// src/api/index.ts
var BCAPI = class {
  constructor(plugin) {
    this.DIRECTIONS = DIRECTIONS;
    this.ARROW_DIRECTIONS = ARROW_DIRECTIONS;
    // TODO
    this.buildObsGraph = () => {
      throw new Error("Not implemented");
    };
    this.refresh = () => this.plugin.refresh();
    /** @deprecated Use refresh */
    this.refreshIndex = this.refresh;
    /** @deprecated Filter edges of plugin.graph instead */
    this.getSubInDirs = (dirs, g = this.plugin.graph) => {
    };
    /** @deprecated Filter edges of plugin.graph instead */
    this.getSubForFields = (fields, g = this.plugin.graph) => {
    };
    this.all_paths_depth_first = (start_node = ((_a) => (_a = get_store_value(active_file_store)) == null ? void 0 : _a.path)(), graph = this.plugin.graph, attrs) => {
      if (!start_node)
        throw new Error("No active file");
      return Traverse.all_paths(
        "depth_first",
        graph,
        start_node,
        (e) => has_edge_attrs(e, attrs)
      );
    };
    /** @deprecated Use all_paths_depth_first instead */
    this.dfsAllPaths = this.all_paths_depth_first;
    this.nest_all_paths = Traverse.nest_all_paths;
    this.flatten_all_paths = Traverse.flatten_all_paths;
    this.create_list_index = (start_node = ((_b) => (_b = get_store_value(active_file_store)) == null ? void 0 : _b.path)(), options) => {
      if (!start_node)
        throw new Error("No active file");
      return ListIndex.build(
        this.plugin.graph,
        start_node,
        Object.assign({ ...ListIndex.DEFAULT_OPTIONS }, options)
      );
    };
    // BREAKING
    /** @deprecated Use flatten_all_paths and flat_paths_to_index_list instead. Or, create_list_index */
    this.createIndex = () => {
    };
    this.get_neighbours = (source = ((_c) => (_c = get_store_value(active_file_store)) == null ? void 0 : _c.path)()) => source && this.plugin.graph.hasNode(source) ? this.plugin.graph.get_out_edges(source) : [];
    /** @deprecated Use get_neighbours instead */
    this.getMatrixNeighbours = this.get_neighbours;
    this.get_opposite_direction = get_opposite_direction;
    /** @deprecated Use get_opposite_direction */
    this.getOppDir = this.get_opposite_direction;
    this.get_opposite_fields = (field) => {
      const field_hierarchy = get_field_hierarchy(
        this.plugin.settings.hierarchies,
        field
      );
      if (!field_hierarchy) {
        console.error(
          "BCAPI.getOppFields: field_hierarchy not found",
          field
        );
        return [];
      }
      return this.plugin.settings.hierarchies[field_hierarchy.hierarchy_i].dirs[get_opposite_direction(field_hierarchy.dir)];
    };
    /** @deprecated Use get_opposite_fields */
    this.getOppFields = this.get_opposite_fields;
    this.get_field_hierarchy = (field) => get_field_hierarchy(this.plugin.settings.hierarchies, field);
    /** @deprecated Use get_field_hierarchy */
    this.getFieldInfo = this.get_field_hierarchy;
    /** @deprecated Filter plugin.settings.hierarchies instead */
    this.getFields = (dir) => {
    };
    this.plugin = plugin;
  }
  /** @deprecated Map plugin.settings.hierachies instead */
  iterateHiers(cb) {
  }
};

// src/codeblocks/MDRC.ts
var import_obsidian20 = require("obsidian");

// src/components/FlatEdgeList.svelte
function get_each_context11(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function create_if_block12(ctx) {
  let div;
  let span;
  let t_value = url_search_params(untyped_pick(
    /*nested*/
    ctx[6].edge.attr,
    /*show_attributes*/
    ctx[3]
  )).toString().replace(/&/g, " ") + "";
  let t;
  return {
    c() {
      div = element("div");
      span = element("span");
      t = text(t_value);
      attr(span, "class", "BC-field tree-item-flair");
      attr(div, "class", "tree-item-flair-outer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*flat_edges, sort, show_attributes*/
      28 && t_value !== (t_value = url_search_params(untyped_pick(
        /*nested*/
        ctx2[6].edge.attr,
        /*show_attributes*/
        ctx2[3]
      )).toString().replace(/&/g, " ") + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_each_block11(ctx) {
  var _a;
  let li;
  let edgelink;
  let t0;
  let t1;
  let current;
  edgelink = new EdgeLink_default({
    props: {
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      edge: (
        /*nested*/
        ctx[6].edge
      ),
      show_node_options: (
        /*show_node_options*/
        ctx[1]
      )
    }
  });
  let if_block = (
    /*show_attributes*/
    ((_a = ctx[3]) == null ? void 0 : _a.length) && create_if_block12(ctx)
  );
  return {
    c() {
      li = element("li");
      create_component(edgelink.$$.fragment);
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      attr(li, "class", "flex justify-between");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      mount_component(edgelink, li, null);
      append(li, t0);
      if (if_block)
        if_block.m(li, null);
      append(li, t1);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const edgelink_changes = {};
      if (dirty & /*plugin*/
      1)
        edgelink_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*flat_edges, sort*/
      20)
        edgelink_changes.edge = /*nested*/
        ctx2[6].edge;
      if (dirty & /*show_node_options*/
      2)
        edgelink_changes.show_node_options = /*show_node_options*/
        ctx2[1];
      edgelink.$set(edgelink_changes);
      if (
        /*show_attributes*/
        (_a2 = ctx2[3]) == null ? void 0 : _a2.length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block12(ctx2);
          if_block.c();
          if_block.m(li, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(edgelink.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(edgelink.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      destroy_component(edgelink);
      if (if_block)
        if_block.d();
    }
  };
}
function create_fragment33(ctx) {
  let ul;
  let current;
  let each_value = ensure_array_like(
    /*flat_edges*/
    ctx[2].sort(
      /*func*/
      ctx[5]
    )
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block11(get_each_context11(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*flat_edges, sort, show_attributes, plugin, show_node_options*/
      31) {
        each_value = ensure_array_like(
          /*flat_edges*/
          ctx2[2].sort(
            /*func*/
            ctx2[5]
          )
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context11(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block11(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(ul, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(ul);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance33($$self, $$props, $$invalidate) {
  let { plugin } = $$props;
  let { show_node_options } = $$props;
  let { flat_edges = [] } = $$props;
  let { show_attributes } = $$props;
  let { sort } = $$props;
  const func = (a, b) => sort(a.edge, b.edge);
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("show_node_options" in $$props2)
      $$invalidate(1, show_node_options = $$props2.show_node_options);
    if ("flat_edges" in $$props2)
      $$invalidate(2, flat_edges = $$props2.flat_edges);
    if ("show_attributes" in $$props2)
      $$invalidate(3, show_attributes = $$props2.show_attributes);
    if ("sort" in $$props2)
      $$invalidate(4, sort = $$props2.sort);
  };
  return [plugin, show_node_options, flat_edges, show_attributes, sort, func];
}
var FlatEdgeList = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance33, create_fragment33, safe_not_equal, {
      plugin: 0,
      show_node_options: 1,
      flat_edges: 2,
      show_attributes: 3,
      sort: 4
    });
  }
};
var FlatEdgeList_default = FlatEdgeList;

// src/components/NestedEdgeList.svelte
function get_each_context12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  child_ctx[9] = list;
  child_ctx[10] = i;
  return child_ctx;
}
function create_if_block_24(ctx) {
  let div;
  let chevronopener;
  let current;
  chevronopener = new ChevronOpener_default({
    props: { open: (
      /*opens*/
      ctx[5][
        /*i*/
        ctx[10]
      ]
    ) }
  });
  return {
    c() {
      div = element("div");
      create_component(chevronopener.$$.fragment);
      attr(div, "class", "tree-item-icon collapse-icon");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(chevronopener, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const chevronopener_changes = {};
      if (dirty & /*opens*/
      32)
        chevronopener_changes.open = /*opens*/
        ctx2[5][
          /*i*/
          ctx2[10]
        ];
      chevronopener.$set(chevronopener_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(chevronopener.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(chevronopener.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(chevronopener);
    }
  };
}
function create_if_block_14(ctx) {
  let div;
  let span;
  let t_value = url_search_params(untyped_pick(
    /*nested*/
    ctx[8].edge.attr,
    /*show_attributes*/
    ctx[3]
  )) + "";
  let t;
  return {
    c() {
      div = element("div");
      span = element("span");
      t = text(t_value);
      attr(span, "class", "BC-field tree-item-flair");
      attr(div, "class", "tree-item-flair-outer");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*nested_edges, sort, show_attributes*/
      26 && t_value !== (t_value = url_search_params(untyped_pick(
        /*nested*/
        ctx2[8].edge.attr,
        /*show_attributes*/
        ctx2[3]
      )) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block13(ctx) {
  let div;
  let nestededgelist;
  let current;
  nestededgelist = new NestedEdgeList({
    props: {
      sort: (
        /*sort*/
        ctx[4]
      ),
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      show_attributes: (
        /*show_attributes*/
        ctx[3]
      ),
      nested_edges: (
        /*nested*/
        ctx[8].children
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(nestededgelist.$$.fragment);
      attr(div, "class", "tree-item-children");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(nestededgelist, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const nestededgelist_changes = {};
      if (dirty & /*sort*/
      16)
        nestededgelist_changes.sort = /*sort*/
        ctx2[4];
      if (dirty & /*plugin*/
      1)
        nestededgelist_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*show_attributes*/
      8)
        nestededgelist_changes.show_attributes = /*show_attributes*/
        ctx2[3];
      if (dirty & /*nested_edges, sort*/
      18)
        nestededgelist_changes.nested_edges = /*nested*/
        ctx2[8].children;
      nestededgelist.$set(nestededgelist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(nestededgelist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nestededgelist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(nestededgelist);
    }
  };
}
function create_each_block12(ctx) {
  var _a;
  let details;
  let summary;
  let t0;
  let edgelink;
  let t1;
  let t2;
  let t3;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*nested*/
    ctx[8].children.length && create_if_block_24(ctx)
  );
  edgelink = new EdgeLink_default({
    props: {
      cls: "tree-item-inner",
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      edge: (
        /*nested*/
        ctx[8].edge
      ),
      show_node_options: (
        /*show_node_options*/
        ctx[2]
      )
    }
  });
  let if_block1 = (
    /*show_attributes*/
    ((_a = ctx[3]) == null ? void 0 : _a.length) && create_if_block_14(ctx)
  );
  let if_block2 = (
    /*nested*/
    ctx[8].children.length && create_if_block13(ctx)
  );
  function details_toggle_handler() {
    ctx[7].call(
      details,
      /*i*/
      ctx[10]
    );
  }
  return {
    c() {
      details = element("details");
      summary = element("summary");
      if (if_block0)
        if_block0.c();
      t0 = space();
      create_component(edgelink.$$.fragment);
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      attr(summary, "class", "tree-item-self is-clickable flex items-center");
      attr(details, "class", "tree-item");
    },
    m(target, anchor) {
      insert(target, details, anchor);
      append(details, summary);
      if (if_block0)
        if_block0.m(summary, null);
      append(summary, t0);
      mount_component(edgelink, summary, null);
      append(summary, t1);
      if (if_block1)
        if_block1.m(summary, null);
      append(details, t2);
      if (if_block2)
        if_block2.m(details, null);
      append(details, t3);
      details.open = /*opens*/
      ctx[5][
        /*i*/
        ctx[10]
      ];
      current = true;
      if (!mounted) {
        dispose = listen(details, "toggle", details_toggle_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a2;
      ctx = new_ctx;
      if (
        /*nested*/
        ctx[8].children.length
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty & /*nested_edges, sort*/
          18) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_24(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(summary, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const edgelink_changes = {};
      if (dirty & /*plugin*/
      1)
        edgelink_changes.plugin = /*plugin*/
        ctx[0];
      if (dirty & /*nested_edges, sort*/
      18)
        edgelink_changes.edge = /*nested*/
        ctx[8].edge;
      if (dirty & /*show_node_options*/
      4)
        edgelink_changes.show_node_options = /*show_node_options*/
        ctx[2];
      edgelink.$set(edgelink_changes);
      if (
        /*show_attributes*/
        (_a2 = ctx[3]) == null ? void 0 : _a2.length
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_14(ctx);
          if_block1.c();
          if_block1.m(summary, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*nested*/
        ctx[8].children.length
      ) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
          if (dirty & /*nested_edges, sort*/
          18) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block13(ctx);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(details, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (dirty & /*opens*/
      32) {
        details.open = /*opens*/
        ctx[5][
          /*i*/
          ctx[10]
        ];
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(edgelink.$$.fragment, local);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(edgelink.$$.fragment, local);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(details);
      }
      if (if_block0)
        if_block0.d();
      destroy_component(edgelink);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      dispose();
    }
  };
}
function create_fragment34(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*nested_edges*/
    ctx[1].sort(
      /*func*/
      ctx[6]
    )
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block12(get_each_context12(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*opens, sort, plugin, show_attributes, nested_edges, show_node_options*/
      63) {
        each_value = ensure_array_like(
          /*nested_edges*/
          ctx2[1].sort(
            /*func*/
            ctx2[6]
          )
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context12(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block12(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance34($$self, $$props, $$invalidate) {
  let { plugin } = $$props;
  let { nested_edges } = $$props;
  let { show_node_options } = $$props;
  let { show_attributes } = $$props;
  let { sort } = $$props;
  const opens = nested_edges.map(() => true);
  const func = (a, b) => sort(a.edge, b.edge);
  function details_toggle_handler(i) {
    opens[i] = this.open;
    $$invalidate(5, opens);
  }
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("nested_edges" in $$props2)
      $$invalidate(1, nested_edges = $$props2.nested_edges);
    if ("show_node_options" in $$props2)
      $$invalidate(2, show_node_options = $$props2.show_node_options);
    if ("show_attributes" in $$props2)
      $$invalidate(3, show_attributes = $$props2.show_attributes);
    if ("sort" in $$props2)
      $$invalidate(4, sort = $$props2.sort);
  };
  return [
    plugin,
    nested_edges,
    show_node_options,
    show_attributes,
    sort,
    opens,
    func,
    details_toggle_handler
  ];
}
var NestedEdgeList = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance34, create_fragment34, safe_not_equal, {
      plugin: 0,
      nested_edges: 1,
      show_node_options: 2,
      show_attributes: 3,
      sort: 4
    });
  }
};
var NestedEdgeList_default = NestedEdgeList;

// src/components/codeblocks/CodeblockTree.svelte
function get_each_context13(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function create_if_block_32(ctx) {
  let h3;
  let t1;
  let ul;
  let each_value = ensure_array_like(
    /*errors*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block13(get_each_context13(ctx, each_value, i));
  }
  return {
    c() {
      h3 = element("h3");
      h3.textContent = "Breadcrumbs Codeblock Errors";
      t1 = space();
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(h3, "class", "text-error");
      attr(ul, "class", "BC-codeblock-tree-errors");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      insert(target, t1, anchor);
      insert(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*errors*/
      4) {
        each_value = ensure_array_like(
          /*errors*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context13(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block13(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
        detach(t1);
        detach(ul);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block13(ctx) {
  let li;
  let code;
  let t0_value = (
    /*error*/
    ctx[7].message + ""
  );
  let t0;
  let t1;
  return {
    c() {
      li = element("li");
      code = element("code");
      t0 = text(t0_value);
      t1 = space();
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, code);
      append(code, t0);
      append(li, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*errors*/
      4 && t0_value !== (t0_value = /*error*/
      ctx2[7].message + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
function create_if_block_25(ctx) {
  let h3;
  let t_value = (
    /*options*/
    ctx[1].title + ""
  );
  let t;
  return {
    c() {
      h3 = element("h3");
      t = text(t_value);
      attr(h3, "class", "BC-codeblock-tree-title");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      append(h3, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*options*/
      2 && t_value !== (t_value = /*options*/
      ctx2[1].title + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
      }
    }
  };
}
function create_if_block14(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_15, create_else_block5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*options*/
    ctx2[1].flat)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block5(ctx) {
  let flatedgelist;
  let current;
  flatedgelist = new FlatEdgeList_default({
    props: {
      sort: (
        /*sort*/
        ctx[4]
      ),
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      show_attributes: (
        /*options*/
        ctx[1].show_attributes
      ),
      flat_edges: Traverse.flatten_all_paths(
        /*sliced*/
        ctx[3]
      ),
      show_node_options: (
        /*plugin*/
        ctx[0].settings.codeblocks.show_node_options
      )
    }
  });
  return {
    c() {
      create_component(flatedgelist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(flatedgelist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const flatedgelist_changes = {};
      if (dirty & /*plugin*/
      1)
        flatedgelist_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*options*/
      2)
        flatedgelist_changes.show_attributes = /*options*/
        ctx2[1].show_attributes;
      if (dirty & /*plugin*/
      1)
        flatedgelist_changes.show_node_options = /*plugin*/
        ctx2[0].settings.codeblocks.show_node_options;
      flatedgelist.$set(flatedgelist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(flatedgelist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(flatedgelist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(flatedgelist, detaching);
    }
  };
}
function create_if_block_15(ctx) {
  let nestededgelist;
  let current;
  nestededgelist = new NestedEdgeList_default({
    props: {
      sort: (
        /*sort*/
        ctx[4]
      ),
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      show_attributes: (
        /*options*/
        ctx[1].show_attributes
      ),
      nested_edges: Traverse.nest_all_paths(
        /*sliced*/
        ctx[3]
      ),
      show_node_options: (
        /*plugin*/
        ctx[0].settings.codeblocks.show_node_options
      )
    }
  });
  return {
    c() {
      create_component(nestededgelist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(nestededgelist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const nestededgelist_changes = {};
      if (dirty & /*plugin*/
      1)
        nestededgelist_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*options*/
      2)
        nestededgelist_changes.show_attributes = /*options*/
        ctx2[1].show_attributes;
      if (dirty & /*plugin*/
      1)
        nestededgelist_changes.show_node_options = /*plugin*/
        ctx2[0].settings.codeblocks.show_node_options;
      nestededgelist.$set(nestededgelist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(nestededgelist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nestededgelist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(nestededgelist, detaching);
    }
  };
}
function create_fragment35(ctx) {
  let div1;
  let t0;
  let t1;
  let div0;
  let current;
  let if_block0 = (
    /*errors*/
    ctx[2].length && create_if_block_32(ctx)
  );
  let if_block1 = (
    /*options*/
    ctx[1].title && create_if_block_25(ctx)
  );
  let if_block2 = (
    /*sliced*/
    ctx[3].length && create_if_block14(ctx)
  );
  return {
    c() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      div0 = element("div");
      if (if_block2)
        if_block2.c();
      attr(div0, "class", "BC-codeblock-tree-items");
      attr(div1, "class", "BC-codeblock-tree");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t0);
      if (if_block1)
        if_block1.m(div1, null);
      append(div1, t1);
      append(div1, div0);
      if (if_block2)
        if_block2.m(div0, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*errors*/
        ctx2[2].length
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_32(ctx2);
          if_block0.c();
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*options*/
        ctx2[1].title
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_25(ctx2);
          if_block1.c();
          if_block1.m(div1, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*sliced*/
        ctx2[3].length
      )
        if_block2.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function instance35($$self, $$props, $$invalidate) {
  let $active_file_store;
  component_subscribe($$self, active_file_store, ($$value) => $$invalidate(5, $active_file_store = $$value));
  let { plugin } = $$props;
  let { options } = $$props;
  let { errors } = $$props;
  const all_paths2 = $active_file_store && // Even tho we ensure the graph is built before the views are registered,
  // Existing views still try render before the graph is built.
  plugin.graph.hasNode($active_file_store.path) ? plugin.settings.hierarchies.map((_hierarchy, hierarchy_i) => Traverse.all_paths("depth_first", plugin.graph, $active_file_store.path, (e) => has_edge_attrs(e, {
    hierarchy_i,
    dir: options.dir,
    $or_fields: options.fields,
    $or_target_ids: options.dataview_from_paths
  }))).flat() : [];
  const sliced = all_paths2.map((path4) => path4.slice(options.depth[0], options.depth[1]));
  const sort = get_edge_sorter(options.sort, plugin.graph);
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
    if ("errors" in $$props2)
      $$invalidate(2, errors = $$props2.errors);
  };
  return [plugin, options, errors, sliced, sort];
}
var CodeblockTree = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance35, create_fragment35, safe_not_equal, { plugin: 0, options: 1, errors: 2 });
  }
};
var CodeblockTree_default = CodeblockTree;

// src/codeblocks/index.ts
var FIELDS = [
  "type",
  "dir",
  "title",
  "fields",
  "depth",
  "flat",
  "dataview-from",
  "content",
  "sort",
  "field-prefix",
  "show-attributes"
];
var parse_source = (plugin, source) => {
  const hierarchy_fields = get_all_hierarchy_fields(
    plugin.settings.hierarchies
  );
  const lines = source.split("\n");
  const errors = [];
  const parsed = {};
  lines.forEach((line) => {
    var _a;
    const [key, ...rest] = line.split(":");
    const value = rest.join(":").trim();
    if (!key || !value)
      return;
    switch (key) {
      case "type": {
        return parsed.type = value;
      }
      case "dir": {
        if (!DIRECTIONS.includes(value)) {
          return errors.push({
            path: key,
            code: "invalid_field_value",
            message: `Invalid dir: ${value}`
          });
        }
        return parsed.dir = value;
      }
      case "title": {
        return parsed.title = value;
      }
      case "fields": {
        return parsed.fields = value.split(",").map((field) => field.trim()).filter((field) => {
          if (!hierarchy_fields.includes(field)) {
            errors.push({
              path: key,
              code: "invalid_field_value",
              message: `Invalid field: ${field}. Must be one of your hierarchy fields.`
            });
            return false;
          } else
            return true;
        });
      }
      case "depth": {
        const bounds = value.split("-").map((num) => parseInt(num));
        const [min, max] = [
          Number.isNaN(bounds[0]) ? 0 : bounds[0],
          Number.isNaN(bounds[1]) ? Infinity : bounds[1]
        ];
        if (min > max) {
          errors.push({
            path: key,
            code: "invalid_field_value",
            message: `Invalid depth: ${value}. Min is greater than max.`
          });
          return parsed.depth = [0, Infinity];
        }
        return parsed.depth = [min, max];
      }
      case "flat": {
        return parsed.flat = value === "true";
      }
      case "from":
      case "dataview-from": {
        if (key === "from") {
          console.warn(
            "The 'from' field in codeblocks is deprecated in favour of 'dataview-from' instead."
          );
        }
        try {
          const pages = (_a = dataview_plugin.get_api(plugin.app)) == null ? void 0 : _a.pages(value);
          return parsed.dataview_from_paths = pages == null ? void 0 : pages.map(
            (page) => page.file.path
          );
        } catch (error) {
          return errors.push({
            path: key,
            code: "invalid_field_value",
            message: `Invalid dataview-from: ${value}. Must be a valid dataview query.`
          });
        }
      }
      case "content": {
        if (value !== "open" && value !== "closed") {
          return errors.push({
            path: key,
            code: "invalid_field_value",
            message: `Invalid content: ${value}. Valid options: open, closed`
          });
        }
        return parsed.content = value;
      }
      case "sort": {
        const [field, order] = value.split(" ");
        if (!SIMPLE_EDGE_SORT_FIELDS.includes(field) && !COMPLEX_EDGE_SORT_FIELD_PREFIXES.some(
          (f) => field.startsWith(f + ":")
        )) {
          return errors.push({
            path: key,
            code: "invalid_field_value",
            message: `Invalid sort field: ${field}. Valid options: ${SIMPLE_EDGE_SORT_FIELDS.map((f) => `"${f}"`).join(", ")}, or a complex field prefixed with: ${COMPLEX_EDGE_SORT_FIELD_PREFIXES.map(
              (f) => `"${f}"`
            ).join(", ")}`
          });
        }
        if (order && order !== "asc" && order !== "desc") {
          return errors.push({
            path: key,
            code: "invalid_field_value",
            message: `Invalid sort order: ${order}. Valid options: asc, desc, or blank (default is asc).`
          });
        }
        parsed.sort = {
          field,
          order: order === "desc" ? -1 : 1
        };
        return;
      }
      case "field-prefix": {
        errors.push({
          path: key,
          code: "deprecated_field",
          message: `The 'field-prefix' field is deprecated. Use 'show-attributes' instead.`
        });
        return;
      }
      case "show-attributes": {
        return parsed.show_attributes = value.split(",").map((attr2) => attr2.trim()).filter((attr2) => {
          if (!EDGE_ATTRIBUTES.includes(attr2)) {
            errors.push({
              path: key,
              code: "invalid_field_value",
              message: `Invalid show-attributes: ${attr2}. Valid options: ${EDGE_ATTRIBUTES.join(
                ", "
              )}`
            });
            return false;
          } else {
            return true;
          }
        });
      }
      default: {
        errors.push({
          path: key,
          code: "invalid_field_value",
          message: `Invalid codeblock field: ${key}. Valid options: ${FIELDS.join(", ")}`
        });
      }
    }
  });
  return { parsed, errors };
};
var resolve_options = (parsed) => Object.assign(
  {
    type: "tree",
    dir: "down",
    depth: [0, Infinity],
    flat: false,
    sort: {
      field: "basename",
      order: 1
    }
  },
  parsed
);
var Codeblocks = {
  FIELDS,
  parse_source,
  resolve_options
};

// src/codeblocks/MDRC.ts
var CodeblockMDRC = class extends import_obsidian20.MarkdownRenderChild {
  constructor(plugin, containerEl, source) {
    super(containerEl);
    this.plugin = plugin;
    this.source = source;
  }
  async onload() {
    console.log("CodeblockMDRC.load");
    this.containerEl.empty();
    const { parsed, errors } = Codeblocks.parse_source(
      this.plugin,
      this.source
    );
    if (errors.length)
      console.log("codeblock errors", errors);
    const options = Codeblocks.resolve_options(parsed);
    console.log("resolved codeblock options", options);
    this.component = new CodeblockTree_default({
      target: this.containerEl,
      props: {
        errors,
        options,
        plugin: this.plugin
      }
    });
  }
  onunload() {
    var _a;
    console.log("CodeblockMDRC.unload");
    (_a = this.component) == null ? void 0 : _a.$destroy();
  }
};

// src/commands/freeze_edges/index.ts
var import_obsidian21 = require("obsidian");
var linkify_edge = (plugin, edge) => {
  var _a;
  const target_file = plugin.app.vault.getAbstractFileByPath(edge.target_id);
  if (!target_file) {
    console.log("unresolved target", edge.target_id);
    return `[[${edge.target_id}]]`;
  } else if (target_file instanceof import_obsidian21.TFile) {
    return plugin.app.fileManager.generateMarkdownLink(
      target_file,
      edge.source_id,
      void 0,
      (_a = edge.target_attr.aliases) == null ? void 0 : _a.at(0)
    );
  }
};
var freeze_implied_edges_to_note = async (plugin, source_file, options) => {
  const implied_edges = plugin.graph.get_out_edges(source_file.path).filter(
    (e) => !e.attr.explicit && // Don't freeze a note to itself (self_is_sibling)
    !is_self_loop(e) && // If field === null, we don't have an opposite field to freeze to
    e.attr.field !== null
  );
  const implied_edges_by_field = group_by(
    implied_edges,
    (e) => e.attr.field
  );
  switch (options.destination) {
    case "frontmatter": {
      await plugin.app.fileManager.processFrontMatter(
        source_file,
        (frontmatter) => {
          Object.keys(implied_edges_by_field).forEach((field) => {
            const edges = implied_edges_by_field[field];
            const links = edges.map((e) => linkify_edge(plugin, e));
            const existing = frontmatter[field];
            if (existing) {
              frontmatter[field] = remove_duplicates(
                ensure_is_array(existing).concat(links)
              );
            } else {
              frontmatter[field] = links;
            }
          });
          console.log("frontmatter", frontmatter);
        }
      );
      break;
    }
    case "dataview-inline": {
      const dataview_fields = Object.keys(implied_edges_by_field).map(
        (field) => {
          const links = implied_edges_by_field[field].map(
            (e) => linkify_edge(plugin, e)
          );
          return `${field}:: ${links.join(", ")}`;
        }
      );
      await plugin.app.vault.process(source_file, (content) => {
        content += "\n\n" + dataview_fields.join("\n");
        return content;
      });
      break;
    }
  }
};

// src/commands/jump/index.ts
var import_obsidian22 = require("obsidian");
var jump_to_neighbour = async (plugin, options) => {
  const active_file = get_store_value(active_file_store);
  if (!active_file)
    return;
  const matches = plugin.graph.get_out_edges(active_file.path).filter(
    (e) => has_edge_attrs(e, options.attr) && e.target_id !== active_file.path
  );
  if (!matches.length) {
    new import_obsidian22.Notice("No matches found");
    return;
  } else {
    await plugin.app.workspace.openLinkText(
      matches[0].target_id,
      active_file.path
    );
  }
};

// src/commands/stats/index.ts
var get_graph_stats = (graph) => {
  var _a, _b;
  const stats = {
    nodes: {
      resolved: {}
    },
    edges: {
      field: {},
      source: {},
      explicit: {},
      direction: {},
      hierarchy_i: {},
      implied_kind: {}
    }
  };
  for (const node of graph.nodeEntries()) {
    const resolved = String(node.attributes.resolved);
    stats.nodes.resolved[resolved] = (stats.nodes.resolved[resolved] || 0) + 1;
  }
  for (const { attributes } of graph.edgeEntries()) {
    stats.edges.hierarchy_i[attributes.hierarchy_i] = (stats.edges.hierarchy_i[attributes.hierarchy_i] || 0) + 1;
    stats.edges.direction[attributes.dir] = (stats.edges.direction[attributes.dir] || 0) + 1;
    stats.edges.field[(_a = attributes.field) != null ? _a : "null"] = (stats.edges.field[(_b = attributes.field) != null ? _b : "null"] || 0) + 1;
    if (attributes.explicit) {
      stats.edges.source[attributes.source] = (stats.edges.source[attributes.source] || 0) + 1;
    } else {
      stats.edges.implied_kind[attributes.implied_kind] = (stats.edges.implied_kind[attributes.implied_kind] || 0) + 1;
    }
    const explicit = String(attributes.explicit);
    stats.edges.explicit[explicit] = (stats.edges.explicit[explicit] || 0) + 1;
  }
  return stats;
};

// src/modals/CreateListIndexModal.ts
var import_obsidian23 = require("obsidian");
var CreateListIndexModal = class extends import_obsidian23.Modal {
  constructor(app, plugin) {
    super(app);
    this.active_file = get_store_value(active_file_store);
    this.plugin = plugin;
    this.options = plugin.settings.commands.list_index.default_options;
  }
  onOpen() {
    if (!this.active_file) {
      new import_obsidian23.Notice("No active file");
      return this.close();
    }
    const { contentEl, plugin } = this;
    const { settings } = plugin;
    contentEl.createEl("h2", {
      text: "Create List Index"
    });
    new import_obsidian23.Setting(contentEl).setName("Hierarchy").setDesc(
      "Optionally constrain the traversal to a specific hierarchy"
    ).addDropdown((dropdown) => {
      dropdown.addOption("-1", "All");
      settings.hierarchies.forEach((hierarchy, i) => {
        dropdown.addOption(
          String(i),
          stringify_hierarchy(hierarchy)
        );
      });
      dropdown.setValue(String(this.options.hierarchy_i));
      dropdown.onChange((value) => {
        this.options.hierarchy_i = Number(value);
      });
    });
    new_setting(contentEl, {
      name: "Direction",
      desc: "Direction to traverse",
      select: {
        options: DIRECTIONS,
        value: this.options.dir,
        cb: (value) => this.options.dir = value
      }
    });
    new_setting(contentEl, {
      name: "Link Kind",
      desc: "Format to use for links",
      select: {
        options: LINK_KINDS,
        value: this.options.link_kind,
        cb: (value) => this.options.link_kind = value
      }
    });
    new_setting(contentEl, {
      name: "Indent",
      desc: "Indentation to use for each level",
      input: {
        value: this.options.indent,
        cb: (value) => this.options.indent = value
      }
    });
    new EdgeSortIdSettingItem_default({
      target: contentEl,
      props: { edge_sort_id: this.options.edge_sort_id }
    }).$on("select", (e) => {
      this.options.edge_sort_id = e.detail;
    });
    _add_settings_show_node_options(
      plugin,
      contentEl,
      {
        get: () => this.options.show_node_options,
        set: (value) => this.options.show_node_options = value
      },
      { save_and_refresh: false }
    );
    new import_obsidian23.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Build & Copy to Clipboard").setCta().onClick(async () => {
        console.log("build_list_index options", this.options);
        const list_index = ListIndex.build(
          plugin.graph,
          this.active_file.path,
          this.options
        );
        if (list_index) {
          await navigator.clipboard.writeText(list_index);
          new import_obsidian23.Notice("List index copied to clipboard");
        } else {
          new import_obsidian23.Notice("No list items to copy");
        }
        this.close();
      })
    );
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/settings/migration.ts
var import_obsidian24 = require("obsidian");
var migrate_old_settings = async (plugin) => {
  var _a;
  const old = plugin.settings;
  if (old.userHiers && old.impliedRelations) {
    const implied_relationships = {
      ...blank_hierarchy().implied_relationships,
      self_is_sibling: {
        rounds: Number(old.impliedRelations.siblingIdentity)
      },
      cousin_is_sibling: {
        rounds: Number(old.impliedRelations.cousinsIsSibling)
      },
      same_parent_is_sibling: {
        rounds: Number(old.impliedRelations.sameParentIsSibling)
      },
      same_sibling_is_sibling: {
        rounds: Number(old.impliedRelations.siblingsSiblingIsSibling)
      },
      siblings_parent_is_parent: {
        rounds: Number(old.impliedRelations.siblingsParentIsParent)
      },
      parents_sibling_is_parent: {
        rounds: Number(old.impliedRelations.parentsSiblingsIsParents)
      }
    };
    plugin.settings.hierarchies = old.userHiers.map((hierarchy) => ({
      dirs: hierarchy,
      implied_relationships
    }));
    delete old.userHiers;
    delete old.impliedRelations;
  }
  if (typeof ((_a = plugin.settings.hierarchies.at(0)) == null ? void 0 : _a.implied_relationships.cousin_is_sibling) === "boolean") {
    plugin.settings.hierarchies = plugin.settings.hierarchies.map(
      (hier) => {
        hier.implied_relationships = {
          self_is_sibling: {
            rounds: Number(
              hier.implied_relationships.self_is_sibling
            )
          },
          opposite_direction: {
            rounds: Number(
              hier.implied_relationships.opposite_direction
            )
          },
          cousin_is_sibling: {
            rounds: Number(
              hier.implied_relationships.cousin_is_sibling
            )
          },
          same_parent_is_sibling: {
            rounds: Number(
              hier.implied_relationships.same_parent_is_sibling
            )
          },
          same_sibling_is_sibling: {
            rounds: Number(
              hier.implied_relationships.same_sibling_is_sibling
            )
          },
          siblings_parent_is_parent: {
            rounds: Number(
              hier.implied_relationships.siblings_parent_is_parent
            )
          },
          parents_sibling_is_parent: {
            rounds: Number(
              hier.implied_relationships.parents_sibling_is_parent
            )
          }
        };
        return hier;
      }
    );
  }
  if (old.tagNoteField !== void 0) {
    plugin.settings.explicit_edge_sources.tag_note.default_field = old.tagNoteField;
    delete old.tagNoteField;
  }
  if (old.hierarchyNotes !== void 0 && old.hierarchyNoteIsParent !== void 0 && old.HNUpField !== void 0) {
    if (old.hierarchyNotes.length > 0) {
      new import_obsidian24.Notice(
        `DEPRECATED: The central Hierarchy Notes setting is deprecated in favour of the "${META_FIELD["list-note-field"]}" field in each hierarchy note.`
      );
    }
    delete old.HNUpField;
    delete old.hierarchyNotes;
    delete old.hierarchyNoteIsParent;
  }
  if (old.addDendronNotes !== void 0 && old.dendronNoteField !== void 0 && old.trimDendronNotes !== void 0 && old.dendronNoteDelimiter !== void 0) {
    plugin.settings.explicit_edge_sources.dendron_note = {
      enabled: old.addDendronNotes,
      default_field: old.dendronNoteField,
      delimiter: old.dendronNoteDelimiter,
      display_trimmed: old.trimDendronNotes
    };
    delete old.addDendronNotes;
    delete old.dendronNoteField;
    delete old.trimDendronNotes;
    delete old.dendronNoteDelimiter;
  }
  if (old.addDateNotes !== void 0 && old.dateNoteField !== void 0 && old.dateNoteFormat !== void 0) {
    plugin.settings.explicit_edge_sources.date_note = {
      enabled: old.addDateNotes,
      default_field: old.dateNoteField,
      date_format: old.dateNoteFormat
    };
    delete old.addDateNotes;
    delete old.dateNoteField;
    delete old.dateNoteFormat;
  }
  if (old.respectReadableLineLength !== void 0) {
    plugin.settings.views.page.all.readable_line_width = old.respectReadableLineLength;
    delete old.respectReadableLineLength;
  }
  if (old.showBCs !== void 0) {
    plugin.settings.views.page.trail.enabled = old.showBCs;
    delete old.showBCs;
  }
  if (old.showGrid !== void 0) {
    plugin.settings.views.page.trail.format = old.showGrid ? "grid" : "path";
    delete old.showGrid;
  }
  if (old.gridDefaultDepth !== void 0) {
    plugin.settings.views.page.trail.default_depth = old.gridDefaultDepth;
    delete old.gridDefaultDepth;
  }
  if (old.noPathMessage !== void 0) {
    plugin.settings.views.page.trail.no_path_message = old.noPathMessage;
    delete old.noPathMessage;
  }
  if (old.showPrevNext !== void 0) {
    plugin.settings.views.page.prev_next.enabled = old.showPrevNext;
    delete old.showPrevNext;
  }
  if (old.showRefreshNotice !== void 0 && old.refreshOnNoteSave !== void 0 && old.refreshOnNoteChange !== void 0) {
    plugin.settings.commands.rebuild_graph.notify = old.showRefreshNotice;
    plugin.settings.commands.rebuild_graph.trigger = {
      note_save: old.refreshOnNoteSave,
      layout_change: old.refreshOnNoteChange
    };
    delete old.showRefreshNotice;
    delete old.refreshOnNoteSave;
    delete old.refreshOnNoteChange;
  }
  if (old.wikilinkIndex !== void 0 && old.aliasesInIndex !== void 0 && old.createIndexIndent !== void 0) {
    plugin.settings.commands.list_index.default_options = {
      ...plugin.settings.commands.list_index.default_options,
      indent: old.createIndexIndent,
      link_kind: old.wikilinkIndex ? "wiki" : "none",
      show_node_options: {
        ...ListIndex.DEFAULT_OPTIONS.show_node_options,
        alias: old.aliasesInIndex
      }
    };
    delete old.wikilinkIndex;
    delete old.aliasesInIndex;
    delete old.createIndexIndent;
  }
  if (old.writeBCsInline !== void 0) {
    plugin.settings.commands.freeze_implied_edges.default_options.destination = old.writeBCsInline ? "dataview-inline" : "frontmatter";
    delete old.writeBCsInline;
  }
  await plugin.saveSettings();
};

// src/views/tree.ts
var import_obsidian26 = require("obsidian");

// src/menus/DirectionSelectorMenu.ts
var import_obsidian25 = require("obsidian");
var DirectionSelectorMenu = ({
  cb,
  value
}) => {
  const menu = new import_obsidian25.Menu();
  DIRECTIONS.forEach((dir) => {
    menu.addItem(
      (item) => item.setTitle(dir).setChecked(value === dir).onClick(() => {
        value = dir;
        cb(value);
      })
    );
  });
  return menu;
};

// src/components/TreeView.svelte
function create_else_block6(ctx) {
  let p;
  let t0;
  let t1;
  return {
    c() {
      p = element("p");
      t0 = text("No paths found in dir=");
      t1 = text(
        /*dir*/
        ctx[1]
      );
      attr(p, "class", "text-faint");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, t0);
      append(p, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*dir*/
      2)
        set_data(
          t1,
          /*dir*/
          ctx2[1]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block15(ctx) {
  let nestededgelist;
  let current;
  nestededgelist = new NestedEdgeList_default({
    props: {
      sort: (
        /*sort*/
        ctx[4]
      ),
      plugin: (
        /*plugin*/
        ctx[0]
      ),
      nested_edges: (
        /*nested_edges*/
        ctx[5]
      ),
      show_attributes: (
        /*show_attributes*/
        ctx[3]
      ),
      show_node_options: (
        /*plugin*/
        ctx[0].settings.views.side.tree.show_node_options
      )
    }
  });
  return {
    c() {
      create_component(nestededgelist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(nestededgelist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const nestededgelist_changes = {};
      if (dirty & /*sort*/
      16)
        nestededgelist_changes.sort = /*sort*/
        ctx2[4];
      if (dirty & /*plugin*/
      1)
        nestededgelist_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty & /*nested_edges*/
      32)
        nestededgelist_changes.nested_edges = /*nested_edges*/
        ctx2[5];
      if (dirty & /*show_attributes*/
      8)
        nestededgelist_changes.show_attributes = /*show_attributes*/
        ctx2[3];
      if (dirty & /*plugin*/
      1)
        nestededgelist_changes.show_node_options = /*plugin*/
        ctx2[0].settings.views.side.tree.show_node_options;
      nestededgelist.$set(nestededgelist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(nestededgelist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nestededgelist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(nestededgelist, detaching);
    }
  };
}
function create_key_block5(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block15, create_else_block6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*nested_edges*/
      ctx2[5].length
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_fragment36(ctx) {
  let div3;
  let div1;
  let div0;
  let rebuildgraphbutton;
  let t0;
  let edgesortidselector;
  let updating_edge_sort_id;
  let t1;
  let showattributesselectormenu;
  let updating_show_attributes;
  let t2;
  let button;
  let compass;
  let t3;
  let span;
  let t4;
  let t5;
  let div2;
  let previous_key = (
    /*nested_edges*/
    ctx[5] || /*sort*/
    ctx[4]
  );
  let current;
  let mounted;
  let dispose;
  rebuildgraphbutton = new RebuildGraphButton_default({
    props: {
      cls: "clickable-icon nav-action-button",
      plugin: (
        /*plugin*/
        ctx[0]
      )
    }
  });
  function edgesortidselector_edge_sort_id_binding(value) {
    ctx[7](value);
  }
  let edgesortidselector_props = {
    cls: "clickable-icon nav-action-button",
    exclude_fields: []
  };
  if (
    /*edge_sort_id*/
    ctx[2] !== void 0
  ) {
    edgesortidselector_props.edge_sort_id = /*edge_sort_id*/
    ctx[2];
  }
  edgesortidselector = new EdgeSortIdSelector_default({ props: edgesortidselector_props });
  binding_callbacks.push(() => bind(edgesortidselector, "edge_sort_id", edgesortidselector_edge_sort_id_binding));
  function showattributesselectormenu_show_attributes_binding(value) {
    ctx[8](value);
  }
  let showattributesselectormenu_props = {
    exclude_attributes: ["dir"],
    cls: "clickable-icon nav-action-button"
  };
  if (
    /*show_attributes*/
    ctx[3] !== void 0
  ) {
    showattributesselectormenu_props.show_attributes = /*show_attributes*/
    ctx[3];
  }
  showattributesselectormenu = new ShowAttributesSelectorMenu_default({ props: showattributesselectormenu_props });
  binding_callbacks.push(() => bind(showattributesselectormenu, "show_attributes", showattributesselectormenu_show_attributes_binding));
  compass = new compass_default({ props: { size: ICON_SIZE } });
  let key_block = create_key_block5(ctx);
  return {
    c() {
      div3 = element("div");
      div1 = element("div");
      div0 = element("div");
      create_component(rebuildgraphbutton.$$.fragment);
      t0 = space();
      create_component(edgesortidselector.$$.fragment);
      t1 = space();
      create_component(showattributesselectormenu.$$.fragment);
      t2 = space();
      button = element("button");
      create_component(compass.$$.fragment);
      t3 = space();
      span = element("span");
      t4 = text(
        /*dir*/
        ctx[1]
      );
      t5 = space();
      div2 = element("div");
      key_block.c();
      attr(button, "class", "clickable-icon nav-action-button flex items-center gap-2");
      attr(button, "aria-label", "Change direction");
      attr(div0, "class", "nav-buttons-container");
      attr(div1, "class", "nav-header");
      attr(div2, "class", "BC-tree-view-items");
      attr(div3, "class", "markdown-rendered BC-tree-view -mt-2");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div1);
      append(div1, div0);
      mount_component(rebuildgraphbutton, div0, null);
      append(div0, t0);
      mount_component(edgesortidselector, div0, null);
      append(div0, t1);
      mount_component(showattributesselectormenu, div0, null);
      append(div0, t2);
      append(div0, button);
      mount_component(compass, button, null);
      append(button, t3);
      append(button, span);
      append(span, t4);
      append(div3, t5);
      append(div3, div2);
      key_block.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[9]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const rebuildgraphbutton_changes = {};
      if (dirty & /*plugin*/
      1)
        rebuildgraphbutton_changes.plugin = /*plugin*/
        ctx2[0];
      rebuildgraphbutton.$set(rebuildgraphbutton_changes);
      const edgesortidselector_changes = {};
      if (!updating_edge_sort_id && dirty & /*edge_sort_id*/
      4) {
        updating_edge_sort_id = true;
        edgesortidselector_changes.edge_sort_id = /*edge_sort_id*/
        ctx2[2];
        add_flush_callback(() => updating_edge_sort_id = false);
      }
      edgesortidselector.$set(edgesortidselector_changes);
      const showattributesselectormenu_changes = {};
      if (!updating_show_attributes && dirty & /*show_attributes*/
      8) {
        updating_show_attributes = true;
        showattributesselectormenu_changes.show_attributes = /*show_attributes*/
        ctx2[3];
        add_flush_callback(() => updating_show_attributes = false);
      }
      showattributesselectormenu.$set(showattributesselectormenu_changes);
      if (!current || dirty & /*dir*/
      2)
        set_data(
          t4,
          /*dir*/
          ctx2[1]
        );
      if (dirty & /*nested_edges, sort*/
      48 && safe_not_equal(previous_key, previous_key = /*nested_edges*/
      ctx2[5] || /*sort*/
      ctx2[4])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block5(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(div2, null);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(rebuildgraphbutton.$$.fragment, local);
      transition_in(edgesortidselector.$$.fragment, local);
      transition_in(showattributesselectormenu.$$.fragment, local);
      transition_in(compass.$$.fragment, local);
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(rebuildgraphbutton.$$.fragment, local);
      transition_out(edgesortidselector.$$.fragment, local);
      transition_out(showattributesselectormenu.$$.fragment, local);
      transition_out(compass.$$.fragment, local);
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_component(rebuildgraphbutton);
      destroy_component(edgesortidselector);
      destroy_component(showattributesselectormenu);
      destroy_component(compass);
      key_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance36($$self, $$props, $$invalidate) {
  let nested_edges;
  let sort;
  let $active_file_store;
  component_subscribe($$self, active_file_store, ($$value) => $$invalidate(6, $active_file_store = $$value));
  let { plugin } = $$props;
  let dir = plugin.settings.views.side.tree.default_dir;
  let edge_sort_id = { field: "basename", order: 1 };
  let show_attributes = [];
  function edgesortidselector_edge_sort_id_binding(value) {
    edge_sort_id = value;
    $$invalidate(2, edge_sort_id);
  }
  function showattributesselectormenu_show_attributes_binding(value) {
    show_attributes = value;
    $$invalidate(3, show_attributes);
  }
  const click_handler = (e) => DirectionSelectorMenu({
    value: dir,
    cb: (value) => $$invalidate(1, dir = value)
  }).showAtMouseEvent(e);
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$active_file_store, plugin, dir*/
    67) {
      $:
        $$invalidate(5, nested_edges = $active_file_store && // Even tho we ensure the graph is built before the views are registered,
        // Existing views still try render before the graph is built.
        plugin.graph.hasNode($active_file_store.path) ? plugin.settings.hierarchies.map((_hierarchy, hierarchy_i) => Traverse.nest_all_paths(Traverse.all_paths(
          "depth_first",
          plugin.graph,
          $active_file_store.path,
          // Here, we ensure an edge is only considered part of a path if it is from the same hierarchy as the previous edges
          (edge) => has_edge_attrs(edge, { dir, hierarchy_i })
        ))).flat() : []);
    }
    if ($$self.$$.dirty & /*edge_sort_id, plugin*/
    5) {
      $:
        $$invalidate(4, sort = get_edge_sorter(edge_sort_id, plugin.graph));
    }
  };
  return [
    plugin,
    dir,
    edge_sort_id,
    show_attributes,
    sort,
    nested_edges,
    $active_file_store,
    edgesortidselector_edge_sort_id_binding,
    showattributesselectormenu_show_attributes_binding,
    click_handler
  ];
}
var TreeView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance36, create_fragment36, safe_not_equal, { plugin: 0 });
  }
};
var TreeView_default = TreeView;

// src/views/tree.ts
var TreeView2 = class extends import_obsidian26.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.icon = "tree-pine";
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_IDS.tree;
  }
  getDisplayText() {
    return "Tree view";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    this.component = new TreeView_default({
      target: this.contentEl,
      props: { plugin: this.plugin }
    });
  }
  async onClose() {
    var _a;
    (_a = this.component) == null ? void 0 : _a.$destroy();
  }
};

// src/main.ts
var BreadcrumbsPlugin = class extends import_obsidian27.Plugin {
  constructor() {
    super(...arguments);
    this.graph = new BCGraph();
    /** rebuild_graph, then react by updating active_file_store and redrawing page_views.
     * Optionally disable any of these steps.
     */
    this.refresh = async (options) => {
      console.group("bc.refresh");
      console.log(
        ["rebuild_graph", "active_file_store", "redraw_page_views"].filter(
          (key) => (options == null ? void 0 : options[key]) !== false
        ).join(", ")
      );
      if ((options == null ? void 0 : options.rebuild_graph) !== false) {
        const start_ms = Date.now();
        const notice = this.settings.commands.rebuild_graph.notify ? new import_obsidian27.Notice("Rebuilding graph") : null;
        console.group("rebuild_graph");
        const rebuild_results = await rebuild_graph(this);
        this.graph = rebuild_results.graph;
        console.groupEnd();
        const explicit_edge_errors = rebuild_results.explicit_edge_results.filter(
          (result) => result.errors.length
        );
        notice == null ? void 0 : notice.setMessage(
          [
            `Rebuilt graph in ${Date.now() - start_ms}ms`,
            explicit_edge_errors.length ? "\nErrors (see console for more info):" : null,
            ...explicit_edge_errors.map(
              ({ errors, source }) => `- ${source}: ${errors.length} errors`
            )
          ].filter(Boolean).join("\n")
        );
      }
      if ((options == null ? void 0 : options.active_file_store) !== false) {
        active_file_store.refresh(this.app);
      }
      if ((options == null ? void 0 : options.redraw_page_views) !== false) {
        console.groupCollapsed("redraw_page_views");
        redraw_page_views(this);
        console.groupEnd();
      }
      console.groupEnd();
    };
  }
  async onload() {
    console.log("loading breadcrumbs");
    await this.loadSettings();
    await migrate_old_settings(this);
    this.addSettingTab(new BreadcrumbsSettingTab(this.app, this));
    this.api = new BCAPI(this);
    window.BCAPI = this.api;
    this.register(
      // @ts-ignore: Don't want to make it optional, but still delete on unload
      () => delete window.BCAPI
    );
    this.app.workspace.onLayoutReady(async () => {
      console.log("onLayoutReady");
      await dataview_plugin.await_if_enabled(this);
      await this.refresh();
      this.registerEvent(
        this.app.workspace.on("layout-change", async () => {
          console.log("layout-change");
          await this.refresh({
            rebuild_graph: this.settings.commands.rebuild_graph.trigger.layout_change
          });
        })
      );
      this.registerEvent(
        this.app.vault.on("create", (file) => {
          console.log("on.create:", file.path);
          if (file instanceof import_obsidian27.TFile) {
            this.graph.upsert_node(file.path, { resolved: true });
          }
        })
      );
      this.registerEvent(
        this.app.vault.on("rename", (file, old_path) => {
          console.log("on.rename:", old_path, "->", file.path);
          if (file instanceof import_obsidian27.TFile) {
            this.graph.safe_rename_node(old_path, file.path);
          }
        })
      );
      this.registerEvent(
        this.app.vault.on("delete", (file) => {
          console.log("on.delete:", file.path);
          if (file instanceof import_obsidian27.TFile) {
            this.graph.setNodeAttribute(
              file.path,
              "resolved",
              false
            );
          }
        })
      );
      this.registerView(
        VIEW_IDS.matrix,
        (leaf) => new MatrixView(leaf, this)
      );
      this.registerView(
        VIEW_IDS.tree,
        (leaf) => new TreeView2(leaf, this)
      );
      this.registerMarkdownCodeBlockProcessor(
        "breadcrumbs",
        (source, el, ctx) => {
          const mdrc = new CodeblockMDRC(this, el, source);
          ctx.addChild(mdrc);
        }
      );
    });
    this.addCommand({
      id: "breadcrumbs:rebuild-graph",
      name: "Rebuild graph",
      callback: async () => await this.refresh()
    });
    Object.keys(VIEW_IDS).forEach((view_id) => {
      this.addCommand({
        id: `breadcrumbs:open-${view_id}-view`,
        name: `Open ${view_id} view`,
        callback: () => this.activateView(
          VIEW_IDS[view_id]
        )
      });
    });
    this.addCommand({
      id: "breadcrumbs:create-list-index",
      name: "Create list index",
      callback: () => {
        new CreateListIndexModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "breadcrumbs:graph-stats",
      name: "Print graph stats",
      callback: () => {
        const stats = get_graph_stats(this.graph);
        console.log(stats);
        new import_obsidian27.Notice("Graph stats printed to console");
      }
    });
    this.addCommand({
      id: "breadcrumbs:freeze-implied-edges-to-note",
      name: "Freeze implied edges to note",
      callback: async () => {
        const active_file = get_store_value(active_file_store);
        if (!active_file)
          return;
        await freeze_implied_edges_to_note(
          this,
          active_file,
          this.settings.commands.freeze_implied_edges.default_options
        );
        new import_obsidian27.Notice("Implied edges frozen to note");
      }
    });
    DIRECTIONS.forEach((dir) => {
      this.addCommand({
        id: `breadcrumbs:jump-to-first-neighbour-dir:${dir}`,
        name: `Jump to first neigbour in direction:${dir}`,
        callback: () => jump_to_neighbour(this, { attr: { dir } })
      });
    });
    this.settings.hierarchies.forEach((hierarchy, hierarchy_i) => {
      DIRECTIONS.forEach((dir) => {
        const fields_str = hierarchy.dirs[dir].join(",");
        if (!fields_str.length)
          return;
        this.addCommand({
          id: `breadcrumbs:jump-to-first-neighbour-field:${hierarchy_i}-${dir}`,
          name: `Jump to first neighbour by field:${fields_str}`,
          callback: () => jump_to_neighbour(this, {
            attr: { hierarchy_i, dir }
          })
        });
      });
    });
  }
  onunload() {
  }
  async loadSettings() {
    var _a;
    this.settings = deep_merge_objects(
      (_a = await this.loadData()) != null ? _a : {},
      DEFAULT_SETTINGS
    );
    console.log("bc.loadsettings", this.settings);
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // SOURCE: https://docs.obsidian.md/Plugins/User+interface/Views
  async activateView(view_id, options) {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(view_id);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = (options == null ? void 0 : options.side) === "left" ? workspace.getLeftLeaf(false) : workspace.getRightLeaf(false);
      if (!leaf) {
        console.log("bc.activateView: no leaf found");
        return;
      }
      await leaf.setViewState({ type: view_id, active: true });
    }
    workspace.revealLeaf(leaf);
  }
};
/*! Bundled license information:

lucide-svelte/dist/defaultAttributes.js:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/arrow-down-wide-narrow.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/arrow-down.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/arrow-up-narrow-wide.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/arrow-up.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/chevron-down.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/chevron-right.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/compass.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/file-json.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/plus.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/rotate-ccw.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/save.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/settings.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/trash-2.svelte:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/icons/index.js:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-svelte/dist/aliases.js:
  (**
   * @license lucide-svelte v0.360.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)
*/
